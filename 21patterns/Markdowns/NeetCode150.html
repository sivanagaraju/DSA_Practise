<!DOCTYPE html>
<html>
<head>
<title>NeetCode150.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="arrays--hashing"><strong>ARRAYS &amp; HASHING</strong></h2>
<h3 id="problem-1-contains-duplicate">Problem 1: Contains Duplicate</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: The task is to determine if a given array contains any duplicates. Specifically, we need to return <code>True</code> if any value appears at least twice in the array, and <code>False</code> if every element is distinct.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[1, 2, 3, 1]</code><br>
Output: <code>True</code> (because the number 1 appears twice).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The appropriate coding pattern here is <strong>Hashing</strong> (or <strong>Set Usage</strong>). This is because we need to quickly check if we've already seen a value before. By using a set, we can keep track of the elements we encounter in the array. If we find an element that is already in the set, we return <code>True</code> immediately. Otherwise, after iterating through the array, we return <code>False</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contains_duplicate</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Initialize an empty set to store unique elements</span>
    seen = set()
    
    <span class="hljs-comment"># Iterate through each number in the list</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        <span class="hljs-comment"># If the current number is already in the set, it means we found a duplicate</span>
        <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> seen:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># Return True as soon as we find a duplicate</span>
        
        <span class="hljs-comment"># Add the number to the set if it's not already present</span>
        seen.add(num)
    
    <span class="hljs-comment"># If no duplicates were found after iterating through the list, return False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list once</span>
<span class="hljs-comment"># Space Complexity: O(n) - we use a set to store the numbers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(contains_duplicate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<p><strong>Explanation</strong>:</p>
<ol>
<li>We use a <strong>set</strong> because checking membership in a set is O(1) on average.</li>
<li>We loop through the array:
<ul>
<li>If we encounter a number that is already in the set, we immediately return <code>True</code>.</li>
<li>If it's not in the set, we add it to the set.</li>
</ul>
</li>
<li>If we finish the loop without finding any duplicates, we return <code>False</code>.</li>
</ol>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li>Another approach could be sorting the array and then checking adjacent elements for duplicates. However, this is less efficient since sorting takes O(n log n) time.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contains_duplicate_alternative</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Sort the array in-place, so duplicate elements will be adjacent</span>
    nums.sort()
    
    <span class="hljs-comment"># Check each pair of adjacent elements in the sorted list</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(nums)):
        <span class="hljs-comment"># If any pair of adjacent elements are the same, a duplicate is found</span>
        <span class="hljs-keyword">if</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># Return True if a duplicate is found</span>
    
    <span class="hljs-comment"># If no duplicates are found after checking all pairs, return False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Time Complexity: O(n log n) - due to sorting</span>
<span class="hljs-comment"># Space Complexity: O(1) - no additional space is used apart from the input list</span>

<span class="hljs-comment"># Test the alternative function</span>
print(contains_duplicate_alternative([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li>Here, we sort the array first, which takes O(n log n) time.</li>
<li>Then, we check adjacent elements in the sorted array. If any two adjacent elements are the same, we return <code>True</code>.</li>
</ul>
<hr>
<h3 id="problem-2-valid-anagram">Problem 2: Valid Anagram</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: The task is to determine if two strings are anagrams of each other. Two strings are anagrams if they contain the same characters, with the same frequencies, but possibly in a different order.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>s = &quot;anagram&quot;, t = &quot;nagaram&quot;</code><br>
Output: <code>True</code> (since both strings contain the same letters in any order).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem fits well with the <strong>Hashing</strong> or <strong>Frequency Counting</strong> pattern. We can use a dictionary (or an array for constant-size alphabets) to count the frequency of each character in the strings, and then compare these frequencies.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_anagram</span><span class="hljs-params">(s, t)</span>:</span>
    <span class="hljs-comment"># If the two strings have different lengths, they can't be anagrams</span>
    <span class="hljs-keyword">if</span> len(s) != len(t):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># Dictionary to count the frequency of characters in the first string</span>
    count = {}
    
    <span class="hljs-comment"># Count the frequency of each character in the first string</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:
        count[char] = count.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the count for each character</span>
    
    <span class="hljs-comment"># Iterate through the second string</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> t:
        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> count:
            count[char] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># Decrement the count for each character</span>
            <span class="hljs-comment"># If the count goes to zero, we remove the character from the dictionary</span>
            <span class="hljs-keyword">if</span> count[char] == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">del</span> count[char]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># If a character is not in the dictionary, it's not an anagram</span>
    
    <span class="hljs-comment"># If the dictionary is empty, both strings are anagrams</span>
    <span class="hljs-keyword">return</span> len(count) == <span class="hljs-number">0</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the length of the strings</span>
<span class="hljs-comment"># Space Complexity: O(1) - the space required for the dictionary is constant for 26 letters</span>

<span class="hljs-comment"># Test the function with the example</span>
print(is_anagram(<span class="hljs-string">"anagram"</span>, <span class="hljs-string">"nagaram"</span>))  <span class="hljs-comment"># Output: True</span>

</div></code></pre>
<p><strong>Explanation</strong>:</p>
<ol>
<li>We first check if the lengths of the strings are equal. If not, they cannot be anagrams.</li>
<li>We use a dictionary to count the frequency of characters in the first string.</li>
<li>Then, for the second string, we decrease the count of the characters in the dictionary. If any character does not exist or the counts don't match, we return <code>False</code>.</li>
<li>If we finish and the dictionary is empty, the strings are anagrams.</li>
</ol>
<hr>
<h3 id="problem-3-two-sum">Problem 3: Two Sum</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an array of integers and a target integer. The task is to find two distinct indices such that the sum of the numbers at those indices is equal to the target.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code><br>
Output: <code>[0, 1]</code> (since nums[0] + nums[1] = 9).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The <strong>Hashing</strong> pattern works well here. We can keep track of the complement (target - current element) in a dictionary while iterating through the list. If we encounter an element that is already in the dictionary (i.e., its complement was seen earlier), we return the indices.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">two_sum</span><span class="hljs-params">(nums, target)</span>:</span>
    <span class="hljs-comment"># Dictionary to store the complement (target - num) and its index</span>
    complement_map = {}
    
    <span class="hljs-comment"># Iterate over the list with both index and value</span>
    <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> enumerate(nums):
        complement = target - num  <span class="hljs-comment"># Calculate the complement that adds up to the target</span>
        
        <span class="hljs-comment"># Check if the complement exists in the dictionary (i.e., we've seen it before)</span>
        <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> complement_map:
            <span class="hljs-comment"># Return the index of the complement and the current index</span>
            <span class="hljs-keyword">return</span> [complement_map[complement], i]
        
        <span class="hljs-comment"># Otherwise, store the current number's index in the dictionary</span>
        complement_map[num] = i
    
    <span class="hljs-comment"># In case no solution exists, return an empty list</span>
    <span class="hljs-keyword">return</span> []

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list once</span>
<span class="hljs-comment"># Space Complexity: O(n) - we use a dictionary to store the complements and their indices</span>

<span class="hljs-comment"># Test the function with the example</span>
print(two_sum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>))  <span class="hljs-comment"># Output: [0, 1]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>An alternative approach involves <strong>brute force</strong>, where we check every pair of elements and return the indices if their sum matches the target. This method is simple but inefficient for large inputs.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">two_sum_brute_force</span><span class="hljs-params">(nums, target)</span>:</span>
    <span class="hljs-comment"># Iterate over each pair of numbers in the list</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i + <span class="hljs-number">1</span>, len(nums)):
            <span class="hljs-comment"># If the sum of the two numbers equals the target, return their indices</span>
            <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:
                <span class="hljs-keyword">return</span> [i, j]
    
    <span class="hljs-comment"># In case no solution exists, return an empty list</span>
    <span class="hljs-keyword">return</span> []

<span class="hljs-comment"># Time Complexity: O(n^2) - we check every pair of numbers</span>
<span class="hljs-comment"># Space Complexity: O(1) - no extra space is used apart from the indices</span>

<span class="hljs-comment"># Test the function with the example</span>
print(two_sum_brute_force([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>))  <span class="hljs-comment"># Output: [0, 1]</span>

</div></code></pre>
<p><strong>Note</strong>: The brute-force approach is slower, with a time complexity of <strong>O(n²)</strong>, compared to the more efficient hashing approach, which has <strong>O(n)</strong> time complexity.</p>
<hr>
<h3 id="problem-4-group-anagrams">Problem 4: Group Anagrams</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of strings, group the anagrams together. Anagrams are strings made up of the same characters with the same frequencies, but possibly in different orders.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code><br>
Output: <code>[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The appropriate pattern is <strong>Hashing</strong>. By using a dictionary where the keys are sorted versions of the words (or frequency counts), and the values are lists of words that match that key, we can easily group the anagrams.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group_anagrams</span><span class="hljs-params">(strs)</span>:</span>
    <span class="hljs-comment"># Dictionary to group words by their sorted character tuple</span>
    anagram_map = {}
    
    <span class="hljs-comment"># Iterate through each word in the input list</span>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> strs:
        <span class="hljs-comment"># Sort the characters in the word to form a key</span>
        key = tuple(sorted(word))
        
        <span class="hljs-comment"># Add the word to the list corresponding to the sorted key in the dictionary</span>
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> anagram_map:
            anagram_map[key] = []
        anagram_map[key].append(word)
    
    <span class="hljs-comment"># Return the values (grouped anagrams) as a list of lists</span>
    <span class="hljs-keyword">return</span> list(anagram_map.values())

<span class="hljs-comment"># Time Complexity: O(n * k log k) - where n is the number of words and k is the average length of the word (sorting each word)</span>
<span class="hljs-comment"># Space Complexity: O(n * k) - space needed to store the words and their corresponding sorted keys</span>

<span class="hljs-comment"># Test the function with the example</span>
print(group_anagrams([<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]))  
<span class="hljs-comment"># Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>Another approach could be using <strong>character frequency</strong> as the key instead of sorting. Instead of sorting the string, we count the frequency of each character and use the frequency tuple as the key.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group_anagrams_alternative</span><span class="hljs-params">(strs)</span>:</span>
    <span class="hljs-comment"># Dictionary to group words by their character frequency tuple</span>
    anagram_map = {}
    
    <span class="hljs-comment"># Iterate through each word in the input list</span>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> strs:
        <span class="hljs-comment"># Create a list of 26 zeros to represent the frequency of each character</span>
        count = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>
        
        <span class="hljs-comment"># Count the frequency of each character in the word</span>
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:
            count[ord(char) - ord(<span class="hljs-string">'a'</span>)] += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Use the tuple of counts as the key</span>
        key = tuple(count)
        
        <span class="hljs-comment"># Add the word to the corresponding list in the dictionary</span>
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> anagram_map:
            anagram_map[key] = []
        anagram_map[key].append(word)
    
    <span class="hljs-comment"># Return the values (grouped anagrams) as a list of lists</span>
    <span class="hljs-keyword">return</span> list(anagram_map.values())

<span class="hljs-comment"># Time Complexity: O(n * k) - n is the number of words, and k is the max length of a word (counting each character)</span>
<span class="hljs-comment"># Space Complexity: O(n * k) - space needed to store the words and their corresponding frequency counts</span>

<span class="hljs-comment"># Test the function with the example</span>
print(group_anagrams_alternative([<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]))  
<span class="hljs-comment"># Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</span>

</div></code></pre>
<p><strong>Note</strong>: This approach avoids sorting the string and may perform better when the strings are long, but its complexity depends on the number of characters (26 for lowercase letters).</p>
<hr>
<h3 id="problem-5-top-k-frequent-elements">Problem 5: Top K Frequent Elements</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an integer array, return the k most frequent elements.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1, 1, 1, 2, 2, 3]</code>, <code>k = 2</code><br>
Output: <code>[1, 2]</code> (since 1 appears 3 times, 2 appears 2 times).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The pattern to solve this problem is <strong>Heap</strong> or <strong>Bucket Sort</strong>. We can either use a max-heap to keep track of the top k elements, or use bucket sort if the number of unique elements is small compared to the array size.</li>
</ul>
<h4 id="solution-heap-based">Solution (Heap-based):</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_k_frequent</span><span class="hljs-params">(nums, k)</span>:</span>
    <span class="hljs-comment"># Create a frequency map of elements in the list</span>
    count = Counter(nums)
    
    <span class="hljs-comment"># Use a heap to get the k most frequent elements</span>
    <span class="hljs-comment"># 'nlargest' returns the k largest elements based on their frequency count</span>
    <span class="hljs-keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)

<span class="hljs-comment"># Time Complexity: O(n log k) - counting is O(n), and extracting k elements from the heap is O(log k)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the frequency count</span>

<span class="hljs-comment"># Test the function with the example</span>
print(top_k_frequent([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">2</span>))  <span class="hljs-comment"># Output: [1, 2]</span>

</div></code></pre>
<h4 id="alternative-approach-bucket-sort">Alternative Approach (Bucket Sort):</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_k_frequent_bucket</span><span class="hljs-params">(nums, k)</span>:</span>
    <span class="hljs-comment"># Frequency map to count occurrences of each number</span>
    freq_map = defaultdict(int)
    
    <span class="hljs-comment"># Count the frequency of each number in the input list</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        freq_map[num] += <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Create buckets: each index represents a frequency, and the value is a list of numbers</span>
    bucket = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(nums) + <span class="hljs-number">1</span>)]
    
    <span class="hljs-comment"># Populate the bucket based on the frequency of each number</span>
    <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> freq_map.items():
        bucket[freq].append(num)
    
    <span class="hljs-comment"># Gather the k most frequent elements</span>
    result = []
    
    <span class="hljs-comment"># Traverse the bucket from the highest frequency to the lowest</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(bucket) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):
        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> bucket[i]:
            result.append(num)
            <span class="hljs-comment"># If we've collected k elements, return the result</span>
            <span class="hljs-keyword">if</span> len(result) == k:
                <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n) - for counting and bucket sorting</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the frequency map and buckets</span>

<span class="hljs-comment"># Test the function with the example</span>
print(top_k_frequent_bucket([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">2</span>))  <span class="hljs-comment"># Output: [1, 2]</span>
</div></code></pre>
<hr>
<h3 id="problem-6-encode-and-decode-strings">Problem 6: Encode and Decode Strings</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: The task is to encode a list of strings into a single string and then decode that string back into the original list of strings. We need a reliable method to ensure that when we decode the string, it splits the original list correctly (even if there are special characters like commas or spaces in the strings).</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[&quot;lint&quot;, &quot;code&quot;, &quot;love&quot;, &quot;you&quot;]</code><br>
Encoded Output: <code>&quot;4#lint4#code4#love3#you&quot;</code><br>
Decoded Output: <code>[&quot;lint&quot;, &quot;code&quot;, &quot;love&quot;, &quot;you&quot;]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>custom encoding</strong>. We encode the length of each string followed by a delimiter (<code>#</code>) and the actual string. When decoding, we extract the length and retrieve the corresponding substring.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span><span class="hljs-params">(strs)</span>:</span>
    <span class="hljs-string">"""
    Encodes a list of strings to a single string.
    """</span>
    encoded_str = <span class="hljs-string">""</span>
    
    <span class="hljs-comment"># Iterate through each string in the list</span>
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:
        <span class="hljs-comment"># For each string, prepend its length followed by a delimiter '#'</span>
        encoded_str += str(len(s)) + <span class="hljs-string">'#'</span> + s
    
    <span class="hljs-keyword">return</span> encoded_str

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span><span class="hljs-params">(encoded_str)</span>:</span>
    <span class="hljs-string">"""
    Decodes a single string to a list of strings.
    """</span>
    decoded_strs = []
    i = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Iterate through the encoded string</span>
    <span class="hljs-keyword">while</span> i &lt; len(encoded_str):
        <span class="hljs-comment"># Find the position of the delimiter '#' to get the length of the next string</span>
        j = encoded_str.index(<span class="hljs-string">'#'</span>, i)
        length = int(encoded_str[i:j])  <span class="hljs-comment"># Convert the substring (length) to an integer</span>
        i = j + <span class="hljs-number">1</span>  <span class="hljs-comment"># Move past the delimiter</span>
        
        <span class="hljs-comment"># Extract the actual string using the length we just decoded</span>
        decoded_strs.append(encoded_str[i:i + length])
        
        <span class="hljs-comment"># Move the index to the start of the next encoded part</span>
        i += length
    
    <span class="hljs-keyword">return</span> decoded_strs

<span class="hljs-comment"># Time Complexity: O(n) - where n is the total length of all the strings combined (for both encode and decode)</span>
<span class="hljs-comment"># Space Complexity: O(n) - we use extra space for the encoded string and decoded list</span>

<span class="hljs-comment"># Test the functions</span>
encoded = encode([<span class="hljs-string">"lint"</span>, <span class="hljs-string">"code"</span>, <span class="hljs-string">"love"</span>, <span class="hljs-string">"you"</span>])
print(encoded)  <span class="hljs-comment"># Output: "4#lint4#code4#love3#you"</span>
decoded = decode(encoded)
print(decoded)  <span class="hljs-comment"># Output: ["lint", "code", "love", "you"]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> for this encoding and decoding method is required, as this custom encoding method efficiently solves the problem.</li>
</ul>
<hr>
<h3 id="problem-7-product-of-array-except-self">Problem 7: Product of Array Except Self</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of integers, return an array such that each element at index <code>i</code> is the product of all numbers in the array except the one at index <code>i</code>. You cannot use division, and the time complexity must be O(n).</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[1, 2, 3, 4]</code><br>
Output: <code>[24, 12, 8, 6]</code> (since 24 = 2*3*4, 12 = 1*3*4, etc.)</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>prefix and suffix product</strong> pattern. We calculate two arrays: the product of all elements to the left of the current element (prefix product) and the product of all elements to the right (suffix product). We then multiply these two for each element.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">product_except_self</span><span class="hljs-params">(nums)</span>:</span>
    n = len(nums)
    
    <span class="hljs-comment"># Initialize the result array with 1's to store the final products</span>
    result = [<span class="hljs-number">1</span>] * n
    
    <span class="hljs-comment"># Step 1: Calculate prefix products (product of all elements to the left)</span>
    prefix = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        result[i] = prefix  <span class="hljs-comment"># Store the prefix product</span>
        prefix *= nums[i]   <span class="hljs-comment"># Update the prefix for the next element</span>
    
    <span class="hljs-comment"># Step 2: Calculate suffix products (product of all elements to the right)</span>
    suffix = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):
        result[i] *= suffix  <span class="hljs-comment"># Multiply the stored prefix product with the suffix product</span>
        suffix *= nums[i]    <span class="hljs-comment"># Update the suffix for the next element</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the array twice (once for prefix, once for suffix)</span>
<span class="hljs-comment"># Space Complexity: O(1) - we use constant space for the result, not counting the output array</span>

<span class="hljs-comment"># Test the function with the example</span>
print(product_except_self([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]))  <span class="hljs-comment"># Output: [24, 12, 8, 6]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this method avoids division and meets the O(n) time complexity requirement.</li>
</ul>
<hr>
<h3 id="problem-8-valid-sudoku">Problem 8: Valid Sudoku</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Determine if a 9x9 Sudoku board is valid. Each row, each column, and each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. The board may be partially filled with empty cells represented by '.'.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], 
 [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], 
 [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], 
 [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], 
 [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], 
 [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], 
 [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], 
 [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], 
 [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The pattern here is <strong>hashing</strong>. We need to ensure there are no duplicate numbers in each row, column, and 3x3 grid. We can use sets to track the numbers we've seen in each of these regions.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid_sudoku</span><span class="hljs-params">(board)</span>:</span>
    <span class="hljs-comment"># Create sets to track the numbers seen in rows, columns, and boxes</span>
    rows = [set() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>)]
    cols = [set() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>)]
    boxes = [set() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>)]
    
    <span class="hljs-comment"># Iterate over each cell in the 9x9 board</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>):
            num = board[i][j]
            <span class="hljs-keyword">if</span> num == <span class="hljs-string">'.'</span>:
                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># Skip empty cells</span>
            
            <span class="hljs-comment"># Calculate the index for the 3x3 sub-box</span>
            box_index = (i // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + (j // <span class="hljs-number">3</span>)
            
            <span class="hljs-comment"># Check if the number is already seen in the current row, column, or box</span>
            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> rows[i] <span class="hljs-keyword">or</span> num <span class="hljs-keyword">in</span> cols[j] <span class="hljs-keyword">or</span> num <span class="hljs-keyword">in</span> boxes[box_index]:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># The board is invalid if there's a duplicate</span>
            
            <span class="hljs-comment"># Add the number to the respective row, column, and box sets</span>
            rows[i].add(num)
            cols[j].add(num)
            boxes[box_index].add(num)
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># If no duplicates were found, the board is valid</span>

<span class="hljs-comment"># Time Complexity: O(1) - since the board is always 9x9, the operations are constant</span>
<span class="hljs-comment"># Space Complexity: O(1) - the space for rows, cols, and boxes is fixed for a 9x9 board</span>

<span class="hljs-comment"># Test the function with the example</span>
print(is_valid_sudoku([[<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>], 
                       [<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>], 
                       [<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>], 
                       [<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>], 
                       [<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>], 
                       [<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>], 
                       [<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>], 
                       [<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>], 
                       [<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]))  
<span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as this is the optimal method for checking the validity of a Sudoku board.</li>
</ul>
<hr>
<h3 id="problem-9-longest-consecutive-sequence">Problem 9: Longest Consecutive Sequence</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an unsorted array of integers. Find the length of the longest consecutive elements sequence. The solution must run in O(n) time.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[100, 4, 200, 1, 3, 2]</code><br>
Output: <code>4</code> (because the longest consecutive sequence is <code>[1, 2, 3, 4]</code>).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>set</strong>. By inserting all elements into a set and then checking for sequences starting with elements that do not have a smaller predecessor, we can efficiently find the longest consecutive sequence.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest_consecutive</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Create a set to store all the unique numbers from the input array</span>
    num_set = set(nums)
    longest_streak = <span class="hljs-number">0</span>  <span class="hljs-comment"># Variable to track the longest consecutive sequence</span>
    
    <span class="hljs-comment"># Iterate through each number in the set</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_set:
        <span class="hljs-comment"># Check if this number is the start of a new sequence (i.e., num-1 is not in the set)</span>
        <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_set:
            current_num = num
            current_streak = <span class="hljs-number">1</span>  <span class="hljs-comment"># Start a new streak</span>
            
            <span class="hljs-comment"># Continue the streak as long as the next consecutive number exists</span>
            <span class="hljs-keyword">while</span> current_num + <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> num_set:
                current_num += <span class="hljs-number">1</span>
                current_streak += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the streak length</span>
            
            <span class="hljs-comment"># Update the longest streak found so far</span>
            longest_streak = max(longest_streak, current_streak)
    
    <span class="hljs-keyword">return</span> longest_streak

<span class="hljs-comment"># Time Complexity: O(n) - we traverse each element in the set once</span>
<span class="hljs-comment"># Space Complexity: O(n) - space for storing the set of numbers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(longest_consecutive([<span class="hljs-number">100</span>, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed because this approach provides the optimal O(n) time complexity solution.</li>
</ul>
<hr>
<h3 id="problem-10-valid-palindrome">Problem 10: Valid Palindrome</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, <code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>&quot;A man, a plan, a canal: Panama&quot;</code><br>
Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Two Pointers</strong> pattern. We use one pointer starting at the beginning and one at the end, skipping non-alphanumeric characters and comparing the remaining characters in a case-insensitive manner.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_palindrome</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-comment"># Initialize two pointers, one at the start and one at the end of the string</span>
    left, right = <span class="hljs-number">0</span>, len(s) - <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">while</span> left &lt; right:
        <span class="hljs-comment"># Move the left pointer to the next alphanumeric character</span>
        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[left].isalnum():
            left += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Move the right pointer to the previous alphanumeric character</span>
        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[right].isalnum():
            right -= <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Compare the characters at left and right pointers (case-insensitive)</span>
        <span class="hljs-keyword">if</span> s[left].lower() != s[right].lower():
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Return False if the characters don't match</span>
        
        <span class="hljs-comment"># Move both pointers towards the center</span>
        left += <span class="hljs-number">1</span>
        right -= <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># Return True if all characters match</span>

<span class="hljs-comment"># Time Complexity: O(n) - we scan through the string once</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the two pointers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(is_palindrome(<span class="hljs-string">"A man, a plan, a canal: Panama"</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed because this two-pointer method efficiently solves the problem in O(n) time.</li>
</ul>
<hr>
<h3 id="problem-11-two-sum-ii---input-array-is-sorted">Problem 11: Two Sum II - Input Array Is Sorted</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of integers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target. You must return the indices of the two numbers (1-indexed).</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>numbers = [2, 7, 11, 15]</code>, <code>target = 9</code><br>
Output: <code>[1, 2]</code> (since 2 + 7 = 9)</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>Since the array is sorted, we can apply the <strong>Two Pointers</strong> technique. One pointer starts at the beginning and the other at the end. We check the sum of the two numbers, adjusting the pointers based on whether the sum is too small or too large.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">two_sum_sorted</span><span class="hljs-params">(numbers, target)</span>:</span>
    <span class="hljs-comment"># Initialize two pointers, one at the start and one at the end</span>
    left, right = <span class="hljs-number">0</span>, len(numbers) - <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">while</span> left &lt; right:
        current_sum = numbers[left] + numbers[right]  <span class="hljs-comment"># Calculate the sum of the two pointers</span>
        
        <span class="hljs-comment"># If the sum matches the target, return the 1-indexed positions</span>
        <span class="hljs-keyword">if</span> current_sum == target:
            <span class="hljs-keyword">return</span> [left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>]
        
        <span class="hljs-comment"># If the sum is too small, move the left pointer to the right</span>
        <span class="hljs-keyword">elif</span> current_sum &lt; target:
            left += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># If the sum is too large, move the right pointer to the left</span>
        <span class="hljs-keyword">else</span>:
            right -= <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> []  <span class="hljs-comment"># In case no solution exists</span>

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the array once</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the two pointers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(two_sum_sorted([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>))  <span class="hljs-comment"># Output: [1, 2]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed because the two-pointer approach is optimal for sorted arrays.</li>
</ul>
<hr>
<h3 id="problem-12-3sum">Problem 12: 3Sum</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an integer array <code>nums</code>, return all unique triplets that sum to zero. The solution set must not contain duplicate triplets.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[-1, 0, 1, 2, -1, -4]</code><br>
Output: <code>[[-1, -1, 2], [-1, 0, 1]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem is a variation of the <strong>Two Pointers</strong> technique but extended to three elements. First, sort the array, and then for each element, use two pointers to find pairs that sum to the negative of the current element.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">three_sum</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Sort the array to use the two-pointer approach</span>
    nums.sort()
    result = []
    
    <span class="hljs-comment"># Iterate through the array, treating each number as the potential first element of a triplet</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
        <span class="hljs-comment"># Skip duplicate elements to avoid repeating triplets</span>
        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-comment"># Use two pointers to find two numbers that sum up to -nums[i]</span>
        left, right = i + <span class="hljs-number">1</span>, len(nums) - <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> left &lt; right:
            current_sum = nums[i] + nums[left] + nums[right]
            
            <span class="hljs-keyword">if</span> current_sum == <span class="hljs-number">0</span>:
                result.append([nums[i], nums[left], nums[right]])
                
                <span class="hljs-comment"># Move the left pointer and skip duplicates</span>
                left += <span class="hljs-number">1</span>
                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] == nums[left - <span class="hljs-number">1</span>]:
                    left += <span class="hljs-number">1</span>
                
                <span class="hljs-comment"># Move the right pointer and skip duplicates</span>
                right -= <span class="hljs-number">1</span>
                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] == nums[right + <span class="hljs-number">1</span>]:
                    right -= <span class="hljs-number">1</span>
            
            <span class="hljs-comment"># If the sum is less than zero, move the left pointer to the right</span>
            <span class="hljs-keyword">elif</span> current_sum &lt; <span class="hljs-number">0</span>:
                left += <span class="hljs-number">1</span>
            
            <span class="hljs-comment"># If the sum is greater than zero, move the right pointer to the left</span>
            <span class="hljs-keyword">else</span>:
                right -= <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n^2) - for each element, we perform a two-pointer search</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the pointers (not counting the output list)</span>

<span class="hljs-comment"># Test the function with the example</span>
print(three_sum([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>]))  <span class="hljs-comment"># Output: [[-1, -1, 2], [-1, 0, 1]]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed because this method, using sorting and two pointers, is the most efficient.</li>
</ul>
<hr>
<h3 id="problem-13-container-with-most-water">Problem 13: Container With Most Water</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given <code>n</code> non-negative integers <code>a1, a2, ..., an</code>, where each represents a point at coordinate <code>(i, ai)</code>, the task is to find two lines that, together with the x-axis, form a container that holds the most water. The goal is to return the maximum amount of water the container can store.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[1,8,6,2,5,4,8,3,7]</code><br>
Output: <code>49</code> (between lines at indices 1 and 8, heights 8 and 7, area is 49).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Two Pointers</strong> technique. We initialize two pointers, one at the beginning and the other at the end, and calculate the area. Then, we move the pointer that points to the shorter line inward, aiming to maximize the area.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_area</span><span class="hljs-params">(height)</span>:</span>
    <span class="hljs-comment"># Initialize two pointers at the beginning and end of the list</span>
    left, right = <span class="hljs-number">0</span>, len(height) - <span class="hljs-number">1</span>
    max_water = <span class="hljs-number">0</span>  <span class="hljs-comment"># Variable to store the maximum amount of water</span>
    
    <span class="hljs-comment"># Continue moving the pointers towards each other</span>
    <span class="hljs-keyword">while</span> left &lt; right:
        <span class="hljs-comment"># Calculate the current area (distance between pointers * height of shorter line)</span>
        current_area = (right - left) * min(height[left], height[right])
        
        <span class="hljs-comment"># Update the maximum water if the current area is larger</span>
        max_water = max(max_water, current_area)
        
        <span class="hljs-comment"># Move the pointer that points to the shorter line</span>
        <span class="hljs-keyword">if</span> height[left] &lt; height[right]:
            left += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            right -= <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> max_water

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list once with two pointers</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the two pointers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(max_area([<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]))  <span class="hljs-comment"># Output: 49</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as the two-pointer technique provides an efficient solution in O(n) time.</li>
</ul>
<hr>
<h3 id="problem-14-trapping-rain-water">Problem 14: Trapping Rain Water</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code><br>
Output: <code>6</code> (The trapped water is above the bars at indices 2, 4, 5, 6, 9).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Two Pointers</strong> pattern, where we maintain two pointers and track the maximum heights on the left and right of the current position. We calculate how much water can be trapped at each step.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trap</span><span class="hljs-params">(height)</span>:</span>
    <span class="hljs-comment"># Initialize two pointers, one at the start and one at the end of the list</span>
    left, right = <span class="hljs-number">0</span>, len(height) - <span class="hljs-number">1</span>
    left_max, right_max = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># Variables to track the maximum heights on the left and right</span>
    water_trapped = <span class="hljs-number">0</span>  <span class="hljs-comment"># Variable to store the total amount of trapped water</span>
    
    <span class="hljs-comment"># Continue processing while the two pointers don't cross</span>
    <span class="hljs-keyword">while</span> left &lt; right:
        <span class="hljs-comment"># If the left height is smaller, process from the left side</span>
        <span class="hljs-keyword">if</span> height[left] &lt; height[right]:
            <span class="hljs-comment"># Update the maximum height on the left</span>
            <span class="hljs-keyword">if</span> height[left] &gt;= left_max:
                left_max = height[left]
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># Calculate trapped water based on the difference between the max height and current height</span>
                water_trapped += left_max - height[left]
            left += <span class="hljs-number">1</span>
        <span class="hljs-comment"># If the right height is smaller, process from the right side</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Update the maximum height on the right</span>
            <span class="hljs-keyword">if</span> height[right] &gt;= right_max:
                right_max = height[right]
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># Calculate trapped water based on the difference between the max height and current height</span>
                water_trapped += right_max - height[right]
            right -= <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> water_trapped

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list once with two pointers</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the two pointers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(trap([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this two-pointer solution is optimal for this problem, achieving O(n) time complexity.</li>
</ul>
<hr>
<h3 id="problem-15-best-time-to-buy-and-sell-stock">Problem 15: Best Time to Buy and Sell Stock</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an array where each element represents the price of a given stock on that day. You want to maximize your profit by choosing a single day to buy one stock and another day in the future to sell it. Find the maximum profit you can achieve.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[7,1,5,3,6,4]</code><br>
Output: <code>5</code> (buy on day 2 at price 1 and sell on day 5 at price 6, profit = 6 - 1 = 5).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Single Pass</strong> approach. We iterate through the array, keeping track of the minimum price seen so far and calculating the maximum profit we can get if we sell on each day.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_profit</span><span class="hljs-params">(prices)</span>:</span>
    <span class="hljs-comment"># Initialize variables to track the minimum price and the maximum profit</span>
    min_price = float(<span class="hljs-string">'inf'</span>)
    max_profit = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Iterate through the list of prices</span>
    <span class="hljs-keyword">for</span> price <span class="hljs-keyword">in</span> prices:
        <span class="hljs-comment"># Update the minimum price if we find a new lower price</span>
        <span class="hljs-keyword">if</span> price &lt; min_price:
            min_price = price
        <span class="hljs-comment"># Calculate the profit if we sell at the current price</span>
        <span class="hljs-keyword">elif</span> price - min_price &gt; max_profit:
            max_profit = price - min_price
    
    <span class="hljs-keyword">return</span> max_profit

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list once</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for tracking the minimum price and maximum profit</span>

<span class="hljs-comment"># Test the function with the example</span>
print(max_profit([<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]))  <span class="hljs-comment"># Output: 5</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this single-pass solution provides the optimal result in O(n) time.</li>
</ul>
<hr>
<h3 id="problem-16-longest-substring-without-repeating-characters">Problem 16: Longest Substring Without Repeating Characters</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string <code>s</code>, find the length of the longest substring without repeating characters.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>&quot;abcabcbb&quot;</code><br>
Output: <code>3</code> (The answer is <code>&quot;abc&quot;</code>, with the length of 3).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Sliding Window</strong> pattern. We use a sliding window to keep track of the current substring without repeating characters, adjusting the window as needed.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length_of_longest_substring</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-comment"># Dictionary to store the last index of each character</span>
    char_map = {}
    left = <span class="hljs-number">0</span>  <span class="hljs-comment"># Left boundary of the sliding window</span>
    max_length = <span class="hljs-number">0</span>  <span class="hljs-comment"># Variable to store the maximum length of the substring</span>
    
    <span class="hljs-comment"># Iterate through the string with the right boundary of the window</span>
    <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> range(len(s)):
        <span class="hljs-comment"># If the character is already in the window, move the left boundary</span>
        <span class="hljs-keyword">if</span> s[right] <span class="hljs-keyword">in</span> char_map <span class="hljs-keyword">and</span> char_map[s[right]] &gt;= left:
            left = char_map[s[right]] + <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Update the last seen index of the character</span>
        char_map[s[right]] = right
        
        <span class="hljs-comment"># Update the maximum length of the substring</span>
        max_length = max(max_length, right - left + <span class="hljs-number">1</span>)
    
    <span class="hljs-keyword">return</span> max_length

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the string once with the sliding window</span>
<span class="hljs-comment"># Space Complexity: O(min(n, m)) - where n is the length of the string, and m is the character set (26 for lowercase letters)</span>

<span class="hljs-comment"># Test the function with the example</span>
print(length_of_longest_substring(<span class="hljs-string">"abcabcbb"</span>))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this sliding window solution provides an optimal O(n) time complexity result.</li>
</ul>
<hr>
<h3 id="problem-17-longest-repeating-character-replacement">Problem 17: Longest Repeating Character Replacement</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string <code>s</code> and an integer <code>k</code>, you can replace any character in the string with another character <code>k</code> times. The goal is to find the length of the longest substring containing the same letter after performing the replacements.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>s = &quot;AABABBA&quot;, k = 1</code><br>
Output: <code>4</code> (After replacing one 'B', the substring <code>&quot;AABA&quot;</code> becomes the longest).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Sliding Window</strong> pattern. The idea is to expand the window to include more characters, but shrink it when the condition (allowing at most <code>k</code> replacements) is violated.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">character_replacement</span><span class="hljs-params">(s, k)</span>:</span>
    <span class="hljs-comment"># Dictionary to count the frequency of characters in the current window</span>
    count = {}
    left = <span class="hljs-number">0</span>  <span class="hljs-comment"># Left boundary of the sliding window</span>
    max_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># To track the count of the most frequent character in the window</span>
    max_length = <span class="hljs-number">0</span>  <span class="hljs-comment"># Variable to store the maximum length of the valid substring</span>
    
    <span class="hljs-comment"># Iterate through the string with the right boundary of the window</span>
    <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> range(len(s)):
        count[s[right]] = count.get(s[right], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the count of the current character</span>
        
        <span class="hljs-comment"># Update the max_count with the most frequent character's count</span>
        max_count = max(max_count, count[s[right]])
        
        <span class="hljs-comment"># If the window size minus the most frequent character's count is greater than k, shrink the window</span>
        <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> - max_count &gt; k:
            count[s[left]] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># Decrement the count of the left character</span>
            left += <span class="hljs-number">1</span>  <span class="hljs-comment"># Shrink the window by moving the left pointer to the right</span>
        
        <span class="hljs-comment"># Calculate the maximum length of the valid substring</span>
        max_length = max(max_length, right - left + <span class="hljs-number">1</span>)
    
    <span class="hljs-keyword">return</span> max_length

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the string once with the sliding window</span>
<span class="hljs-comment"># Space Complexity: O(1) - since the character count dictionary has at most 26 entries (for uppercase letters)</span>

<span class="hljs-comment"># Test the function with the example</span>
print(character_replacement(<span class="hljs-string">"AABABBA"</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as the sliding window approach provides the optimal O(n) solution.</li>
</ul>
<hr>
<h3 id="problem-18-permutation-in-string">Problem 18: Permutation in String</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two strings <code>s1</code> and <code>s2</code>, return <code>True</code> if <code>s2</code> contains a permutation of <code>s1</code>. In other words, check if one of <code>s1</code>'s permutations is a substring of <code>s2</code>.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>s1 = &quot;ab&quot;</code>, <code>s2 = &quot;eidbaooo&quot;</code><br>
Output: <code>True</code> (because <code>&quot;ba&quot;</code> is a permutation of <code>&quot;ab&quot;</code> and is a substring of <code>s2</code>).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Sliding Window</strong> pattern combined with <strong>Hashing</strong>. We use a sliding window of size equal to <code>s1</code> and check whether the character counts in the window match those in <code>s1</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_inclusion</span><span class="hljs-params">(s1, s2)</span>:</span>
    <span class="hljs-comment"># Edge case: if s1 is longer than s2, s2 cannot contain its permutation</span>
    <span class="hljs-keyword">if</span> len(s1) &gt; len(s2):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># Arrays to store the character counts of s1 and the current window in s2</span>
    s1_count = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>
    s2_count = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>
    
    <span class="hljs-comment"># Count the frequency of characters in s1</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s1:
        s1_count[ord(char) - ord(<span class="hljs-string">'a'</span>)] += <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Use a sliding window to compare character counts in s2</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s2)):
        <span class="hljs-comment"># Add the current character in the window</span>
        s2_count[ord(s2[i]) - ord(<span class="hljs-string">'a'</span>)] += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Remove the character that's sliding out of the window</span>
        <span class="hljs-keyword">if</span> i &gt;= len(s1):
            s2_count[ord(s2[i - len(s1)]) - ord(<span class="hljs-string">'a'</span>)] -= <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># If the character counts in the window match those in s1, return True</span>
        <span class="hljs-keyword">if</span> s1_count == s2_count:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the length of s2 (sliding window of size len(s1))</span>
<span class="hljs-comment"># Space Complexity: O(1) - fixed space for the character count arrays (26 for lowercase letters)</span>

<span class="hljs-comment"># Test the function with the example</span>
print(check_inclusion(<span class="hljs-string">"ab"</span>, <span class="hljs-string">"eidbaooo"</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as the sliding window approach with character counts is optimal.</li>
</ul>
<hr>
<h3 id="problem-19-minimum-window-substring">Problem 19: Minimum Window Substring</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two strings <code>s</code> and <code>t</code>, return the minimum window in <code>s</code> which contains all the characters in <code>t</code>. If there is no such window, return an empty string.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code><br>
Output: <code>&quot;BANC&quot;</code> (because this is the smallest window that contains all characters from <code>t</code>).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Sliding Window</strong> pattern. The goal is to expand the window until all characters in <code>t</code> are included, and then contract the window to find the smallest possible substring.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_window</span><span class="hljs-params">(s, t)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> s:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
    
    <span class="hljs-comment"># Dictionary to count the frequency of characters in t</span>
    dict_t = {}
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> t:
        dict_t[char] = dict_t.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
    
    required = len(dict_t)  <span class="hljs-comment"># Number of unique characters in t</span>
    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># Pointers for the sliding window</span>
    formed = <span class="hljs-number">0</span>  <span class="hljs-comment"># To track how many unique characters in t are satisfied in the window</span>
    
    <span class="hljs-comment"># Dictionary to count the characters in the current window</span>
    window_counts = {}
    <span class="hljs-comment"># (window length, left, right) to store the smallest window found</span>
    ans = float(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># Start expanding the window</span>
    <span class="hljs-keyword">while</span> right &lt; len(s):
        char = s[right]
        window_counts[char] = window_counts.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># If the current character's frequency in the window matches t's, update formed</span>
        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> dict_t <span class="hljs-keyword">and</span> window_counts[char] == dict_t[char]:
            formed += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Try to contract the window until it's no longer valid</span>
        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> formed == required:
            char = s[left]
            
            <span class="hljs-comment"># Update the result if this window is smaller than the previous smallest</span>
            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &lt; ans[<span class="hljs-number">0</span>]:
                ans = (right - left + <span class="hljs-number">1</span>, left, right)
            
            <span class="hljs-comment"># Remove the leftmost character and shrink the window</span>
            window_counts[char] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> dict_t <span class="hljs-keyword">and</span> window_counts[char] &lt; dict_t[char]:
                formed -= <span class="hljs-number">1</span>
            
            left += <span class="hljs-number">1</span>  <span class="hljs-comment"># Move the left pointer to shrink the window</span>
        
        <span class="hljs-comment"># Expand the window by moving the right pointer</span>
        right += <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># If no valid window was found, return an empty string</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> <span class="hljs-keyword">if</span> ans[<span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> s[ans[<span class="hljs-number">1</span>]:ans[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>]

<span class="hljs-comment"># Time Complexity: O(n + m) - where n is the length of s and m is the length of t</span>
<span class="hljs-comment"># Space Complexity: O(n + m) - for the dictionaries used to store counts of s and t</span>

<span class="hljs-comment"># Test the function with the example</span>
print(min_window(<span class="hljs-string">"ADOBECODEBANC"</span>, <span class="hljs-string">"ABC"</span>))  <span class="hljs-comment"># Output: "BANC"</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as the sliding window with dictionary counting is efficient for this problem.</li>
</ul>
<hr>
<h3 id="problem-20-sliding-window-maximum">Problem 20: Sliding Window Maximum</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array <code>nums</code> and an integer <code>k</code>, you need to find the maximum value in every sliding window of size <code>k</code> in the array.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1,3,-1,-3,5,3,6,7]</code>, <code>k = 3</code><br>
Output: <code>[3,3,5,5,6,7]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Deque</strong> (double-ended queue). The idea is to maintain a deque where the front holds the index of the maximum element in the current window, and we adjust it as the window slides.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_sliding_window</span><span class="hljs-params">(nums, k)</span>:</span>
    <span class="hljs-comment"># Deque to store indices of potential maximum elements</span>
    dq = deque()
    result = []
    
    <span class="hljs-comment"># Iterate through each element in the array</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
        <span class="hljs-comment"># Remove elements that are outside the current window</span>
        <span class="hljs-keyword">if</span> dq <span class="hljs-keyword">and</span> dq[<span class="hljs-number">0</span>] &lt; i - k + <span class="hljs-number">1</span>:
            dq.popleft()
        
        <span class="hljs-comment"># Remove elements that are smaller than</span>

 the current element (since they can<span class="hljs-string">'t be the max)
        while dq and nums[dq[-1]] &lt; nums[i]:
            dq.pop()
        
        # Add the current element'</span>s index to the deque
        dq.append(i)
        
        <span class="hljs-comment"># If the window is fully within the array, add the maximum to the result</span>
        <span class="hljs-keyword">if</span> i &gt;= k - <span class="hljs-number">1</span>:
            result.append(nums[dq[<span class="hljs-number">0</span>]])  <span class="hljs-comment"># The front of the deque is the maximum element in the window</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n) - each element is added and removed from the deque at most once</span>
<span class="hljs-comment"># Space Complexity: O(k) - for storing the indices in the deque</span>

<span class="hljs-comment"># Test the function with the example</span>
print(max_sliding_window([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-number">3</span>))  <span class="hljs-comment"># Output: [3, 3, 5, 5, 6, 7]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as using a deque provides the optimal O(n) solution.</li>
</ul>
<hr>
<h3 id="problem-21-valid-parentheses">Problem 21: Valid Parentheses</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{', '}', '[', ']'</code>, determine if the input string is valid. A valid string must have matching open and close parentheses, and they must be in the correct order.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>&quot;()[]{}&quot;</code><br>
Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem is solved using the <strong>Stack</strong> pattern. We push open parentheses onto a stack, and for every closing parenthesis, we check if the top of the stack contains the corresponding open parenthesis.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-comment"># Stack to store open brackets</span>
    stack = []
    
    <span class="hljs-comment"># Dictionary to store matching pairs of parentheses</span>
    mapping = {<span class="hljs-string">')'</span>: <span class="hljs-string">'('</span>, <span class="hljs-string">'}'</span>: <span class="hljs-string">'{'</span>, <span class="hljs-string">']'</span>: <span class="hljs-string">'['</span>}
    
    <span class="hljs-comment"># Iterate over the characters in the input string</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:
        <span class="hljs-comment"># If the character is a closing parenthesis</span>
        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> mapping:
            <span class="hljs-comment"># Pop the top of the stack (if stack is empty, use a dummy value '#')</span>
            top_element = stack.pop() <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">else</span> <span class="hljs-string">'#'</span>
            
            <span class="hljs-comment"># Check if the popped element is the corresponding open parenthesis</span>
            <span class="hljs-keyword">if</span> mapping[char] != top_element:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># If it's an opening parenthesis, push it onto the stack</span>
            stack.append(char)
    
    <span class="hljs-comment"># The string is valid if the stack is empty at the end (all parentheses matched)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack

<span class="hljs-comment"># Time Complexity: O(n) - where n is the length of the string</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the stack that stores open parentheses</span>

<span class="hljs-comment"># Test the function with the example</span>
print(is_valid(<span class="hljs-string">"()[]{}"</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required as the stack-based solution efficiently solves the problem in O(n) time.</li>
</ul>
<hr>
<h3 id="problem-22-min-stack">Problem 22: Min Stack</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement <code>MinStack</code> with these methods:
<ul>
<li><code>push(val)</code>: Pushes <code>val</code> onto the stack.</li>
<li><code>pop()</code>: Removes the element on the top of the stack.</li>
<li><code>top()</code>: Gets the top element.</li>
<li><code>get_min()</code>: Retrieves the minimum element in the stack.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.get_min(); // Returns -3
minStack.pop();
minStack.top();      // Returns 0
minStack.get_min();  // Returns -2
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>We can solve this by maintaining two stacks: one for all elements and another for tracking the minimum elements.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Initialize two stacks: one for all elements and one for the minimum elements</span>
        self.stack = []
        self.min_stack = []

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, val: int)</span>:</span>
        <span class="hljs-comment"># Push the value onto the main stack</span>
        self.stack.append(val)
        <span class="hljs-comment"># If the min_stack is empty or the current value is smaller or equal to the top of the min_stack, push it</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.min_stack <span class="hljs-keyword">or</span> val &lt;= self.min_stack[<span class="hljs-number">-1</span>]:
            self.min_stack.append(val)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Pop the value from the main stack</span>
        <span class="hljs-keyword">if</span> self.stack:
            val = self.stack.pop()
            <span class="hljs-comment"># If the popped value is the same as the top of the min_stack, pop it from the min_stack as well</span>
            <span class="hljs-keyword">if</span> val == self.min_stack[<span class="hljs-number">-1</span>]:
                self.min_stack.pop()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Return the top element of the stack</span>
        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>] <span class="hljs-keyword">if</span> self.stack <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_min</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Return the top element of the min_stack (the minimum element in the stack)</span>
        <span class="hljs-keyword">return</span> self.min_stack[<span class="hljs-number">-1</span>] <span class="hljs-keyword">if</span> self.min_stack <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># Time Complexity for all operations: O(1) - constant time for push, pop, top, and get_min</span>
<span class="hljs-comment"># Space Complexity: O(n) - where n is the number of elements in the stack</span>

<span class="hljs-comment"># Test the MinStack class</span>
min_stack = MinStack()
min_stack.push(<span class="hljs-number">-2</span>)
min_stack.push(<span class="hljs-number">0</span>)
min_stack.push(<span class="hljs-number">-3</span>)
print(min_stack.get_min())  <span class="hljs-comment"># Output: -3</span>
min_stack.pop()
print(min_stack.top())      <span class="hljs-comment"># Output: 0</span>
print(min_stack.get_min())  <span class="hljs-comment"># Output: -2</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as this solution already provides constant time complexity for all operations.</li>
</ul>
<hr>
<h3 id="problem-23-evaluate-reverse-polish-notation">Problem 23: Evaluate Reverse Polish Notation</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Evaluate the value of an arithmetic expression in Reverse Polish Notation (RPN). Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer, and division should truncate towards zero.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code><br>
Output: <code>9</code><br>
Explanation: <code>((2 + 1) * 3) = 9</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Stack</strong> pattern. We push operands onto the stack, and when encountering an operator, we pop two elements, perform the operation, and push the result back onto the stack.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eval_rpn</span><span class="hljs-params">(tokens)</span>:</span>
    <span class="hljs-comment"># Stack to store the operands</span>
    stack = []
    
    <span class="hljs-comment"># Iterate through each token</span>
    <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:
        <span class="hljs-comment"># If the token is an operator, pop two elements, perform the operation, and push the result</span>
        <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> <span class="hljs-string">"+-*/"</span>:
            b = stack.pop()  <span class="hljs-comment"># Second operand</span>
            a = stack.pop()  <span class="hljs-comment"># First operand</span>
            <span class="hljs-keyword">if</span> token == <span class="hljs-string">'+'</span>:
                stack.append(a + b)
            <span class="hljs-keyword">elif</span> token == <span class="hljs-string">'-'</span>:
                stack.append(a - b)
            <span class="hljs-keyword">elif</span> token == <span class="hljs-string">'*'</span>:
                stack.append(a * b)
            <span class="hljs-keyword">elif</span> token == <span class="hljs-string">'/'</span>:
                <span class="hljs-comment"># Integer division (truncating towards zero)</span>
                stack.append(int(a / b))
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># If the token is a number, push it onto the stack</span>
            stack.append(int(token))
    
    <span class="hljs-comment"># The final result will be the only element left in the stack</span>
    <span class="hljs-keyword">return</span> stack.pop()

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of tokens in the input</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the stack used to store operands</span>

<span class="hljs-comment"># Test the function with the example</span>
print(eval_rpn([<span class="hljs-string">"2"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"+"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"*"</span>]))  <span class="hljs-comment"># Output: 9</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required because the stack-based solution is efficient for this problem, and there are no faster approaches.</li>
</ul>
<hr>
<h3 id="problem-24-generate-parentheses">Problem 24: Generate Parentheses</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given <code>n</code> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>n = 3</code><br>
Output:</p>
<pre class="hljs"><code><div>[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong>. We recursively generate strings by adding open and close parentheses, ensuring that we always add valid parentheses combinations.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_parenthesis</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(s, left, right)</span>:</span>
        <span class="hljs-comment"># If the current string is of length 2*n, it's a valid combination</span>
        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">2</span> * n:
            result.append(s)
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># If we can still add an open parenthesis, do so</span>
        <span class="hljs-keyword">if</span> left &lt; n:
            backtrack(s + <span class="hljs-string">'('</span>, left + <span class="hljs-number">1</span>, right)
        
        <span class="hljs-comment"># If we can still add a close parenthesis, do so</span>
        <span class="hljs-keyword">if</span> right &lt; left:
            backtrack(s + <span class="hljs-string">')'</span>, left, right + <span class="hljs-number">1</span>)
    
    result = []
    backtrack(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(4^n / sqrt(n)) - the number of valid parentheses combinations is a Catalan number</span>
<span class="hljs-comment"># Space Complexity: O(4^n / sqrt(n)) - for storing the valid combinations</span>

<span class="hljs-comment"># Test the function with the example</span>
print(generate_parenthesis(<span class="hljs-number">3</span>))
<span class="hljs-comment"># Output: ['((()))', '(()())', '(())()', '()(())', '()()()']</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as this backtracking solution is optimal for generating all valid combinations.</li>
</ul>
<hr>
<h3 id="problem-25-daily-temperatures">Problem 25: Daily Temperatures</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of daily temperatures <code>T</code>, return an array <code>answer</code> such that <code>answer[i]</code> is the number of days you would have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, put <code>0</code> instead.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code><br>
Output: <code>[1, 1, 4, 2, 1, 1, 0, 0]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The problem can be efficiently solved using a <strong>Monotonic Stack</strong>. The idea is to store indices of days in a stack such that the temperatures are in decreasing order. Whenever a warmer day is found, we pop from the stack and calculate the difference in indices.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">daily_temperatures</span><span class="hljs-params">(T)</span>:</span>
    <span class="hljs-comment"># Stack to store the indices of days</span>
    stack = []
    <span class="hljs-comment"># Initialize the answer array with all zeros</span>
    answer = [<span class="hljs-number">0</span>] * len(T)
    
    <span class="hljs-comment"># Iterate through the temperature list</span>
    <span class="hljs-keyword">for</span> i, temp <span class="hljs-keyword">in</span> enumerate(T):
        <span class="hljs-comment"># Check if the current temperature is warmer than the temperatures at the indices in the stack</span>
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> T[stack[<span class="hljs-number">-1</span>]] &lt; temp:
            prev_day = stack.pop()
            answer[prev_day] = i - prev_day  <span class="hljs-comment"># Calculate the number of days to wait for a warmer temperature</span>
        
        <span class="hljs-comment"># Push the current index onto the stack</span>
        stack.append(i)
    
    <span class="hljs-keyword">return</span> answer

<span class="hljs-comment"># Time Complexity: O(n) - we process each element at most twice (push and pop from the stack)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the stack storing indices</span>

<span class="hljs-comment"># Test the function with the example</span>
print(daily_temperatures([<span class="hljs-number">73</span>, <span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">71</span>, <span class="hljs-number">69</span>, <span class="hljs-number">72</span>, <span class="hljs-number">76</span>, <span class="hljs-number">73</span>]))  <span class="hljs-comment"># Output: [1, 1, 4, 2, 1, 1, 0, 0]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as the monotonic stack solution is optimal.</li>
</ul>
<hr>
<h3 id="problem-26-car-fleet">Problem 26: Car Fleet</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: There are <code>n</code> cars going to the same destination along a one-lane road. The destination is <code>target</code> miles away. Each car <code>i</code> has a position <code>position[i]</code> and speed <code>speed[i]</code>. A car can never pass another car, but it can catch up to it, forming a fleet. The goal is to return the number of car fleets that will arrive at the destination.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>target = 12</code>, <code>position = [10, 8, 0, 5, 3]</code>, <code>speed = [2, 4, 1, 1, 3]</code><br>
Output: <code>3</code> (Cars form 3 different fleets).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>The problem can be solved using sorting and a <strong>Greedy</strong> approach. We sort the cars by their starting positions (from farthest to closest) and calculate how long it will take each car to reach the destination. Cars that catch up to others form a fleet.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car_fleet</span><span class="hljs-params">(target, position, speed)</span>:</span>
    <span class="hljs-comment"># Create pairs of (position, time to reach the target)</span>
    cars = [(p, (target - p) / s) <span class="hljs-keyword">for</span> p, s <span class="hljs-keyword">in</span> zip(position, speed)]
    
    <span class="hljs-comment"># Sort the cars by their starting positions in descending order</span>
    cars.sort(reverse=<span class="hljs-literal">True</span>)
    
    fleets = <span class="hljs-number">0</span>  <span class="hljs-comment"># Number of car fleets</span>
    current_fleet_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># Time taken by the leading car in the current fleet</span>
    
    <span class="hljs-comment"># Iterate through the sorted cars</span>
    <span class="hljs-keyword">for</span> pos, time <span class="hljs-keyword">in</span> cars:
        <span class="hljs-comment"># If the current car cannot catch up with the fleet in front, it forms a new fleet</span>
        <span class="hljs-keyword">if</span> time &gt; current_fleet_time:
            fleets += <span class="hljs-number">1</span>
            current_fleet_time = time  <span class="hljs-comment"># Update the fleet time with the current car's time</span>
    
    <span class="hljs-keyword">return</span> fleets

<span class="hljs-comment"># Time Complexity: O(n log n) - sorting the cars by position</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the position and time pairs</span>

<span class="hljs-comment"># Test the function with the example</span>
print(car_fleet(<span class="hljs-number">12</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as the sorting and greedy approach provides an optimal solution.</li>
</ul>
<hr>
<h3 id="problem-27-largest-rectangle-in-histogram">Problem 27: Largest Rectangle in Histogram</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of integers representing the heights of bars in a histogram, return the area of the largest rectangle that can be formed within the bounds of the histogram.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>heights = [2, 1, 5, 6, 2, 3]</code><br>
Output: <code>10</code> (The largest rectangle has height 5 and width 2, area = 5 * 2 = 10).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be efficiently solved using a <strong>Monotonic Stack</strong>. The stack helps to keep track of indices of bars in increasing order of height, and we calculate the area whenever we find a bar shorter than the top of the stack.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largest_rectangle_area</span><span class="hljs-params">(heights)</span>:</span>
    <span class="hljs-comment"># Initialize the stack and the maximum area variable</span>
    stack = []
    max_area = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Append a zero height to handle remaining bars in the stack at the end</span>
    heights.append(<span class="hljs-number">0</span>)
    
    <span class="hljs-comment"># Iterate through the heights</span>
    <span class="hljs-keyword">for</span> i, h <span class="hljs-keyword">in</span> enumerate(heights):
        <span class="hljs-comment"># While the current height is less than the height of the bar at the top of the stack</span>
        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> heights[stack[<span class="hljs-number">-1</span>]] &gt; h:
            <span class="hljs-comment"># Pop the top of the stack and calculate the area with the popped height</span>
            height = heights[stack.pop()]
            width = i <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">else</span> i - stack[<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>  <span class="hljs-comment"># Calculate the width of the rectangle</span>
            max_area = max(max_area, height * width)  <span class="hljs-comment"># Update the maximum area</span>
        
        <span class="hljs-comment"># Push the current index onto the stack</span>
        stack.append(i)
    
    <span class="hljs-comment"># Return the maximum area found</span>
    <span class="hljs-keyword">return</span> max_area

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the heights array and process each element at most twice</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the stack used to store indices</span>

<span class="hljs-comment"># Test the function with the example</span>
print(largest_rectangle_area([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))  <span class="hljs-comment"># Output: 10</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as the monotonic stack provides an optimal solution in O(n) time.</li>
</ul>
<hr>
<h3 id="binary-search-section">Binary Search Section</h3>
<hr>
<h3 id="problem-1-binary-search">Problem 1: Binary Search</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a sorted array of integers, write a function to search for a target value. If the target exists, return its index. If not, return <code>-1</code>.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [-1, 0, 3, 5, 9, 12]</code>, <code>target = 9</code><br>
Output: <code>4</code> (target is at index 4).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Binary Search</strong> since the array is sorted.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(nums, target)</span>:</span>
    left, right = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Perform binary search</span>
    <span class="hljs-keyword">while</span> left &lt;= right:
        mid = left + (right - left) // <span class="hljs-number">2</span>  <span class="hljs-comment"># Calculate the middle index</span>
        
        <span class="hljs-comment"># If target is found, return the index</span>
        <span class="hljs-keyword">if</span> nums[mid] == target:
            <span class="hljs-keyword">return</span> mid
        
        <span class="hljs-comment"># If target is smaller than the middle element, search in the left half</span>
        <span class="hljs-keyword">elif</span> nums[mid] &gt; target:
            right = mid - <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># If target is larger, search in the right half</span>
        <span class="hljs-keyword">else</span>:
            left = mid + <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># Target not found</span>

<span class="hljs-comment"># Time Complexity: O(log n) - binary search divides the array in half each time</span>
<span class="hljs-comment"># Space Complexity: O(1) - only a few variables are used for searching</span>

<span class="hljs-comment"># Test the function with the example</span>
print(binary_search([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>], <span class="hljs-number">9</span>))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as binary search is the most optimal solution for this problem.</li>
</ul>
<hr>
<h3 id="problem-2-search-a-2d-matrix">Problem 2: Search a 2D Matrix</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Write an efficient algorithm that searches for a target value in an <code>m x n</code> matrix. The matrix has the following properties:
<ol>
<li>Each row is sorted in ascending order.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ol>
</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]</code>, <code>target = 3</code><br>
Output: <code>True</code> (target is found).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved by treating the 2D matrix as a flattened sorted array and using <strong>Binary Search</strong>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_matrix</span><span class="hljs-params">(matrix, target)</span>:</span>
    <span class="hljs-comment"># If the matrix is empty, return False</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    m, n = len(matrix), len(matrix[<span class="hljs-number">0</span>])  <span class="hljs-comment"># Dimensions of the matrix</span>
    left, right = <span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>  <span class="hljs-comment"># Treat the matrix as a flat array</span>
    
    <span class="hljs-comment"># Perform binary search</span>
    <span class="hljs-keyword">while</span> left &lt;= right:
        mid = left + (right - left) // <span class="hljs-number">2</span>
        mid_value = matrix[mid // n][mid % n]  <span class="hljs-comment"># Convert 1D index to 2D index</span>
        
        <span class="hljs-comment"># If target is found, return True</span>
        <span class="hljs-keyword">if</span> mid_value == target:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        
        <span class="hljs-comment"># If target is smaller, search the left half</span>
        <span class="hljs-keyword">elif</span> mid_value &gt; target:
            right = mid - <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># If target is larger, search the right half</span>
        <span class="hljs-keyword">else</span>:
            left = mid + <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Target not found</span>

<span class="hljs-comment"># Time Complexity: O(log(m * n)) - binary search in a matrix of m rows and n columns</span>
<span class="hljs-comment"># Space Complexity: O(1) - only a few variables are used for searching</span>

<span class="hljs-comment"># Test the function with the example</span>
print(search_matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">23</span>, <span class="hljs-number">30</span>, <span class="hljs-number">34</span>, <span class="hljs-number">60</span>]], <span class="hljs-number">3</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as binary search is optimal.</li>
</ul>
<hr>
<h3 id="problem-3-koko-eating-bananas">Problem 3: Koko Eating Bananas</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Koko loves to eat bananas. There are <code>n</code> piles of bananas, the ith pile has <code>piles[i]</code> bananas. Koko wants to finish eating all the bananas in <code>h</code> hours. She can decide her banana eating speed <code>k</code>, which is the number of bananas per hour. Find the minimum integer <code>k</code> such that she can finish all the bananas within <code>h</code> hours.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>piles = [3, 6, 7, 11]</code>, <code>h = 8</code><br>
Output: <code>4</code> (minimum speed is 4 bananas/hour).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Binary Search</strong> on the potential values of <code>k</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> math

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_eating_speed</span><span class="hljs-params">(piles, h)</span>:</span>
    <span class="hljs-comment"># Define the range of possible speeds (from 1 to max of piles)</span>
    left, right = <span class="hljs-number">1</span>, max(piles)
    
    <span class="hljs-comment"># Perform binary search to find the minimum speed</span>
    <span class="hljs-keyword">while</span> left &lt; right:
        mid = (left + right) // <span class="hljs-number">2</span>
        hours_needed = sum(math.ceil(pile / mid) <span class="hljs-keyword">for</span> pile <span class="hljs-keyword">in</span> piles)
        
        <span class="hljs-comment"># If she can finish in the given time, search for a smaller speed</span>
        <span class="hljs-keyword">if</span> hours_needed &lt;= h:
            right = mid
        <span class="hljs-keyword">else</span>:
            left = mid + <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> left

<span class="hljs-comment"># Time Complexity: O(n log max(piles)) - binary search on speed, and for each speed, sum over piles</span>
<span class="hljs-comment"># Space Complexity: O(1) - only a few variables are used for searching</span>

<span class="hljs-comment"># Test the function with the example</span>
print(min_eating_speed([<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], <span class="hljs-number">8</span>))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as binary search on the speed is optimal.</li>
</ul>
<hr>
<h3 id="problem-4-find-minimum-in-rotated-sorted-array">Problem 4: Find Minimum in Rotated Sorted Array</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Suppose an array of sorted integers is rotated at some pivot. You need to find the minimum element in the array without any duplicates.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [3, 4, 5, 1, 2]</code><br>
Output: <code>1</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Binary Search</strong> in a rotated array.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_min</span><span class="hljs-params">(nums)</span>:</span>
    left, right = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Perform binary search to find the minimum element</span>
    <span class="hljs-keyword">while</span> left &lt; right:
        mid = left + (right - left) // <span class="hljs-number">2</span>
        
        <span class="hljs-comment"># If mid is greater than right, the minimum is in the right half</span>
        <span class="hljs-keyword">if</span> nums[mid] &gt; nums[right]:
            left = mid + <span class="hljs-number">1</span>
        <span class="hljs-comment"># Otherwise, it's in the left half (including mid)</span>
        <span class="hljs-keyword">else</span>:
            right = mid
    
    <span class="hljs-keyword">return</span> nums[left]

<span class="hljs-comment"># Time Complexity: O(log n) - binary search in the rotated sorted array</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space is used</span>

<span class="hljs-comment"># Test the function with the example</span>
print(find_min([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))  <span class="hljs-comment"># Output: 1</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as binary search is optimal for finding the minimum in a rotated sorted array.</li>
</ul>
<hr>
<h3 id="problem-5-search-in-rotated-sorted-array">Problem 5: Search in Rotated Sorted Array</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given a rotated sorted array, and you need to search for a target value. If found, return its index, otherwise return <code>-1</code>.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [4, 5, 6, 7, 0, 1, 2]</code>, <code>target = 0</code><br>
Output: <code>4</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Binary Search</strong> in a rotated sorted array.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(nums, target)</span>:</span>
    left, right = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Perform binary search</span>
    <span class="hljs-keyword">while</span> left &lt;= right:
        mid = left + (right - left) // <span class="hljs-number">2</span>
        
        <span class="hljs-comment"># If target is found, return the index</span>
        <span class="hljs-keyword">if</span> nums[mid] == target:
            <span class="hljs-keyword">return</span> mid
        
        <span class="hljs-comment"># If the left half is sorted</span>
        <span class="hljs-keyword">if</span> nums[left] &lt;= nums[mid]:
            <span class="hljs-comment"># Check if the target lies within the left half</span>
            <span class="hljs-keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:
                right = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                left = mid + <span class="hljs-number">1</span>
        <span class="hljs-comment"># If the right half is sorted</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Check if the target lies within the right half</span>
            <span class="hljs-keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:
                left = mid + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                right = mid - <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>

<span class="hljs-comment"># Time Complexity: O(log n) - binary search in the rotated sorted array</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space is used</span>

<span class="hljs-comment"># Test the function with the example</span>
print(search([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">0</span>))  <span class="hljs-comment"># Output: 4</span>


</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as binary search is optimal.</li>
</ul>
<hr>
<h3 id="problem-6-time-based-key-value-store">Problem 6: Time Based Key-Value Store</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a time-based key-value store that supports two operations:
<ul>
<li><code>set(key, value, timestamp)</code>: Stores the key and value, along with the given timestamp.</li>
<li><code>get(key, timestamp)</code>: Returns the value associated with the key at the largest timestamp <code>≤ timestamp</code>. If there is no such timestamp, return an empty string <code>&quot;&quot;</code>.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>Input:
timeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1);
timeMap.get(&quot;foo&quot;, 1); // returns &quot;bar&quot;
timeMap.get(&quot;foo&quot;, 3); // returns &quot;bar&quot;
timeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4);
timeMap.get(&quot;foo&quot;, 4); // returns &quot;bar2&quot;
timeMap.get(&quot;foo&quot;, 5); // returns &quot;bar2&quot;
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>We can solve this problem using <strong>Binary Search</strong> over the timestamps for each key. A dictionary will store each key and a list of <code>(timestamp, value)</code> pairs, and binary search will be used to find the appropriate value for a given timestamp.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict
<span class="hljs-keyword">import</span> bisect

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeMap</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Dictionary to store key as the key and a list of (timestamp, value) pairs as the value</span>
        self.store = defaultdict(list)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span><span class="hljs-params">(self, key: str, value: str, timestamp: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Append the (timestamp, value) pair to the list for the key</span>
        self.store[key].append((timestamp, value))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self, key: str, timestamp: int)</span> -&gt; str:</span>
        <span class="hljs-comment"># Use binary search to find the largest timestamp ≤ the given timestamp</span>
        values = self.store.get(key, [])
        i = bisect.bisect_right(values, (timestamp, chr(<span class="hljs-number">127</span>)))  <span class="hljs-comment"># `chr(127)` ensures it's the largest possible character</span>
        <span class="hljs-keyword">return</span> values[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>

<span class="hljs-comment"># Time Complexity: </span>
<span class="hljs-comment"># - set: O(1) to append a value.</span>
<span class="hljs-comment"># - get: O(log n) to binary search for the timestamp in the list.</span>
<span class="hljs-comment"># Space Complexity: O(n) - where n is the number of set operations.</span>

<span class="hljs-comment"># Test the class with the example</span>
timeMap = TimeMap()
timeMap.set(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-number">1</span>)
print(timeMap.get(<span class="hljs-string">"foo"</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: "bar"</span>
print(timeMap.get(<span class="hljs-string">"foo"</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># Output: "bar"</span>
timeMap.set(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar2"</span>, <span class="hljs-number">4</span>)
print(timeMap.get(<span class="hljs-string">"foo"</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment"># Output: "bar2"</span>
print(timeMap.get(<span class="hljs-string">"foo"</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># Output: "bar2"</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as binary search efficiently solves this problem in O(log n) time for each query.</li>
</ul>
<hr>
<h3 id="problem-7-median-of-two-sorted-arrays">Problem 7: Median of Two Sorted Arrays</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums1 = [1, 3]</code>, <code>nums2 = [2]</code><br>
Output: <code>2.0</code> (merged array is [1, 2, 3] and the median is 2).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Binary Search</strong> on the smaller array. The goal is to partition both arrays such that the left half of the merged array contains all smaller elements, and the right half contains all larger elements.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_median_sorted_arrays</span><span class="hljs-params">(nums1, nums2)</span>:</span>
    <span class="hljs-comment"># Ensure nums1 is the smaller array for binary search</span>
    <span class="hljs-keyword">if</span> len(nums1) &gt; len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    half_len = (m + n + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>
    
    <span class="hljs-comment"># Perform binary search on the smaller array</span>
    left, right = <span class="hljs-number">0</span>, m
    <span class="hljs-keyword">while</span> left &lt;= right:
        i = (left + right) // <span class="hljs-number">2</span>
        j = half_len - i
        
        <span class="hljs-comment"># Check if i is too small (nums1[i] &lt; nums2[j-1])</span>
        <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">and</span> nums2[j<span class="hljs-number">-1</span>] &gt; nums1[i]:
            left = i + <span class="hljs-number">1</span>
        <span class="hljs-comment"># Check if i is too large (nums1[i-1] &gt; nums2[j])</span>
        <span class="hljs-keyword">elif</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums1[i<span class="hljs-number">-1</span>] &gt; nums2[j]:
            right = i - <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Find the maximum of the left partition</span>
            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>: max_of_left = nums2[j<span class="hljs-number">-1</span>]
            <span class="hljs-keyword">elif</span> j == <span class="hljs-number">0</span>: max_of_left = nums1[i<span class="hljs-number">-1</span>]
            <span class="hljs-keyword">else</span>: max_of_left = max(nums1[i<span class="hljs-number">-1</span>], nums2[j<span class="hljs-number">-1</span>])
            
            <span class="hljs-comment"># If the total number of elements is odd, return max_of_left</span>
            <span class="hljs-keyword">if</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> max_of_left
            
            <span class="hljs-comment"># Find the minimum of the right partition</span>
            <span class="hljs-keyword">if</span> i == m: min_of_right = nums2[j]
            <span class="hljs-keyword">elif</span> j == n: min_of_right = nums1[i]
            <span class="hljs-keyword">else</span>: min_of_right = min(nums1[i], nums2[j])
            
            <span class="hljs-comment"># Return the average of the two middle elements</span>
            <span class="hljs-keyword">return</span> (max_of_left + min_of_right) / <span class="hljs-number">2</span>

<span class="hljs-comment"># Time Complexity: O(log(min(m, n))) - binary search on the smaller array</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used</span>

<span class="hljs-comment"># Test the function with the example</span>
print(find_median_sorted_arrays([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>]))  <span class="hljs-comment"># Output: 2.0</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as binary search on the smaller array is optimal.</li>
</ul>
<hr>
<h3 id="linked-list-section">Linked List Section</h3>
<hr>
<h3 id="problem-8-reverse-linked-list">Problem 8: Reverse Linked List</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the head of a singly linked list, reverse the list and return the reversed list.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>head = [1, 2, 3, 4, 5]</code><br>
Output: <code>[5, 4, 3, 2, 1]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Iterative</strong> or <strong>Recursive</strong> approaches. We'll first solve it iteratively by reversing the pointers between nodes.</li>
</ul>
<h4 id="solution-iterative">Solution (Iterative):</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, val=<span class="hljs-number">0</span>, next=None)</span>:</span>
        self.val = val
        self.next = next

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_list</span><span class="hljs-params">(head)</span>:</span>
    prev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Initialize prev to None to mark the end of the reversed list</span>
    current = head
    
    <span class="hljs-comment"># Traverse the list and reverse the pointers</span>
    <span class="hljs-keyword">while</span> current:
        next_node = current.next  <span class="hljs-comment"># Save the next node</span>
        current.next = prev  <span class="hljs-comment"># Reverse the pointer</span>
        prev = current  <span class="hljs-comment"># Move prev to current</span>
        current = next_node  <span class="hljs-comment"># Move to the next node</span>
    
    <span class="hljs-keyword">return</span> prev  <span class="hljs-comment"># prev will be the new head of the reversed list</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the list</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for pointer manipulation</span>

<span class="hljs-comment"># Test the function (you can write test cases with a linked list structure)</span>
</div></code></pre>
<h4 id="alternative-approach-recursive">Alternative Approach (Recursive):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_list_recursive</span><span class="hljs-params">(head)</span>:</span>
    <span class="hljs-comment"># Base case: if head is empty or only one node, return it</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.next:
        <span class="hljs-keyword">return</span> head
    
    <span class="hljs-comment"># Reverse the rest of the list recursively</span>
    new_head = reverse_list_recursive(head.next)
    
    <span class="hljs-comment"># Adjust the pointers to reverse the current pair of nodes</span>
    head.next.next = head
    head.next = <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">return</span> new_head

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the list</span>
<span class="hljs-comment"># Space Complexity: O(n) - due to the recursion stack</span>
</div></code></pre>
<hr>
<h3 id="problem-9-merge-two-sorted-lists">Problem 9: Merge Two Sorted Lists</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>l1 = [1, 2, 4]</code>, <code>l2 = [1, 3, 4]</code><br>
Output: <code>[1, 1, 2, 3, 4, 4]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Two Pointers</strong>. We can traverse both lists and merge them into one by comparing node values.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_two_lists</span><span class="hljs-params">(l1, l2)</span>:</span>
    <span class="hljs-comment"># Create a dummy node to serve as the head of the merged list</span>
    dummy = ListNode()
    current = dummy
    
    <span class="hljs-comment"># Traverse both lists and merge them</span>
    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:
        <span class="hljs-keyword">if</span> l1.val &lt; l2.val:
            current.next = l1
            l1 = l1.next
        <span class="hljs-keyword">else</span>:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    <span class="hljs-comment"># Attach the remaining elements, if any</span>
    <span class="hljs-keyword">if</span>

 l1:
        current.next = l1
    <span class="hljs-keyword">else</span>:
        current.next = l2
    
    <span class="hljs-keyword">return</span> dummy.next

<span class="hljs-comment"># Time Complexity: O(n + m) - where n and m are the lengths of the two lists</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space (apart from the input list space)</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as the two-pointer solution is optimal.</li>
</ul>
<hr>
<h3 id="problem-10-reorder-list">Problem 10: Reorder List</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a singly linked list <code>L: L0 → L1 → … → Ln-1 → Ln</code>, reorder it to: <code>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</code></li>
</ul>
<p>You must do this in-place without altering the nodes' values.</p>
<p><strong>Example</strong>:<br>
Input: <code>head = [1, 2, 3, 4]</code><br>
Output: <code>[1, 4, 2, 3]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved in three steps:
<ol>
<li><strong>Split the list</strong> into two halves.</li>
<li><strong>Reverse the second half</strong> of the list.</li>
<li><strong>Merge</strong> the two halves in alternating fashion.</li>
</ol>
</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reorder_list</span><span class="hljs-params">(head)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-comment"># Step 1: Find the middle of the list using the slow-fast pointer approach</span>
    slow, fast = head, head
    <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next
    
    <span class="hljs-comment"># Step 2: Reverse the second half of the list</span>
    prev, curr = <span class="hljs-literal">None</span>, slow
    <span class="hljs-keyword">while</span> curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    
    <span class="hljs-comment"># Step 3: Merge the two halves</span>
    first, second = head, prev
    <span class="hljs-keyword">while</span> second.next:
        tmp1, tmp2 = first.next, second.next
        first.next = second
        second.next = tmp1
        first = tmp1
        second = tmp2

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list multiple times (split, reverse, merge)</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space for pointer manipulation</span>

<span class="hljs-comment"># Test the function with example linked lists (you can create linked list test cases)</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as this three-step approach is optimal for reordering in place.</li>
</ul>
<hr>
<h3 id="problem-11-remove-nth-node-from-end-of-list">Problem 11: Remove Nth Node From End of List</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the head of a linked list, remove the nth node from the end of the list and return its head.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>head = [1, 2, 3, 4, 5]</code>, <code>n = 2</code><br>
Output: <code>[1, 2, 3, 5]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Two Pointers</strong> approach. One pointer will be ahead of the other by <code>n</code> steps, so when the first pointer reaches the end, the second pointer will be at the node to remove.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_nth_from_end</span><span class="hljs-params">(head, n)</span>:</span>
    dummy = ListNode(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Create a dummy node before the head</span>
    dummy.next = head
    first = dummy
    second = dummy
    
    <span class="hljs-comment"># Move the first pointer so that it's `n` nodes ahead</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n + <span class="hljs-number">1</span>):
        first = first.next
    
    <span class="hljs-comment"># Move both pointers until first reaches the end</span>
    <span class="hljs-keyword">while</span> first:
        first = first.next
        second = second.next
    
    <span class="hljs-comment"># Second pointer is now at the node before the one to remove</span>
    second.next = second.next.next
    
    <span class="hljs-keyword">return</span> dummy.next  <span class="hljs-comment"># Return the modified list</span>

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list twice (move pointers and remove node)</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space for pointer manipulation</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed as the two-pointer approach is efficient and intuitive.</li>
</ul>
<hr>
<h3 id="problem-12-copy-list-with-random-pointer">Problem 12: Copy List with Random Pointer</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: A linked list is given where each node contains an additional random pointer which could point to any node in the list or <code>None</code>. You need to make a deep copy of this list.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</code><br>
Output: <code>[[7,null],[13,0],[11,4],[10,2],[1,0]]</code> (a deep copy of the original list).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved in two steps:
<ol>
<li>Create new nodes interleaved with the old nodes.</li>
<li>Assign the <code>random</code> pointers to the new nodes and then restore the original list.</li>
</ol>
</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, val, next=None, random=None)</span>:</span>
        self.val = val
        self.next = next
        self.random = random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy_random_list</span><span class="hljs-params">(head)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># Step 1: Create new nodes interleaved with the original ones</span>
    curr = head
    <span class="hljs-keyword">while</span> curr:
        new_node = Node(curr.val)
        new_node.next = curr.next
        curr.next = new_node
        curr = new_node.next
    
    <span class="hljs-comment"># Step 2: Assign random pointers for the copied nodes</span>
    curr = head
    <span class="hljs-keyword">while</span> curr:
        <span class="hljs-keyword">if</span> curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next
    
    <span class="hljs-comment"># Step 3: Separate the original and copied nodes</span>
    curr = head
    copy_head = head.next
    copy_curr = copy_head
    <span class="hljs-keyword">while</span> curr:
        curr.next = curr.next.next
        <span class="hljs-keyword">if</span> copy_curr.next:
            copy_curr.next = copy_curr.next.next
        curr = curr.next
        copy_curr = copy_curr.next
    
    <span class="hljs-keyword">return</span> copy_head

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the list</span>
<span class="hljs-comment"># Space Complexity: O(1) - interleaving the nodes uses constant space</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as this method solves the problem in O(n) time without additional space beyond the copied nodes.</li>
</ul>
<hr>
<h3 id="problem-13-add-two-numbers">Problem 13: Add Two Numbers</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two non-empty linked lists representing two non-negative integers, add the two numbers and return the sum as a linked list. The digits are stored in reverse order.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>l1 = [2, 4, 3]</code>, <code>l2 = [5, 6, 4]</code><br>
Output: <code>[7, 0, 8]</code> (since 342 + 465 = 807).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved by <strong>Simulating the Addition</strong> of two numbers, carrying over any value greater than 9.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_two_numbers</span><span class="hljs-params">(l1, l2)</span>:</span>
    dummy = ListNode()
    current = dummy
    carry = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Traverse both lists until both are empty</span>
    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:
        val1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        val2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        total = val1 + val2 + carry
        carry = total // <span class="hljs-number">10</span>  <span class="hljs-comment"># Calculate carry for the next digit</span>
        current.next = ListNode(total % <span class="hljs-number">10</span>)  <span class="hljs-comment"># Create the new node with the current digit</span>
        current = current.next
        
        <span class="hljs-comment"># Move to the next nodes</span>
        <span class="hljs-keyword">if</span> l1:
            l1 = l1.next
        <span class="hljs-keyword">if</span> l2:
            l2 = l2.next
    
    <span class="hljs-keyword">return</span> dummy.next

<span class="hljs-comment"># Time Complexity: O(max(n, m)) - where n and m are the lengths of the two lists</span>
<span class="hljs-comment"># Space Complexity: O(max(n, m)) - for the new linked list storing the sum</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this straightforward addition method works efficiently.</li>
</ul>
<hr>
<h3 id="problem-14-linked-list-cycle">Problem 14: Linked List Cycle</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a linked list, determine if it has a cycle in it.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>head = [3,2,0,-4]</code> (with a cycle)<br>
Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Floyd's Tortoise and Hare</strong> algorithm. We use two pointers (slow and fast). If there is a cycle, they will eventually meet.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_cycle</span><span class="hljs-params">(head)</span>:</span>
    slow = fast = head
    
    <span class="hljs-comment"># Move slow by one step and fast by two steps</span>
    <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next
        
        <span class="hljs-comment"># If they meet, there is a cycle</span>
        <span class="hljs-keyword">if</span> slow == fast:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># No cycle detected</span>

<span class="hljs-comment"># Time Complexity: O(n) - we traverse the list with two pointers</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space for the two pointers</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as Floyd's cycle detection algorithm is optimal.</li>
</ul>
<hr>
<h3 id="problem-15-find-the-duplicate-number">Problem 15: Find the Duplicate Number</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive, return the duplicate number. There is only one repeated number in <code>nums</code>.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1, 3, 4, 2, 2]</code><br>
Output: <code>2</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using the <strong>Floyd's Tortoise and Hare</strong> (Cycle Detection) algorithm, as the array can be viewed as a linked list where each number points to the index of the next number.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_duplicate</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Step 1: Use Floyd's Tortoise and Hare algorithm to detect the cycle</span>
    slow = fast = nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Move slow by one step and fast by two steps</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        slow = nums[slow]
        fast = nums[nums[fast]]
        <span class="hljs-keyword">if</span> slow == fast:
            <span class="hljs-keyword">break</span>
    
    <span class="hljs-comment"># Step 2: Find the entrance to the cycle (the duplicate number)</span>
    slow = nums[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">while</span> slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    
    <span class="hljs-keyword">return</span> slow

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of elements in the array</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space used for the pointers</span>

<span class="hljs-comment"># Test the function with the example</span>
print(find_duplicate([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as Floyd’s Tortoise and Hare algorithm is optimal for finding duplicates in this problem.</li>
</ul>
<hr>
<h3 id="problem-16-lru-cache">Problem 16: LRU Cache</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a data structure that follows the constraints of a <strong>Least Recently Used (LRU) Cache</strong>. Implement the <code>LRUCache</code> class with the following operations:
<ul>
<li><code>get(key)</code>: Return the value of the key if it exists, otherwise return <code>-1</code>.</li>
<li><code>put(key, value)</code>: Insert the key-value pair if it doesn't exist. If the cache exceeds its capacity, remove the least recently used item.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>LRUCache cache = new LRUCache(2); // Capacity is 2
cache.put(1, 1);
cache.put(2, 2);
cache.get(1); // returns 1
cache.put(3, 3); // evicts key 2
cache.get(2); // returns -1
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a combination of a <strong>HashMap</strong> (for quick access) and a <strong>Doubly Linked List</strong> (for tracking the order of use).</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, key=None, value=None)</span>:</span>
        self.key = key
        self.value = value
        self.prev = <span class="hljs-literal">None</span>
        self.next = <span class="hljs-literal">None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, capacity: int)</span>:</span>
        self.capacity = capacity
        self.cache = {}  <span class="hljs-comment"># HashMap to store keys and their corresponding nodes</span>
        self.head = Node()  <span class="hljs-comment"># Dummy head</span>
        self.tail = Node()  <span class="hljs-comment"># Dummy tail</span>
        self.head.next = self.tail  <span class="hljs-comment"># Initialize head and tail to point to each other</span>
        self.tail.prev = self.head

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_remove</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-string">"""Remove a node from the doubly linked list."""</span>
        prev, next = node.prev, node.next
        prev.next = next
        next.prev = prev

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-string">"""Add a node right after the head."""</span>
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self, key: int)</span> -&gt; int:</span>
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:
            node = self.cache[key]
            self._remove(node)  <span class="hljs-comment"># Move accessed node to the front</span>
            self._add(node)
            <span class="hljs-keyword">return</span> node.value
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span><span class="hljs-params">(self, key: int, value: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:
            self._remove(self.cache[key])
        node = Node(key, value)
        self._add(node)
        self.cache[key] = node
        <span class="hljs-keyword">if</span> len(self.cache) &gt; self.capacity:
            lru = self.tail.prev
            self._remove(lru)
            <span class="hljs-keyword">del</span> self.cache[lru.key]

<span class="hljs-comment"># Time Complexity: O(1) for both get and put operations</span>
<span class="hljs-comment"># Space Complexity: O(capacity) - for storing the cache and doubly linked list</span>

<span class="hljs-comment"># Test the LRU Cache</span>
cache = LRUCache(<span class="hljs-number">2</span>)
cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
print(cache.get(<span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: 1</span>
cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># Evicts key 2</span>
print(cache.get(<span class="hljs-number">2</span>))  <span class="hljs-comment"># Output: -1</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as using a combination of a HashMap and Doubly Linked List is optimal.</li>
</ul>
<hr>
<h3 id="problem-17-merge-k-sorted-lists">Problem 17: Merge K Sorted Lists</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of <code>k</code> linked lists, each list is sorted in ascending order, merge all the lists into one sorted linked list and return it.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>lists = [[1,4,5],[1,3,4],[2,6]]</code><br>
Output: <code>[1,1,2,3,4,4,5,6]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Min-Heap</strong> (or priority queue) to efficiently merge the lists by always choosing the smallest element from the available heads of the lists.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, val=<span class="hljs-number">0</span>, next=None)</span>:</span>
        self.val = val
        self.next = next

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_k_lists</span><span class="hljs-params">(lists)</span>:</span>
    <span class="hljs-comment"># Create a min-heap</span>
    min_heap = []
    
    <span class="hljs-comment"># Add the head of each list to the heap</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lists)):
        <span class="hljs-keyword">if</span> lists[i]:
            heapq.heappush(min_heap, (lists[i].val, i, lists[i]))
    
    dummy = ListNode()
    current = dummy
    
    <span class="hljs-comment"># Extract the smallest element and add the next node from that list to the heap</span>
    <span class="hljs-keyword">while</span> min_heap:
        val, i, node = heapq.heappop(min_heap)
        current.next = node
        current = current.next
        <span class="hljs-keyword">if</span> node.next:
            heapq.heappush(min_heap, (node.next.val, i, node.next))
    
    <span class="hljs-keyword">return</span> dummy.next

<span class="hljs-comment"># Time Complexity: O(N log k) - where N is the total number of nodes and k is the number of lists</span>
<span class="hljs-comment"># Space Complexity: O(k) - for the heap storing the heads of k lists</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as the heap-based solution efficiently solves the problem in O(N log k) time.</li>
</ul>
<hr>
<h3 id="problem-18-reverse-nodes-in-k-group">Problem 18: Reverse Nodes in k-Group</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a linked list, reverse the nodes of a linked list <code>k</code> at a time, and return its modified list. If the number of nodes is not a multiple of <code>k</code>, leave the last nodes as they are.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>head = [1, 2, 3, 4, 5]</code>, <code>k = 2</code><br>
Output: <code>[2, 1, 4, 3, 5]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved by <strong>Reversing Nodes in Groups</strong>. First, find the length of the list, then reverse nodes in chunks of size <code>k</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_k_group</span><span class="hljs-params">(head, k)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_linked_list</span><span class="hljs-params">(start, end)</span>:</span>
        <span class="hljs-string">"""Reverse the linked list from start to end."""</span>
        prev, curr = <span class="hljs-literal">None</span>, start
        <span class="hljs-keyword">while</span> curr != end:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        <span class="hljs-keyword">return</span> prev
    
    dummy = ListNode(<span class="hljs-number">0</span>)
    dummy.next = head
    group_prev = dummy
    
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        kth_node = group_prev
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(k):
            kth_node = kth_node.next
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kth_node:
                <span class="hljs-keyword">return</span> dummy.next
        
        group_next = kth_node.next
        <span class="hljs-comment"># Reverse the k nodes</span>
        prev, curr = group_prev.next, group_prev.next.next
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(k - <span class="hljs-number">1</span>):
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        
        temp = group_prev.next
        group_prev.next.next = group_next
        group_prev.next = prev
        group_prev = temp

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the list</span>
<span class="hljs-comment"># Space Complexity: O(1) - constant space for pointer manipulation</span>

<span class="hljs-comment"># Test the function with example linked lists</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary as the iterative reversal method is efficient.</li>
</ul>
<hr>
<h3 id="trees-section">Trees Section</h3>
<hr>
<h3 id="problem-19-invert-binary-tree">Problem 19: Invert Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Invert a binary tree.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    4
   / \
  2   7
 / \ / \
1  3 6  9
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>    4
   / \
  7   2
 / \ / \
9  6 3  1
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved recursively or iteratively by swapping the left and right children of each node.</li>
</ul>
<h4 id="solution-recursive">Solution (Recursive):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invert_tree</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># Swap the left and right children</span>
    root.left, root.right = root.right, root.left
    
    <span class="hljs-comment"># Recursively invert the subtrees</span>
    invert_tree(root.left)
    invert_tree(root.right)
    
    <span class="hljs-keyword">return</span> root

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Iterative Approach</strong> using a queue to perform level-order traversal and swap children at each level.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invert_tree_iterative</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    queue = deque([root])
    
    <span class="hljs-keyword">while</span> queue:
        node = queue.popleft()
        <span class="hljs-comment"># Swap the children</span>
        node.left, node.right = node.right, node.left
        <span class="hljs-keyword">if</span> node.left:
            queue.append(node.left)
        <span class="hljs-keyword">if</span> node.right:
            queue.append(node.right)
    
    <span class="hljs-keyword">return</span> root
</div></code></pre>
<hr>
<h3 id="problem-20-maximum-depth-of-binary-tree">Problem 20: Maximum Depth of Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    3
   / \
  9   20
     /  \
    15   7
</div></code></pre>
<p>Output: <code>3</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> (depth-first search) or <strong>Breadth-First Search</strong> (level-order traversal).</li>
</ul>
<h4 id="solution-recursive">Solution (Recursive):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_depth</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-comment"># The depth is the maximum of the left and right subtrees, plus 1 for the root</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(max_depth(root.left), max_depth(root.right))

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach-iterative">Alternative Approach (Iterative):</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_depth_iterative</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    queue = deque([root])
    depth = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Perform level-order traversal (BFS)</span>
    <span class="hljs-keyword">while</span> queue:
        depth += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(queue)):
            node = queue.popleft()
            <span class="hljs-keyword">if</span> node.left:
                queue.append(node.left)
            <span class="hljs-keyword">if</span> node.right:
                queue.append(node.right)
    
    <span class="hljs-keyword">return</span> depth

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the queue used in BFS</span>
</div></code></pre>
<hr>
<h3 id="problem-21-diameter-of-binary-tree">Problem 21: Diameter of Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    1
   / \
  2   3
 / \     
4   5    
</div></code></pre>
<p>Output: <code>3</code> (the longest path is [4,2,1,3] or [5,2,1,3], and the length is 3).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> (Depth-First Search). The diameter at any node is the sum of the heights of its left and right subtrees.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diameter_of_binary_tree</span><span class="hljs-params">(root)</span>:</span>
    diameter = <span class="hljs-number">0</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth</span><span class="hljs-params">(node)</span>:</span>
        <span class="hljs-keyword">nonlocal</span> diameter
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-comment"># Recursively find the depth of the left and right subtrees</span>
        left_depth = depth(node.left)
        right_depth = depth(node.right)
        <span class="hljs-comment"># Update the diameter (maximum path length at this node)</span>
        diameter = max(diameter, left_depth + right_depth)
        <span class="hljs-comment"># Return the depth of the tree at this node</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(left_depth, right_depth)
    
    depth(root)
    <span class="hljs-keyword">return</span> diameter

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as this solution is optimal.</li>
</ul>
<hr>
<h3 id="problem-22-balanced-binary-tree">Problem 22: Balanced Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    3
   / \
  9  20
     /  \
    15   7
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> (Depth-First Search) to check the height of the left and right subtrees and ensure the difference is not greater than 1.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_balanced</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">height</span><span class="hljs-params">(node)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-comment"># Check the height of the left and right subtrees</span>
        left_height = height(node.left)
        right_height = height(node.right)
        
        <span class="hljs-comment"># If any subtree is unbalanced, return -1</span>
        <span class="hljs-keyword">if</span> left_height == <span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> right_height == <span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> abs(left_height - right_height) &gt; <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(left_height, right_height)
    
    <span class="hljs-comment"># If height returns -1, the tree is not balanced</span>
    <span class="hljs-keyword">return</span> height(root) != <span class="hljs-number">-1</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as this solution efficiently checks the balance condition.</li>
</ul>
<hr>
<h3 id="problem-23-same-tree">Problem 23: Same Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the roots of two binary trees, determine if they are the same. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    Tree 1:
        1
       / \
      2   3
    Tree 2:
        1
       / \
      2   3
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> to compare both trees node by node.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_same_tree</span><span class="hljs-params">(p, q)</span>:</span>
    <span class="hljs-comment"># If both nodes are None, they are the same</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-comment"># If one node is None and the other is not, they are different</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-comment"># If the values of the nodes are different, they are different</span>
    <span class="hljs-keyword">if</span> p.val != q.val:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-comment"># Recursively check the left and right subtrees</span>
    <span class="hljs-keyword">return</span> is_same_tree(p.left, q.left) <span class="hljs-keyword">and</span> is_same_tree(p.right, q.right)

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the smaller tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with two binary trees</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this recursive solution efficiently compares the trees.</li>
</ul>
<hr>
<h3 id="problem-24-subtree-of-another-tree">Problem 24: Subtree of Another Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two binary trees <code>root</code> and <code>subRoot</code>, return <code>True</code> if there is a subtree of <code>root</code> that is identical to <code>subRoot</code>. A subtree of a binary tree is a tree that consists of a node and all its descendants.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    Root:
        3
       / \
      4   5
     / \
    1   2

    SubRoot:
        4
       / \
      1   2
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong>. For each node in the main tree, we check if the subtree rooted at that node is identical to the <code>subRoot</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_subtree</span><span class="hljs-params">(root, sub_root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">if</span> is_same_tree(root, sub_root):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-comment"># Recursively check the left and right subtrees</span>
    <span class="hljs-keyword">return</span> is_subtree(root.left, sub_root) <span class="hljs-keyword">or</span> is_subtree(root.right, sub_root)

<span class="hljs-comment"># Helper function to check if two trees are the same (as defined in the previous problem)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_same_tree</span><span class="hljs-params">(p, q)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q <span class="hljs-keyword">or</span> p.val != q.val:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> is_same_tree(p.left, q.left) <span class="hljs-keyword">and</span> is_same_tree(p.right, q.right)

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of nodes in the main tree and n is the number of nodes in the subtree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the main tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with two binary trees</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is required, as the recursive solution checks all potential subtrees efficiently.</li>
</ul>
<hr>
<h3 id="problem-25-lowest-common-ancestor-of-a-binary-search-tree">Problem 25: Lowest Common Ancestor of a Binary Search Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes. The LCA is defined as the lowest node that has both nodes as descendants.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    6
   / \
  2   8
 / \ / \
0  4 7  9
</div></code></pre>
<p>Nodes: <code>2</code> and <code>8</code><br>
Output: <code>6</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> or <strong>Iteration</strong>. Since it's a BST, we can take advantage of its properties</li>
</ul>
<p>to decide whether to go left or right.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowest_common_ancestor</span><span class="hljs-params">(root, p, q)</span>:</span>
    <span class="hljs-comment"># If both nodes are larger than the current node, go to the right subtree</span>
    <span class="hljs-keyword">if</span> p.val &gt; root.val <span class="hljs-keyword">and</span> q.val &gt; root.val:
        <span class="hljs-keyword">return</span> lowest_common_ancestor(root.right, p, q)
    <span class="hljs-comment"># If both nodes are smaller than the current node, go to the left subtree</span>
    <span class="hljs-keyword">elif</span> p.val &lt; root.val <span class="hljs-keyword">and</span> q.val &lt; root.val:
        <span class="hljs-keyword">return</span> lowest_common_ancestor(root.left, p, q)
    <span class="hljs-comment"># Otherwise, the current node is the LCA</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> root

<span class="hljs-comment"># Time Complexity: O(h) - where h is the height of the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with a binary search tree</span>
</div></code></pre>
<h4 id="alternative-approach-iterative">Alternative Approach (Iterative):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowest_common_ancestor_iterative</span><span class="hljs-params">(root, p, q)</span>:</span>
    <span class="hljs-keyword">while</span> root:
        <span class="hljs-keyword">if</span> p.val &gt; root.val <span class="hljs-keyword">and</span> q.val &gt; root.val:
            root = root.right
        <span class="hljs-keyword">elif</span> p.val &lt; root.val <span class="hljs-keyword">and</span> q.val &lt; root.val:
            root = root.left
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> root
</div></code></pre>
<hr>
<h3 id="problem-26-binary-tree-level-order-traversal">Problem 26: Binary Tree Level Order Traversal</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    3
   / \
  9  20
     /  \
    15   7
</div></code></pre>
<p>Output: <code>[[3], [9, 20], [15, 7]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Breadth-First Search (BFS)</strong> or <strong>Level Order Traversal</strong> with a queue.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">level_order</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> []
    
    result = []
    queue = deque([root])
    
    <span class="hljs-keyword">while</span> queue:
        level = []
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            <span class="hljs-keyword">if</span> node.left:
                queue.append(node.left)
            <span class="hljs-keyword">if</span> node.right:
                queue.append(node.right)
        result.append(level)
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing nodes in the queue</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is necessary, as BFS is the optimal solution for level order traversal.</li>
</ul>
<hr>
<h3 id="problem-27-binary-tree-right-side-view">Problem 27: Binary Tree Right Side View</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    1
   / \
  2   3
   \   \
    5   4
</div></code></pre>
<p>Output: <code>[1, 3, 4]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Level Order Traversal</strong> and capturing the last element of each level (which is the rightmost node).</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">right_side_view</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
        <span class="hljs-keyword">return</span> []
    
    result = []
    queue = deque([root])
    
    <span class="hljs-keyword">while</span> queue:
        rightmost_node = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(queue)):
            node = queue.popleft()
            rightmost_node = node  <span class="hljs-comment"># Update to the last node at this level</span>
            <span class="hljs-keyword">if</span> node.left:
                queue.append(node.left)
            <span class="hljs-keyword">if</span> node.right:
                queue.append(node.right)
        result.append(rightmost_node.val)  <span class="hljs-comment"># The rightmost node for this level</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing nodes in the queue</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>DFS (Depth-First Search)</strong> can also be used by visiting right children first and ensuring we add only the first node at each depth.</li>
</ul>
<hr>
<h3 id="problem-28-count-good-nodes-in-binary-tree">Problem 28: Count Good Nodes in Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a binary tree root, a node X in the tree is named <strong>good</strong> if in the path from the root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    3
   / \
  1   4
     / \
    1   5
</div></code></pre>
<p>Output: <code>4</code> (good nodes are 3, 4, 5, and 3 itself).</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>DFS (Depth-First Search)</strong> where, at each node, we check if the current node is greater than or equal to the maximum value seen so far in the path.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_nodes</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node, max_val)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-comment"># Count the current node as good if its value is greater than or equal to max_val</span>
        count = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> node.val &gt;= max_val <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        max_val = max(max_val, node.val)
        <span class="hljs-comment"># Recursively count good nodes in the left and right subtrees</span>
        count += dfs(node.left, max_val)
        count += dfs(node.right, max_val)
        <span class="hljs-keyword">return</span> count
    
    <span class="hljs-keyword">return</span> dfs(root, root.val)

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong> is needed, as this DFS-based solution is optimal.</li>
</ul>
<hr>
<h3 id="problem-29-validate-binary-search-tree">Problem 29: Validate Binary Search Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    2
   / \
  1   3
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong> by ensuring that each node satisfies the BST property, i.e., its value is greater than the allowed minimum and less than the allowed maximum.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid_bst</span><span class="hljs-params">(root)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate</span><span class="hljs-params">(node, low=float<span class="hljs-params">(<span class="hljs-string">'-inf'</span>)</span>, high=float<span class="hljs-params">(<span class="hljs-string">'inf'</span>)</span>)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-comment"># The current node's value must be between low and high</span>
        <span class="hljs-keyword">if</span> node.val &lt;= low <span class="hljs-keyword">or</span> node.val &gt;= high:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-comment"># Recursively validate the left and right subtrees</span>
        <span class="hljs-keyword">return</span> validate(node.left, low, node.val) <span class="hljs-keyword">and</span> validate(node.right, node.val, high)
    
    <span class="hljs-keyword">return</span> validate(root)

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>In-order traversal</strong> can also be used, where we ensure the values are visited in increasing order.</li>
</ul>
<hr>
<h3 id="problem-30-kth-smallest-element-in-a-bst">Problem 30: Kth Smallest Element in a BST</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given the root of a binary search tree, and an integer <code>k</code>, return the <code>k</code>th smallest element in the BST.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    3
   / \
  1   4
   \
    2
</div></code></pre>
<p>k = 1<br>
Output: <code>1</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>In-Order Traversal</strong> (which visits nodes in ascending order in a BST) and tracking the count of nodes visited.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kth_smallest</span><span class="hljs-params">(root, k)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorder</span><span class="hljs-params">(node)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> []
        <span class="hljs-keyword">return</span> inorder(node.left) + [node.val] + inorder(node.right)
    
    <span class="hljs-comment"># Perform an in-order traversal and get the k-th smallest element</span>
    <span class="hljs-keyword">return</span> inorder(root)[k - <span class="hljs-number">1</span>]

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree (we visit each node)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the inorder traversal list</span>

<span class="hljs-comment"># Test the function with a binary search tree</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Iterative In-order Traversal</strong> can be used with a stack to reduce the space complexity to O(h) where h is the height of the tree.</li>
</ul>
<hr>
<h3 id="problem-31-construct-binary-tree-from-preorder-and-inorder-traversal">Problem 31: Construct Binary Tree from Preorder and Inorder Traversal</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>Preorder = [3,9,20,15,7]  
Inorder = [9,3,15,20,7]
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>    3
   / \
  9  20
     / \
    15  7
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong>. The first element of the preorder array is the root, and we can find the root in the inorder array to split it into left and right subtrees.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(preorder, inorder)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># The first element in preorder is the root</span>
    root_val = preorder.pop(<span class="hljs-number">0</span>)
    root = TreeNode(root_val)
    
    <span class="hljs-comment"># Find the root in inorder to split the tree into left and right subtrees</span>
    inorder_index = inorder.index(root_val)
    
    <span class="hljs-comment"># Recursively build the left and right subtrees</span>
    root.left = build_tree(preorder, inorder[:inorder_index])
    root.right = build_tree(preorder, inorder[inorder_index + <span class="hljs-number">1</span>:])
    
    <span class="hljs-keyword">return</span> root

<span class="hljs-comment"># Time Complexity: O(n^2) - for each node, we need to search in the inorder array</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack and</span>

 new tree nodes

<span class="hljs-comment"># Test the function with preorder and inorder arrays</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Optimized Approach</strong>: Use a hashmap to store the indices of inorder elements for O(1) lookup, reducing the time complexity to O(n).</li>
</ul>
<hr>
<h3 id="problem-32-binary-tree-maximum-path-sum">Problem 32: Binary Tree Maximum Path Sum</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a non-empty binary tree, return the maximum path sum. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    1
   / \
  2   3
</div></code></pre>
<p>Output: <code>6</code> (1 → 2 → 3)</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Recursion</strong>. At each node, we calculate the maximum path sum that includes the current node and potentially its children.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_path_sum</span><span class="hljs-params">(root)</span>:</span>
    max_sum = float(<span class="hljs-string">'-inf'</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node)</span>:</span>
        <span class="hljs-keyword">nonlocal</span> max_sum
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-comment"># Compute the maximum sum on the left and right, ignoring negative sums</span>
        left_sum = max(dfs(node.left), <span class="hljs-number">0</span>)
        right_sum = max(dfs(node.right), <span class="hljs-number">0</span>)
        
        <span class="hljs-comment"># Update the global maximum path sum that passes through the current node</span>
        max_sum = max(max_sum, node.val + left_sum + right_sum)
        
        <span class="hljs-comment"># Return the maximum path sum with the current node as the endpoint</span>
        <span class="hljs-keyword">return</span> node.val + max(left_sum, right_sum)
    
    dfs(root)
    <span class="hljs-keyword">return</span> max_sum

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(h) - where h is the height of the tree (recursion stack)</span>

<span class="hljs-comment"># Test the function with a binary tree</span>
</div></code></pre>
<hr>
<h3 id="problem-33-serialize-and-deserialize-binary-tree">Problem 33: Serialize and Deserialize Binary Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a tree into a string, and deserialization is converting the string back to a tree.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>    1
   / \
  2   3
     / \
    4   5
</div></code></pre>
<p>Output: <code>1,2,3,null,null,4,5</code> (Serialized form)</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>We can solve this problem using <strong>Preorder Traversal</strong> to serialize and deserialize the tree.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""Encodes a tree to a single string."""</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preorder</span><span class="hljs-params">(node)</span>:</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
                <span class="hljs-keyword">return</span> <span class="hljs-string">"null,"</span>
            <span class="hljs-keyword">return</span> str(node.val) + <span class="hljs-string">","</span> + preorder(node.left) + preorder(node.right)
        
        <span class="hljs-keyword">return</span> preorder(root)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(self, data)</span>:</span>
        <span class="hljs-string">"""Decodes your encoded data to tree."""</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build</span><span class="hljs-params">(nodes)</span>:</span>
            val = nodes.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> val == <span class="hljs-string">"null"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            node = TreeNode(int(val))
            node.left = build(nodes)
            node.right = build(nodes)
            <span class="hljs-keyword">return</span> node
        
        node_list = data.split(<span class="hljs-string">','</span>)
        <span class="hljs-keyword">return</span> build(node_list)

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the tree</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the serialized data and the recursion stack</span>

<span class="hljs-comment"># Test the Codec class with a binary tree</span>
</div></code></pre>
<hr>
<h3 id="heap--priority-queue-section">Heap / Priority Queue Section</h3>
<hr>
<h3 id="problem-1-kth-largest-element-in-a-stream">Problem 1: Kth Largest Element in a Stream</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a class that finds the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</li>
</ul>
<p>Implement the <code>KthLargest</code> class:</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code>: Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li>
<li><code>int add(int val)</code>: Appends the integer <code>val</code> to the stream and returns the element representing the kth largest element.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Min-Heap</strong>. We maintain a heap of size <code>k</code>, where the smallest element in the heap will always represent the kth largest element.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, k: int, nums: list)</span>:</span>
        <span class="hljs-comment"># Initialize the heap and maintain the size as k</span>
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)  <span class="hljs-comment"># Convert nums into a heap</span>
        <span class="hljs-comment"># Reduce the size of the heap to k by popping the smallest elements</span>
        <span class="hljs-keyword">while</span> len(self.min_heap) &gt; k:
            heapq.heappop(self.min_heap)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, val: int)</span> -&gt; int:</span>
        <span class="hljs-comment"># Add the new value to the heap</span>
        heapq.heappush(self.min_heap, val)
        <span class="hljs-comment"># If the size of the heap exceeds k, pop the smallest element</span>
        <span class="hljs-keyword">if</span> len(self.min_heap) &gt; self.k:
            heapq.heappop(self.min_heap)
        <span class="hljs-comment"># The kth largest element is always at the root of the heap</span>
        <span class="hljs-keyword">return</span> self.min_heap[<span class="hljs-number">0</span>]

<span class="hljs-comment"># Time Complexity: O(log k) for adding elements (maintaining the heap)</span>
<span class="hljs-comment"># Space Complexity: O(k) for storing the k largest elements in the heap</span>

<span class="hljs-comment"># Test case</span>
kthLargest = KthLargest(<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>])
print(kthLargest.add(<span class="hljs-number">3</span>))  <span class="hljs-comment"># Output: 4</span>
print(kthLargest.add(<span class="hljs-number">5</span>))  <span class="hljs-comment"># Output: 5</span>
print(kthLargest.add(<span class="hljs-number">10</span>))  <span class="hljs-comment"># Output: 5</span>
print(kthLargest.add(<span class="hljs-number">9</span>))  <span class="hljs-comment"># Output: 8</span>
print(kthLargest.add(<span class="hljs-number">4</span>))  <span class="hljs-comment"># Output: 8</span>
</div></code></pre>
<hr>
<h3 id="problem-2-last-stone-weight">Problem 2: Last Stone Weight</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an array of integers <code>stones</code> where each stone represents the weight of a stone. In each turn, you select the two heaviest stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:
<ul>
<li>If <code>x == y</code>, both stones are destroyed.</li>
<li>If <code>x != y</code>, the stone with weight <code>y - x</code> remains.
Repeat this process until at most one stone remains. Return the weight of the last remaining stone, or 0 if no stones remain.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>stones = [2,7,4,1,8,1]</code><br>
Output: <code>1</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Max-Heap</strong> (in Python, we simulate a max-heap by using negative values in a min-heap).</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">last_stone_weight</span><span class="hljs-params">(stones)</span>:</span>
    <span class="hljs-comment"># Convert all stones into negative values to simulate a max-heap</span>
    stones = [-stone <span class="hljs-keyword">for</span> stone <span class="hljs-keyword">in</span> stones]
    heapq.heapify(stones)  <span class="hljs-comment"># Turn the list into a heap</span>
    
    <span class="hljs-comment"># Process the stones until there is at most one stone left</span>
    <span class="hljs-keyword">while</span> len(stones) &gt; <span class="hljs-number">1</span>:
        <span class="hljs-comment"># Pop the two largest stones (remember they are negative, so we negate them)</span>
        stone1 = -heapq.heappop(stones)
        stone2 = -heapq.heappop(stones)
        
        <span class="hljs-comment"># If they are not equal, push the difference back into the heap</span>
        <span class="hljs-keyword">if</span> stone1 != stone2:
            heapq.heappush(stones, -(stone1 - stone2))
    
    <span class="hljs-comment"># If there is no stone left, return 0, else return the last remaining stone</span>
    <span class="hljs-keyword">return</span> -stones[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> stones <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

<span class="hljs-comment"># Time Complexity: O(n log n) - where n is the number of stones, since each operation on the heap is log n</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the heap</span>

<span class="hljs-comment"># Test case</span>
print(last_stone_weight([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]))  <span class="hljs-comment"># Output: 1</span>
</div></code></pre>
<hr>
<h3 id="problem-3-k-closest-points-to-origin">Problem 3: K Closest Points to Origin</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of points where <code>points[i] = [xi, yi]</code> represents a point on the X-Y plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</li>
</ul>
<p>The distance between two points on the X-Y plane is the Euclidean distance. You may return the answer in any order.</p>
<p><strong>Example</strong>:<br>
Input: <code>points = [[1,3],[-2,2]]</code>, <code>k = 1</code><br>
Output: <code>[[-2, 2]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Max-Heap</strong> to store the closest <code>k</code> points.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">import</span> math

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">k_closest</span><span class="hljs-params">(points, k)</span>:</span>
    <span class="hljs-comment"># Max-heap to store the k closest points</span>
    max_heap = []
    
    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:
        x, y = point
        <span class="hljs-comment"># Calculate the squared distance from the origin (to avoid float precision issues)</span>
        dist = -(x ** <span class="hljs-number">2</span> + y ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># We use negative to simulate a max-heap</span>
        <span class="hljs-comment"># Push the point into the heap</span>
        heapq.heappush(max_heap, (dist, point))
        
        <span class="hljs-comment"># If the heap exceeds size k, remove the farthest point</span>
        <span class="hljs-keyword">if</span> len(max_heap) &gt; k:
            heapq.heappop(max_heap)
    
    <span class="hljs-comment"># Extract the points from the heap</span>
    <span class="hljs-keyword">return</span> [point <span class="hljs-keyword">for</span> _, point <span class="hljs-keyword">in</span> max_heap]

<span class="hljs-comment"># Time Complexity: O(n log k) - where n is the number of points, and k is the number of closest points</span>
<span class="hljs-comment"># Space Complexity: O(k) - for storing the k closest points in the heap</span>

<span class="hljs-comment"># Test case</span>
print(k_closest([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]], <span class="hljs-number">2</span>))  <span class="hljs-comment"># Output: [[-2, 2], [0, 1]]</span>
</div></code></pre>
<hr>
<h3 id="problem-4-kth-largest-element-in-an-array">Problem 4: Kth Largest Element in an Array</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code>th largest element in the array.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [3,2,3,1,2,4,5,5,6]</code>, <code>k = 4</code><br>
Output: <code>4</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Min-Heap</strong>. We maintain a heap of size <code>k</code>, and the top of the heap will always represent the <code>k</code>th largest element.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kth_largest</span><span class="hljs-params">(nums, k)</span>:</span>
    <span class="hljs-comment"># Initialize a min-heap with the first k elements</span>
    min_heap = nums[:k]
    heapq.heapify(min_heap)  <span class="hljs-comment"># Convert to a heap</span>
    
    <span class="hljs-comment"># Process the remaining elements in the array</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums[k:]:
        <span class="hljs-comment"># If the current number is greater than the smallest in the heap, replace it</span>
        <span class="hljs-keyword">if</span> num &gt; min_heap[<span class="hljs-number">0</span>]:
            heapq.heapreplace(min_heap, num)
    
    <span class="hljs-comment"># The top of the heap is the kth largest element</span>
    <span class="hljs-keyword">return</span> min_heap[<span class="hljs-number">0</span>]

<span class="hljs-comment"># Time Complexity: O(n log k) - we process n elements and maintain a heap of size k</span>
<span class="hljs-comment"># Space Complexity: O(k) - for storing the k largest elements in the heap</span>

<span class="hljs-comment"># Test case</span>
print(find_kth_largest([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">4</span>))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<hr>
<h3 id="problem-5-task-scheduler">Problem 5: Task Scheduler</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given a char array representing tasks, where each letter represents a different task. Tasks must be done in order, but there is a cooldown period <code>n</code> after each task is performed. You must wait <code>n</code> intervals before performing the same task again. You need to return the least number of intervals required to complete all the tasks.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]</code>, <code>n = 2</code><br>
Output: <code>8</code><br>
Explanation: The task execution sequence can be &quot;A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B&quot;.</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>Priority Queue (Max-Heap)</strong> to always schedule the most frequent tasks first.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">least_interval</span><span class="hljs-params">(tasks, n)</span>:</span>
    <span class="hljs-comment"># Step 1: Count the frequency of each task</span>
    task_counts = Counter(tasks)
    
    <span class="hljs-comment"># Step 2: Create a max-heap (invert counts to simulate max-heap in Python's min-heap)</span>
    max_heap = [-count <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> task_counts.values()]
    heapq.heapify(max_heap)  <span class="hljs-comment"># Heapify the list of counts</span>
    
    time = <span class="hljs-number">0</span>  <span class="hljs-comment"># To track the total intervals</span>
    <span class="hljs-keyword">while</span> max_heap:
        i = <span class="hljs-number">0</span>  <span class="hljs-comment"># Initialize the cycle for the interval</span>
        temp = []  <span class="hljs-comment"># Temporary storage for tasks that still need to be completed</span>
        
        <span class="hljs-comment"># Step 3: Schedule up to 'n + 1' tasks (cooldown period)</span>
        <span class="hljs-keyword">while</span> i &lt;= n:
            <span class="hljs-keyword">if</span> max_heap:
                <span class="hljs-comment"># Pop the most frequent task (invert back since heap is negative)</span>
                task = heapq.heappop(max_heap)
                <span class="hljs-keyword">if</span> task &lt; <span class="hljs-number">-1</span>:
                    <span class="hljs-comment"># If there's still more of this task to process, reduce count and store temporarily</span>
                    temp.append(task + <span class="hljs-number">1</span>)
            time += <span class="hljs-number">1</span>  <span class="hljs-comment"># Count the time intervals</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> max_heap <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> temp:
                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># If no more tasks are left, break out of the loop</span>
            i += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Step 4: Push remaining tasks back into the heap</span>
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> temp:
            heapq.heappush(max_heap, task)
    
    <span class="hljs-keyword">return</span> time

<span class="hljs-comment"># Time Complexity: O(n log k) - where n is the total number of tasks, and k is the number of unique tasks</span>
<span class="hljs-comment"># Space Complexity: O(k) - where k is the number of unique tasks in the heap</span>

<span class="hljs-comment"># Test the function with the example</span>
print(least_interval([<span class="hljs-string">"A"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"B"</span>], <span class="hljs-number">2</span>))  <span class="hljs-comment"># Output: 8</span>
</div></code></pre>
<hr>
<h3 id="problem-6-design-twitter">Problem 6: Design Twitter</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a simplified version of Twitter where users can post tweets, follow/unfollow others, and see the 10 most recent tweets in their news feed.</li>
</ul>
<p>Implement the <code>Twitter</code> class:</p>
<ul>
<li><code>postTweet(userId, tweetId)</code>: Composes a new tweet.</li>
<li><code>getNewsFeed(userId)</code>: Retrieves the 10 most recent tweet ids in the user's news feed.</li>
<li><code>follow(followerId, followeeId)</code>: Follower follows a followee.</li>
<li><code>unfollow(followerId, followeeId)</code>: Follower unfollows a followee.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>Twitter twitter = new Twitter();
twitter.postTweet(1, 5);
twitter.getNewsFeed(1);  // returns [5]
twitter.follow(1, 2);
twitter.postTweet(2, 6);
twitter.getNewsFeed(1);  // returns [6, 5]
twitter.unfollow(1, 2);
twitter.getNewsFeed(1);  // returns [5]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using a <strong>HashMap</strong> (to store user tweets and relationships) and a <strong>Min-Heap</strong> (to keep track of the 10 most recent tweets).</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, deque

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Twitter</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Tweet storage (userId -&gt; deque of tweets (tweetId, timestamp))</span>
        self.user_tweets = defaultdict(deque)
        <span class="hljs-comment"># User following relationships (follower -&gt; set of followees)</span>
        self.user_follows = defaultdict(set)
        self.time = <span class="hljs-number">0</span>  <span class="hljs-comment"># Global timestamp for tweets (to maintain order)</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postTweet</span><span class="hljs-params">(self, userId: int, tweetId: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Add the tweet to the user's deque (use deque to efficiently manage recent tweets)</span>
        self.user_tweets[userId].appendleft((tweetId, self.time))
        self.time += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the global time</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNewsFeed</span><span class="hljs-params">(self, userId: int)</span> -&gt; list:</span>
        <span class="hljs-comment"># Get the recent tweets from the user and all followees</span>
        tweet_candidates = list(self.user_tweets[userId])  <span class="hljs-comment"># Start with user's own tweets</span>
        
        <span class="hljs-comment"># Include tweets from followees</span>
        <span class="hljs-keyword">for</span> followee <span class="hljs-keyword">in</span> self.user_follows[userId]:
            tweet_candidates.extend(self.user_tweets[followee])
        
        <span class="hljs-comment"># Use a heap to get the 10 most recent tweets</span>
        <span class="hljs-keyword">return</span> [tweet[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> tweet <span class="hljs-keyword">in</span> heapq.nlargest(<span class="hljs-number">10</span>, tweet_candidates, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">follow</span><span class="hljs-params">(self, followerId: int, followeeId: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> followerId != followeeId:
            self.user_follows[followerId].add(followeeId)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(self, followerId: int, followeeId: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        self.user_follows[followerId].discard(followeeId)

<span class="hljs-comment"># Time Complexity: </span>
<span class="hljs-comment"># - postTweet: O(1) - adding to a deque is O(1)</span>
<span class="hljs-comment"># - getNewsFeed: O(k log k) - where k is the total number of tweets to sort for recent ones</span>
<span class="hljs-comment"># - follow/unfollow: O(1) - set operations are O(1)</span>
<span class="hljs-comment"># Space Complexity: O(n) - where n is the total number of tweets and relationships</span>

<span class="hljs-comment"># Test the Twitter class</span>
twitter = Twitter()
twitter.postTweet(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)
print(twitter.getNewsFeed(<span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: [5]</span>
twitter.follow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
twitter.postTweet(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)
print(twitter.getNewsFeed(<span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: [6, 5]</span>
twitter.unfollow(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
print(twitter.getNewsFeed(<span class="hljs-number">1</span>))  <span class="hljs-comment"># Output: [5]</span>
</div></code></pre>
<hr>
<h3 id="problem-7-find-median-from-data-stream">Problem 7: Find Median from Data Stream</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: The task is to design a data structure that supports the following operations efficiently:
<ul>
<li><code>addNum(num)</code>: Adds a number to the data stream.</li>
<li><code>findMedian()</code>: Returns the median of all elements so far.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    
medianFinder.addNum(2);    
medianFinder.findMedian(); // returns 1.5
medianFinder.addNum(3);    
medianFinder.findMedian(); // returns 2
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using two <strong>Heaps</strong>:
<ul>
<li>A max-heap to store the smaller half of the numbers.</li>
<li>A min-heap to store the larger half.</li>
</ul>
</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Max-heap to store the smaller half of the numbers (inverted for max-heap)</span>
        self.small = []
        <span class="hljs-comment"># Min-heap to store the larger half of the numbers</span>
        self.large = []

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addNum</span><span class="hljs-params">(self, num: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Step 1: Add the number to the small heap (max-heap)</span>
        heapq.heappush(self.small, -num)
        
        <span class="hljs-comment"># Step 2: Balance the heaps (ensure elements in small are &lt;= elements in large)</span>
        <span class="hljs-keyword">if</span> self.small <span class="hljs-keyword">and</span> self.large <span class="hljs-keyword">and</span> (-self.small[<span class="hljs-number">0</span>] &gt; self.large[<span class="hljs-number">0</span>]):
            heapq.heappush(self.large, -heapq.heappop(self.small))
        
        <span class="hljs-comment"># Step 3: Maintain the size property (either equal or small has one more element)</span>
        <span class="hljs-keyword">if</span> len(self.small) &gt; len(self.large) + <span class="hljs-number">1</span>:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        <span class="hljs-keyword">if</span> len(self.large) &gt; len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(self)</span> -&gt; float:</span>
        <span class="hljs-comment"># If the heaps are of different sizes, return the middle element from the larger heap</span>
        <span class="hljs-keyword">if</span> len(self.small) &gt; len(self.large):
            <span class="hljs-keyword">return</span> -self.small[<span class="hljs-number">0</span>]
        <span class="hljs-comment"># If the heaps are the same size, return the average of the two middle elements</span>
        <span class="hljs-keyword">return</span> (-self.small[<span class="hljs-number">0</span>] + self.large[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>

<span class="hljs-comment"># Time Complexity: </span>
<span class="hljs-comment"># - addNum: O(log n) for heap insertion and balancing</span>
<span class="hljs-comment"># - findMedian: O(1) for retrieving the median</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the elements in two heaps</span>

<span class="hljs-comment"># Test the MedianFinder class</span>
medianFinder = MedianFinder()
medianFinder.addNum(<span class="hljs-number">1</span>)
medianFinder.addNum(<span class="hljs-number">2</span>)
print(medianFinder.findMedian())  <span class="hljs-comment"># Output: 1.5</span>
medianFinder.addNum(

<span class="hljs-number">3</span>)
print(medianFinder.findMedian())  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<hr>
<h3 id="backtracking-section">Backtracking Section</h3>
<hr>
<h3 id="problem-1-subsets">Problem 1: Subsets</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an integer array <code>nums</code> of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1, 2, 3]</code><br>
Output: <code>[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> by exploring all possible subsets recursively.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums)</span>:</span>
    result = []  <span class="hljs-comment"># To store all the subsets</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(start, current_subset)</span>:</span>
        <span class="hljs-comment"># Append the current subset (make a copy to avoid mutation issues)</span>
        result.append(current_subset[:])
        
        <span class="hljs-comment"># Explore all other subsets by adding more elements</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start, len(nums)):
            <span class="hljs-comment"># Include nums[i] in the current subset</span>
            current_subset.append(nums[i])
            <span class="hljs-comment"># Recur with the next elements</span>
            backtrack(i + <span class="hljs-number">1</span>, current_subset)
            <span class="hljs-comment"># Backtrack: remove the last element to try other combinations</span>
            current_subset.pop()

    <span class="hljs-comment"># Start the backtracking with an empty subset</span>
    backtrack(<span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(2^n) - where n is the number of elements, each element can be included/excluded</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(subsets([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))  <span class="hljs-comment"># Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span>
</div></code></pre>
<hr>
<h3 id="problem-2-combination-sum">Problem 2: Combination Sum</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array of distinct integers <code>candidates</code> and a target integer <code>target</code>, return all unique combinations of <code>candidates</code> where the chosen numbers sum to <code>target</code>. You may use each number in the candidates array multiple times.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>candidates = [2, 3, 6, 7]</code>, <code>target = 7</code><br>
Output: <code>[[2, 2, 3], [7]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> to explore all possible combinations, allowing repetition of elements.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combination_sum</span><span class="hljs-params">(candidates, target)</span>:</span>
    result = []  <span class="hljs-comment"># To store all valid combinations</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(remaining, start, current_combination)</span>:</span>
        <span class="hljs-comment"># If the remaining sum is zero, add the current combination</span>
        <span class="hljs-keyword">if</span> remaining == <span class="hljs-number">0</span>:
            result.append(current_combination[:])
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># If the remaining sum is negative, stop exploring further</span>
        <span class="hljs-keyword">if</span> remaining &lt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Explore each candidate from the current starting point</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start, len(candidates)):
            current_combination.append(candidates[i])  <span class="hljs-comment"># Include candidates[i] in the combination</span>
            <span class="hljs-comment"># Recur with the updated remaining sum (we can reuse candidates[i])</span>
            backtrack(remaining - candidates[i], i, current_combination)
            current_combination.pop()  <span class="hljs-comment"># Backtrack and remove the last element</span>

    <span class="hljs-comment"># Start the backtracking with the target sum and empty combination</span>
    backtrack(target, <span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(2^n) - where n is the number of candidates, as we explore combinations recursively</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(combination_sum([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], <span class="hljs-number">7</span>))  <span class="hljs-comment"># Output: [[2, 2, 3], [7]]</span>
</div></code></pre>
<hr>
<h3 id="problem-3-permutations">Problem 3: Permutations</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an array <code>nums</code> of distinct integers, return all possible permutations.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1, 2, 3]</code><br>
Output: <code>[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> by exploring all possible ways to arrange the elements in the array.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums)</span>:</span>
    result = []  <span class="hljs-comment"># To store all permutations</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(current_permutation)</span>:</span>
        <span class="hljs-comment"># If the current permutation is complete, add it to the result</span>
        <span class="hljs-keyword">if</span> len(current_permutation) == len(nums):
            result.append(current_permutation[:])
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Try each element in the array</span>
        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> current_permutation:
                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># Skip if num is already used in the permutation</span>
            current_permutation.append(num)  <span class="hljs-comment"># Include num in the permutation</span>
            backtrack(current_permutation)  <span class="hljs-comment"># Recur with the next step</span>
            current_permutation.pop()  <span class="hljs-comment"># Backtrack by removing the last element</span>

    <span class="hljs-comment"># Start the backtracking with an empty permutation</span>
    backtrack([])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n * n!) - there are n! permutations, and each permutation takes O(n) to build</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(permute([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))  <span class="hljs-comment"># Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</span>
</div></code></pre>
<hr>
<h3 id="problem-4-subsets-ii">Problem 4: Subsets II</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an integer array <code>nums</code> that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>nums = [1, 2, 2]</code><br>
Output: <code>[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong>. To handle duplicates, we must sort the array and skip elements that are the same as the previous one.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets_with_dup</span><span class="hljs-params">(nums)</span>:</span>
    result = []  <span class="hljs-comment"># To store all unique subsets</span>
    nums.sort()  <span class="hljs-comment"># Sort the array to handle duplicates</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(start, current_subset)</span>:</span>
        <span class="hljs-comment"># Append the current subset</span>
        result.append(current_subset[:])
        
        <span class="hljs-comment"># Explore all other subsets by adding more elements</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start, len(nums)):
            <span class="hljs-comment"># Skip duplicates (only consider the first occurrence of each element)</span>
            <span class="hljs-keyword">if</span> i &gt; start <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:
                <span class="hljs-keyword">continue</span>
            current_subset.append(nums[i])  <span class="hljs-comment"># Include nums[i] in the current subset</span>
            backtrack(i + <span class="hljs-number">1</span>, current_subset)  <span class="hljs-comment"># Recur with the next elements</span>
            current_subset.pop()  <span class="hljs-comment"># Backtrack and remove the last element</span>

    <span class="hljs-comment"># Start the backtracking with an empty subset</span>
    backtrack(<span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(2^n) - where n is the number of elements (each element can be included/excluded)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(subsets_with_dup([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]))  <span class="hljs-comment"># Output: [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]</span>
</div></code></pre>
<hr>
<h3 id="problem-5-combination-sum-ii">Problem 5: Combination Sum II</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a collection of candidate numbers <code>candidates</code> and a target number <code>target</code>, return all unique combinations where the candidate numbers sum to <code>target</code>. Each number in <code>candidates</code> may only be used once.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>candidates = [10,1,2,7,6,1,5]</code>, <code>target = 8</code><br>
Output: <code>[[1,1,6], [1,2,5], [1,7], [2,6]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong>. To handle duplicates, we must sort the array and skip over duplicate elements after exploring them.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combination_sum2</span><span class="hljs-params">(candidates, target)</span>:</span>
    result = []  <span class="hljs-comment"># To store all unique combinations</span>
    candidates.sort()  <span class="hljs-comment"># Sort the candidates to handle duplicates</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(remaining, start, current_combination)</span>:</span>
        <span class="hljs-comment"># If the remaining sum is zero, add the current combination</span>
        <span class="hljs-keyword">if</span> remaining == <span class="hljs-number">0</span>:
            result.append(current_combination[:])
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Explore each candidate from the current starting point</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start, len(candidates)):
            <span class="hljs-comment"># Skip duplicates (only consider the first occurrence of each element)</span>
            <span class="hljs-keyword">if</span> i &gt; start <span class="hljs-keyword">and</span> candidates[i] == candidates[i - <span class="hljs-number">1</span>]:
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> candidates[i] &gt; remaining:
                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># Stop if the current number is greater than the remaining sum</span>
            current_combination.append(candidates[i])  <span class="hljs-comment"># Include candidates[i] in the combination</span>
            backtrack(remaining - candidates[i], i + <span class="hljs-number">1</span>, current_combination)  <span class="hljs-comment"># Recur with the next elements</span>
            current_comb

ination.pop()  <span class="hljs-comment"># Backtrack and remove the last element</span>

    <span class="hljs-comment"># Start the backtracking with the target sum and an empty combination</span>
    backtrack(target, <span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(2^n) - as we explore combinations recursively</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(combination_sum2([<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>], <span class="hljs-number">8</span>))  <span class="hljs-comment"># Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]</span>
</div></code></pre>
<hr>
<h3 id="problem-6-word-search">Problem 6: Word Search</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an <code>m x n</code> board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where &quot;adjacent&quot; cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]]</code>, <code>word = &quot;ABCCED&quot;</code><br>
Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> to explore all potential paths starting from each cell on the board.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exist</span><span class="hljs-params">(board, word)</span>:</span>
    rows, cols = len(board), len(board[<span class="hljs-number">0</span>])  <span class="hljs-comment"># Get the dimensions of the board</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(r, c, idx)</span>:</span>
        <span class="hljs-comment"># Base case: if we have found the entire word, return True</span>
        <span class="hljs-keyword">if</span> idx == len(word):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        
        <span class="hljs-comment"># Check the boundaries and if the current letter matches the word[idx]</span>
        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &gt;= rows <span class="hljs-keyword">or</span> c &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c &gt;= cols <span class="hljs-keyword">or</span> board[r][c] != word[idx]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        
        <span class="hljs-comment"># Temporarily mark the cell as visited</span>
        temp, board[r][c] = board[r][c], <span class="hljs-string">'#'</span>
        
        <span class="hljs-comment"># Explore all four directions (up, down, left, right)</span>
        found = (backtrack(r + <span class="hljs-number">1</span>, c, idx + <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span>
                 backtrack(r - <span class="hljs-number">1</span>, c, idx + <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span>
                 backtrack(r, c + <span class="hljs-number">1</span>, idx + <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span>
                 backtrack(r, c - <span class="hljs-number">1</span>, idx + <span class="hljs-number">1</span>))
        
        <span class="hljs-comment"># Backtrack: restore the original value in the board</span>
        board[r][c] = temp
        
        <span class="hljs-keyword">return</span> found

    <span class="hljs-comment"># Try starting from every cell on the board</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> backtrack(r, c, <span class="hljs-number">0</span>):  <span class="hljs-comment"># Start backtracking with the first letter of the word</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Time Complexity: O(m * n * 4^l) - where m * n is the size of the board, and l is the length of the word</span>
<span class="hljs-comment"># Space Complexity: O(l) - for the recursion stack (l is the length of the word)</span>

<span class="hljs-comment"># Test the function with the example</span>
print(exist([[<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"E"</span>], [<span class="hljs-string">"S"</span>, <span class="hljs-string">"F"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"S"</span>], [<span class="hljs-string">"A"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>, <span class="hljs-string">"E"</span>]], <span class="hljs-string">"ABCCED"</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Backtracking is the most suitable solution for this type of problem where multiple paths need to be explored.</li>
</ul>
<hr>
<h3 id="problem-7-palindrome-partitioning">Problem 7: Palindrome Partitioning</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of <code>s</code>.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>s = &quot;aab&quot;</code><br>
Output: <code>[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> to explore all possible ways to partition the string.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span><span class="hljs-params">(s)</span>:</span>
    result = []  <span class="hljs-comment"># To store all the partitions</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(start, current_partition)</span>:</span>
        <span class="hljs-comment"># If we have partitioned the entire string, add the current partition to the result</span>
        <span class="hljs-keyword">if</span> start == len(s):
            result.append(current_partition[:])
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Try to partition the string at every possible position</span>
        <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(start + <span class="hljs-number">1</span>, len(s) + <span class="hljs-number">1</span>):
            <span class="hljs-comment"># If the substring s[start:end] is a palindrome, explore further</span>
            <span class="hljs-keyword">if</span> s[start:end] == s[start:end][::<span class="hljs-number">-1</span>]:
                current_partition.append(s[start:end])
                backtrack(end, current_partition)  <span class="hljs-comment"># Recur for the next part of the string</span>
                current_partition.pop()  <span class="hljs-comment"># Backtrack to try other partitions</span>

    <span class="hljs-comment"># Start the backtracking with the entire string</span>
    backtrack(<span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(2^n) - since we explore every possible partition of the string</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(partition(<span class="hljs-string">"aab"</span>))  <span class="hljs-comment"># Output: [["a","a","b"],["aa","b"]]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Backtracking is the optimal approach to explore all palindrome partitions efficiently.</li>
</ul>
<hr>
<h3 id="problem-8-letter-combinations-of-a-phone-number">Problem 8: Letter Combinations of a Phone Number</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below:
<ul>
<li>2 -&gt; &quot;abc&quot;</li>
<li>3 -&gt; &quot;def&quot;</li>
<li>4 -&gt; &quot;ghi&quot;</li>
<li>5 -&gt; &quot;jkl&quot;</li>
<li>6 -&gt; &quot;mno&quot;</li>
<li>7 -&gt; &quot;pqrs&quot;</li>
<li>8 -&gt; &quot;tuv&quot;</li>
<li>9 -&gt; &quot;wxyz&quot;</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>digits = &quot;23&quot;</code><br>
Output: <code>[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> to explore all possible combinations of letters.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letter_combinations</span><span class="hljs-params">(digits)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:
        <span class="hljs-keyword">return</span> []
    
    <span class="hljs-comment"># Mapping of digits to corresponding letters</span>
    phone_map = {
        <span class="hljs-string">"2"</span>: <span class="hljs-string">"abc"</span>, <span class="hljs-string">"3"</span>: <span class="hljs-string">"def"</span>, <span class="hljs-string">"4"</span>: <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"5"</span>: <span class="hljs-string">"jkl"</span>, 
        <span class="hljs-string">"6"</span>: <span class="hljs-string">"mno"</span>, <span class="hljs-string">"7"</span>: <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"8"</span>: <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"9"</span>: <span class="hljs-string">"wxyz"</span>
    }
    
    result = []  <span class="hljs-comment"># To store all letter combinations</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(index, current_combination)</span>:</span>
        <span class="hljs-comment"># If the combination is complete (equal to the length of digits), add it to the result</span>
        <span class="hljs-keyword">if</span> index == len(digits):
            result.append(<span class="hljs-string">""</span>.join(current_combination))
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Get the letters that the current digit can represent</span>
        letters = phone_map[digits[index]]
        <span class="hljs-comment"># Explore each letter as part of the combination</span>
        <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:
            current_combination.append(letter)
            backtrack(index + <span class="hljs-number">1</span>, current_combination)  <span class="hljs-comment"># Move to the next digit</span>
            current_combination.pop()  <span class="hljs-comment"># Backtrack and try another letter</span>

    <span class="hljs-comment"># Start the backtracking with the first digit</span>
    backtrack(<span class="hljs-number">0</span>, [])
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(4^n) - where n is the length of digits (each digit can have up to 4 letters)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack</span>

<span class="hljs-comment"># Test the function with the example</span>
print(letter_combinations(<span class="hljs-string">"23"</span>))  <span class="hljs-comment"># Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Backtracking is the most suitable method to generate all combinations of letters for a given sequence of digits.</li>
</ul>
<hr>
<h3 id="problem-9-n-queens">Problem 9: N-Queens</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: The N-Queens problem is the problem of placing <code>n</code> chess queens on an <code>n x n</code> chessboard so that no two queens attack each other. Return all distinct solutions to the N-Queens puzzle.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>n = 4</code><br>
Output:</p>
<pre class="hljs"><code><div>[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],
  
 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Backtracking</strong> to explore all possible configurations and validate whether each configuration is a valid solution.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_n_queens</span><span class="hljs-params">(n)</span>:</span>
    result = []  <span class="hljs-comment"># To store all valid solutions</span>
    board = [[<span class="hljs-string">"."</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]  <span class="hljs-comment"># Initialize an empty board</span>
    
    <span class="hljs-comment"># Helper function to check if placing a queen at (row, col) is valid</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(row, col)</span>:</span>
        <span class="hljs-comment"># Check column</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(row):
            <span class="hljs-keyword">if</span> board[r][col] == <span class="hljs-string">"Q"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-comment"># Check diagonal (top-left to bottom-right)</span>
        <span class="hljs-keyword">for</span> r, c <span class="hljs-keyword">in</span> zip(range(row - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), range(col - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)):
            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">"Q"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-comment"># Check diagonal (top-right to bottom-left)</span>
        <span class="hljs-keyword">for</span> r, c <span class="hljs-keyword">in</span> zip(range(row - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), range(col + <span class="hljs-number">1</span>, n)):
            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">"Q"</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
    <span class="hljs-comment"># Backtracking function to place queens row by row</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(row)</span>:</span>
        <span class="hljs-keyword">if</span> row == n:
            <span class="hljs-comment"># Convert the board to a valid solution format and append it</span>
            result.append([<span class="hljs-string">""</span>.

join(r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> board])
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Try placing a queen in each column of the current row</span>
        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span> is_valid(row, col):
                board[row][col] = <span class="hljs-string">"Q"</span>  <span class="hljs-comment"># Place the queen</span>
                backtrack(row + <span class="hljs-number">1</span>)  <span class="hljs-comment"># Recur to place queens in the next row</span>
                board[row][col] = <span class="hljs-string">"."</span>  <span class="hljs-comment"># Backtrack and remove the queen</span>
    
    <span class="hljs-comment"># Start backtracking from the first row</span>
    backtrack(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Time Complexity: O(n!) - for exploring all possible placements of queens</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the recursion stack and storing the board</span>

<span class="hljs-comment"># Test the function with the example</span>
print(solve_n_queens(<span class="hljs-number">4</span>))
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Backtracking is the most efficient way to solve the N-Queens problem by exploring all possible placements of queens and pruning invalid configurations early.</li>
</ul>
<hr>
<h3 id="tries-section">Tries Section</h3>
<hr>
<h3 id="problem-1-implement-trie-prefix-tree">Problem 1: Implement Trie (Prefix Tree)</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: A trie (pronounced as &quot;try&quot;) or prefix tree is a data structure used to efficiently store and search strings, typically words. Implement a <code>Trie</code> class with the following functions:
<ul>
<li><code>insert(word)</code>: Inserts a word into the trie.</li>
<li><code>search(word)</code>: Returns <code>True</code> if the word is in the trie (i.e., was inserted before), <code>False</code> otherwise.</li>
<li><code>startsWith(prefix)</code>: Returns <code>True</code> if there is any word in the trie that starts with the given prefix, <code>False</code> otherwise.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>Trie trie = new Trie();
trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // returns True
trie.search(&quot;app&quot;);     // returns False
trie.startsWith(&quot;app&quot;); // returns True
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);     // returns True
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved by constructing a <strong>Trie</strong> (prefix tree) where each node stores its children and a flag indicating if a word ends at that node.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Dictionary to store children nodes (a-z)</span>
        self.children = {}
        <span class="hljs-comment"># Flag to indicate the end of a word</span>
        self.is_end_of_word = <span class="hljs-literal">False</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Initialize the root node</span>
        self.root = TrieNode()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, word: str)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Start from the root node</span>
        node = self.root
        <span class="hljs-comment"># Traverse through each character in the word</span>
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:
            <span class="hljs-comment"># If the character is not a child of the current node, create a new node</span>
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                node.children[char] = TrieNode()
            node = node.children[char]  <span class="hljs-comment"># Move to the child node</span>
        <span class="hljs-comment"># Mark the end of the word</span>
        node.is_end_of_word = <span class="hljs-literal">True</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, word: str)</span> -&gt; bool:</span>
        <span class="hljs-comment"># Start from the root node</span>
        node = self.root
        <span class="hljs-comment"># Traverse through each character in the word</span>
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># If character is not found, word does not exist</span>
            node = node.children[char]  <span class="hljs-comment"># Move to the next node</span>
        <span class="hljs-comment"># Check if this is the end of a word</span>
        <span class="hljs-keyword">return</span> node.is_end_of_word

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(self, prefix: str)</span> -&gt; bool:</span>
        <span class="hljs-comment"># Start from the root node</span>
        node = self.root
        <span class="hljs-comment"># Traverse through each character in the prefix</span>
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># If character is not found, no word with this prefix</span>
            node = node.children[char]  <span class="hljs-comment"># Move to the next node</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># Prefix exists</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the length of the word/prefix for both insert and search operations</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing n characters in the Trie for each word</span>

<span class="hljs-comment"># Test the Trie class with the example</span>
trie = Trie()
trie.insert(<span class="hljs-string">"apple"</span>)
print(trie.search(<span class="hljs-string">"apple"</span>))   <span class="hljs-comment"># Output: True</span>
print(trie.search(<span class="hljs-string">"app"</span>))     <span class="hljs-comment"># Output: False</span>
print(trie.startsWith(<span class="hljs-string">"app"</span>)) <span class="hljs-comment"># Output: True</span>
trie.insert(<span class="hljs-string">"app"</span>)
print(trie.search(<span class="hljs-string">"app"</span>))     <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. A Trie (prefix tree) is the most efficient data structure for problems involving prefix searches and insertions.</li>
</ul>
<hr>
<h3 id="problem-2-design-add-and-search-words-data-structure">Problem 2: Design Add and Search Words Data Structure</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Design a data structure that supports adding new words and finding if a string matches any previously added string. A string could contain the dot character <code>'.'</code> to represent any one letter. Implement the <code>WordDictionary</code> class:
<ul>
<li><code>addWord(word)</code>: Adds <code>word</code> to the data structure.</li>
<li><code>search(word)</code>: Returns <code>True</code> if the word or pattern (containing <code>.</code>) is found, otherwise <code>False</code>.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(&quot;bad&quot;);
wordDictionary.addWord(&quot;dad&quot;);
wordDictionary.addWord(&quot;mad&quot;);
wordDictionary.search(&quot;pad&quot;); // returns False
wordDictionary.search(&quot;bad&quot;); // returns True
wordDictionary.search(&quot;.ad&quot;); // returns True
wordDictionary.search(&quot;b..&quot;); // returns True
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved by modifying a <strong>Trie</strong> to handle the wildcard character <code>.</code> during the search operation.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordDictionary</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Trie node with children and end-of-word marker</span>
        self.root = TrieNode()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addWord</span><span class="hljs-params">(self, word: str)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Insert the word into the trie</span>
        node = self.root
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Mark the end of the word</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, word: str)</span> -&gt; bool:</span>
        <span class="hljs-comment"># Helper function to search with support for '.'</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(j, node)</span>:</span>
            <span class="hljs-comment"># Perform depth-first search</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(j, len(word)):
                char = word[i]
                <span class="hljs-keyword">if</span> char == <span class="hljs-string">'.'</span>:
                    <span class="hljs-comment"># If current character is '.', try all possible paths</span>
                    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children.values():
                        <span class="hljs-keyword">if</span> dfs(i + <span class="hljs-number">1</span>, child):
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                    node = node.children[char]
            <span class="hljs-keyword">return</span> node.is_end_of_word
        
        <span class="hljs-comment"># Start the search from the root</span>
        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, self.root)

<span class="hljs-comment"># Time Complexity: O(n) - for adding words, and O(n * 26^k) for searching with the '.' wildcard (where k is the length of the word)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing n characters in the Trie</span>

<span class="hljs-comment"># Test the WordDictionary class with the example</span>
wordDictionary = WordDictionary()
wordDictionary.addWord(<span class="hljs-string">"bad"</span>)
wordDictionary.addWord(<span class="hljs-string">"dad"</span>)
wordDictionary.addWord(<span class="hljs-string">"mad"</span>)
print(wordDictionary.search(<span class="hljs-string">"pad"</span>))  <span class="hljs-comment"># Output: False</span>
print(wordDictionary.search(<span class="hljs-string">"bad"</span>))  <span class="hljs-comment"># Output: True</span>
print(wordDictionary.search(<span class="hljs-string">".ad"</span>))  <span class="hljs-comment"># Output: True</span>
print(wordDictionary.search(<span class="hljs-string">"b.."</span>))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Using a Trie with recursive backtracking for handling the wildcard character <code>.</code> is the most effective solution for this problem.</li>
</ul>
<hr>
<h3 id="problem-3-word-search-ii">Problem 3: Word Search II</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an <code>m x n</code> board of characters and a list of strings <code>words</code>, find all the words on the board. The word can be constructed from letters of sequentially adjacent cells, where &quot;adjacent&quot; cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</li>
</ul>
<p><strong>Example</strong>:<br>
Input: <code>board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]]</code>, <code>words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code><br>
Output: <code>[&quot;eat&quot;,&quot;oath&quot;]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Trie</strong> (prefix tree) combined with <strong>Backtracking</strong> to explore the board and search for words.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.children = {}
        self.is_end_of_word = <span class="hljs-literal">False</span>
        self.word = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Store the complete word at the end node</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordSearchTrie</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.root = TrieNode()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, word: str)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-comment"># Insert the word into the trie</span>
        node = self.root
        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = <span class="hljs-literal">True</span>
        node.word = word  <span class="hljs-comment"># Store the complete word</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findWords</span><span class="hljs-params">(self, board, words)</span>:</span>
        <span class="hljs-comment"># Build a trie of the words</span>
        trie = WordSearchTrie()
        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:
            trie.insert(word)
        
        rows, cols = len(board), len(board[<span class="hljs-number">0</span>])
        result = set()  <span class="hljs-comment"># Use a set to avoid duplicate words</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(r, c, node)</span>:</span>
            <span class="hljs-comment"># Base case: if we reach a cell with no corresponding trie node, return</span>
            char = board[r][c]
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:
                <span class="hljs-keyword">return</span>
            <span class="hljs-comment"># Move to the next trie node</span>
            node = node.children[char]
            <span class="hljs-keyword">if</span> node.is_end_of_word:
                result.add(node.word)  <span class="hljs-comment"># Add the word to the result</span>
            
            <span class="hljs-comment"># Mark the cell as visited by temporarily changing its value</span>
            board[r][c] = <span class="hljs-string">'#'</span>
            
            <span class="hljs-comment"># Explore neighbors (up, down, left, right)</span>
            <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>

, <span class="hljs-number">-1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)]:
                nr, nc = r + dr, c + dc
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> board[nr][nc] != <span class="hljs-string">'#'</span>:
                    backtrack(nr, nc, node)
            
            <span class="hljs-comment"># Backtrack: restore the original value in the board</span>
            board[r][c] = char
        
        <span class="hljs-comment"># Start backtracking from each cell</span>
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
                backtrack(r, c, trie.root)
        
        <span class="hljs-keyword">return</span> list(result)

<span class="hljs-comment"># Time Complexity: O(m * n * 4^l) - where m*n is the size of the board and l is the maximum length of the word</span>
<span class="hljs-comment"># Space Complexity: O(k) - where k is the total number of letters in the Trie</span>

<span class="hljs-comment"># Test the function with the example</span>
board = [[<span class="hljs-string">"o"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>],[<span class="hljs-string">"e"</span>,<span class="hljs-string">"t"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"e"</span>],[<span class="hljs-string">"i"</span>,<span class="hljs-string">"h"</span>,<span class="hljs-string">"k"</span>,<span class="hljs-string">"r"</span>],[<span class="hljs-string">"i"</span>,<span class="hljs-string">"f"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"v"</span>]]
words = [<span class="hljs-string">"oath"</span>, <span class="hljs-string">"pea"</span>, <span class="hljs-string">"eat"</span>, <span class="hljs-string">"rain"</span>]
solution = Solution()
print(solution.findWords(board, words))  <span class="hljs-comment"># Output: ["eat", "oath"]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. Using a Trie with backtracking is the most effective way to solve this problem, efficiently combining word search with prefix-based optimizations.</li>
</ul>
<hr>
<h3 id="graphs-section">Graphs Section</h3>
<hr>
<h3 id="problem-1-number-of-islands">Problem 1: Number of Islands</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an <code>m x n</code> 2D grid of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
</div></code></pre>
<p>Output: <code>3</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Depth-First Search (DFS)</strong> to traverse each island and mark its area as visited.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_islands</span><span class="hljs-params">(grid)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    rows, cols = len(grid), len(grid[<span class="hljs-number">0</span>])
    num_of_islands = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(r, c)</span>:</span>
        <span class="hljs-comment"># Base case: stop if out of bounds or at water ('0')</span>
        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &gt;= rows <span class="hljs-keyword">or</span> c &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c &gt;= cols <span class="hljs-keyword">or</span> grid[r][c] == <span class="hljs-string">'0'</span>:
            <span class="hljs-keyword">return</span>
        
        <span class="hljs-comment"># Mark the current cell as visited (change '1' to '0')</span>
        grid[r][c] = <span class="hljs-string">'0'</span>
        
        <span class="hljs-comment"># Explore the neighbors in all four directions (up, down, left, right)</span>
        dfs(r + <span class="hljs-number">1</span>, c)
        dfs(r - <span class="hljs-number">1</span>, c)
        dfs(r, c + <span class="hljs-number">1</span>)
        dfs(r, c - <span class="hljs-number">1</span>)

    <span class="hljs-comment"># Iterate through the grid and apply DFS whenever we find land ('1')</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">'1'</span>:  <span class="hljs-comment"># Found an unvisited island</span>
                num_of_islands += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the island count</span>
                dfs(r, c)  <span class="hljs-comment"># Perform DFS to mark the entire island</span>

    <span class="hljs-keyword">return</span> num_of_islands

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns in the grid</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - due to the recursion stack and the grid size</span>

<span class="hljs-comment"># Test the function with the example</span>
grid = [
  [<span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>]
]
print(num_islands(grid))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li>
<p><strong>Breadth-First Search (BFS)</strong> can also be used to solve this problem. Instead of recursively exploring the island with DFS, we can use a queue to iteratively explore the land.</p>
<p>Here's the BFS alternative approach:</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_islands_bfs</span><span class="hljs-params">(grid)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    rows, cols = len(grid), len(grid[<span class="hljs-number">0</span>])
    num_of_islands = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span><span class="hljs-params">(r, c)</span>:</span>
        queue = deque([(r, c)])
        grid[r][c] = <span class="hljs-string">'0'</span>  <span class="hljs-comment"># Mark as visited</span>
        <span class="hljs-keyword">while</span> queue:
            r, c = queue.popleft()
            <span class="hljs-comment"># Explore all four directions</span>
            <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
                nr, nc = r + dr, c + dc
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> grid[nr][nc] == <span class="hljs-string">'1'</span>:
                    queue.append((nr, nc))
                    grid[nr][nc] = <span class="hljs-string">'0'</span>  <span class="hljs-comment"># Mark as visited</span>

    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">'1'</span>:  <span class="hljs-comment"># Found an unvisited island</span>
                num_of_islands += <span class="hljs-number">1</span>
                bfs(r, c)  <span class="hljs-comment"># Perform BFS to mark the entire island</span>

    <span class="hljs-keyword">return</span> num_of_islands

<span class="hljs-comment"># Time Complexity: O(m * n) - same as DFS</span>
<span class="hljs-comment"># Space Complexity: O(min(m, n)) - for the queue used in BFS</span>

<span class="hljs-comment"># Test the BFS function</span>
print(num_islands_bfs([
  [<span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>],
  [<span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"1"</span>]
]))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<hr>
<h3 id="problem-2-max-area-of-island">Problem 2: Max Area of Island</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an <code>m x n</code> binary matrix <code>grid</code> where '1' represents land and '0' represents water. Return the maximum area of an island in <code>grid</code>. An island is a group of connected '1's (land) connected vertically or horizontally. You may assume all four edges of the grid are surrounded by water.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>grid = [
  [0,0,1,0,0,0,0,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,1,1,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,0,1,1,0,0,1,0,1,0,0],
  [0,1,0,0,1,1,0,0,1,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,0,0,0,0,0,0,1,1,0,0,0,0]
]
</div></code></pre>
<p>Output: <code>6</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Depth-First Search (DFS)</strong> to explore the island area recursively and count its size.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_area_of_island</span><span class="hljs-params">(grid)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    rows, cols = len(grid), len(grid[<span class="hljs-number">0</span>])
    max_area = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(r, c)</span>:</span>
        <span class="hljs-comment"># Base case: stop if out of bounds or at water ('0')</span>
        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &gt;= rows <span class="hljs-keyword">or</span> c &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c &gt;= cols <span class="hljs-keyword">or</span> grid[r][c] == <span class="hljs-string">'0'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        
        <span class="hljs-comment"># Mark the current cell as visited (change '1' to '0') and initialize area to 1</span>
        grid[r][c] = <span class="hljs-string">'0'</span>
        area = <span class="hljs-number">1</span>  <span class="hljs-comment"># Count the current cell</span>
        
        <span class="hljs-comment"># Explore all four directions and accumulate the area</span>
        area += dfs(r + <span class="hljs-number">1</span>, c)
        area += dfs(r - <span class="hljs-number">1</span>, c)
        area += dfs(r, c + <span class="hljs-number">1</span>)
        area += dfs(r, c - <span class="hljs-number">1</span>)
        
        <span class="hljs-keyword">return</span> area

    <span class="hljs-comment"># Iterate through the grid and apply DFS whenever we find land ('1')</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">'1'</span>:  <span class="hljs-comment"># Found an unvisited land cell</span>
                max_area = max(max_area, dfs(r, c))  <span class="hljs-comment"># Update the maximum area</span>

    <span class="hljs-keyword">return</span> max_area

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns in the grid</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - due to the recursion stack and the grid size</span>

<span class="hljs-comment"># Test the function with the example</span>
grid = [
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
]
print(max_area_of_island(grid))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Breadth-First Search (BFS)</strong> can also be used to explore the island iteratively. This would replace the recursive DFS with an</li>
</ul>
<p>iterative queue-based BFS approach to calculate the area of each island.</p>
<p>Here's the BFS alternative approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_area_of_island_bfs</span><span class="hljs-params">(grid)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    rows, cols = len(grid), len(grid[<span class="hljs-number">0</span>])
    max_area = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span><span class="hljs-params">(r, c)</span>:</span>
        queue = deque([(r, c)])
        grid[r][c] = <span class="hljs-string">'0'</span>  <span class="hljs-comment"># Mark as visited</span>
        area = <span class="hljs-number">1</span>  <span class="hljs-comment"># Count the current cell</span>
        <span class="hljs-keyword">while</span> queue:
            r, c = queue.popleft()
            <span class="hljs-comment"># Explore all four directions</span>
            <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
                nr, nc = r + dr, c + dc
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> grid[nr][nc] == <span class="hljs-string">'1'</span>:
                    queue.append((nr, nc))
                    grid[nr][nc] = <span class="hljs-string">'0'</span>  <span class="hljs-comment"># Mark as visited</span>
                    area += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> area

    <span class="hljs-comment"># Iterate through the grid and apply BFS whenever we find land ('1')</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">'1'</span>:
                max_area = max(max_area, bfs(r, c))  <span class="hljs-comment"># Update the maximum area</span>

    <span class="hljs-keyword">return</span> max_area

<span class="hljs-comment"># Test the BFS function</span>
print(max_area_of_island_bfs([
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
]))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<hr>
<h3 id="problem-3-clone-graph">Problem 3: Clone Graph</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given a reference of a node in a <strong>connected</strong> undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (<code>val</code>) and a list (<code>neighbors</code>) of its neighbors.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>1 -- 2
|    |
4 -- 3
</div></code></pre>
<p>Output: A deep clone of this graph.</p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using either <strong>Depth-First Search (DFS)</strong> or <strong>Breadth-First Search (BFS)</strong> to traverse the graph and copy each node and its neighbors.</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, val = <span class="hljs-number">0</span>, neighbors = None)</span>:</span>
        self.val = val
        self.neighbors = neighbors <span class="hljs-keyword">if</span> neighbors <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> []

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clone_graph</span><span class="hljs-params">(node: <span class="hljs-string">'Node'</span>)</span> -&gt; 'Node':</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># Dictionary to store the mapping from original node to the cloned node</span>
    cloned_nodes = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(current_node)</span>:</span>
        <span class="hljs-comment"># If the node is already cloned, return the cloned node</span>
        <span class="hljs-keyword">if</span> current_node <span class="hljs-keyword">in</span> cloned_nodes:
            <span class="hljs-keyword">return</span> cloned_nodes[current_node]
        
        <span class="hljs-comment"># Create a new clone for the current node</span>
        clone = Node(current_node.val)
        cloned_nodes[current_node] = clone
        
        <span class="hljs-comment"># Recursively clone all the neighbors</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> current_node.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        <span class="hljs-keyword">return</span> clone
    
    <span class="hljs-comment"># Start DFS traversal and clone the graph</span>
    <span class="hljs-keyword">return</span> dfs(node)

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the graph (we visit each node once)</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the cloned nodes and the recursion stack</span>

<span class="hljs-comment"># Test the function with a small graph (manually create the graph and test cloning)</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>BFS (Breadth-First Search)</strong> can also be used to clone the graph iteratively. Instead of recursively traversing the graph, BFS uses a queue to process each node level by level.</li>
</ul>
<p>Here's the BFS alternative approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clone_graph_bfs</span><span class="hljs-params">(node: <span class="hljs-string">'Node'</span>)</span> -&gt; 'Node':</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-comment"># Dictionary to store the mapping from original node to the cloned node</span>
    cloned_nodes = {}
    <span class="hljs-comment"># Queue to process nodes in BFS manner</span>
    queue = deque([node])
    
    <span class="hljs-comment"># Clone the root node</span>
    cloned_nodes[node] = Node(node.val)
    
    <span class="hljs-comment"># Start BFS traversal</span>
    <span class="hljs-keyword">while</span> queue:
        current_node = queue.popleft()
        
        <span class="hljs-comment"># Iterate over the neighbors of the current node</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> current_node.neighbors:
            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cloned_nodes:
                <span class="hljs-comment"># Clone the neighbor if it hasn't been cloned yet</span>
                cloned_nodes[neighbor] = Node(neighbor.val)
                queue.append(neighbor)
            
            <span class="hljs-comment"># Link the clone of the current node to the clone of the neighbor</span>
            cloned_nodes[current_node].neighbors.append(cloned_nodes[neighbor])
    
    <span class="hljs-keyword">return</span> cloned_nodes[node]

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of nodes in the graph</span>
<span class="hljs-comment"># Space Complexity: O(n) - for storing the cloned nodes and the queue</span>

<span class="hljs-comment"># Test the BFS function with a small graph (manually create the graph and test cloning)</span>
</div></code></pre>
<hr>
<h3 id="problem-4-walls-and-gates">Problem 4: Walls and Gates</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given a grid <code>rooms</code> where:
<ul>
<li><code>-1</code> represents a wall or obstacle.</li>
<li><code>0</code> represents a gate.</li>
<li><code>∞</code> represents an empty room.</li>
</ul>
</li>
</ul>
<p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the distance as <code>∞</code>.</p>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>rooms = [
  [∞, -1, 0, ∞],
  [∞, ∞, ∞, -1],
  [∞, -1, ∞, -1],
  [0, -1, ∞, ∞]
]
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>[
  [3, -1, 0, 1],
  [2, 2, 1, -1],
  [1, -1, 2, -1],
  [0, -1, 3, 4]
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Breadth-First Search (BFS)</strong> starting from each gate (i.e., nodes with value <code>0</code>). BFS ensures that we find the shortest path from a gate to each empty room.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walls_and_gates</span><span class="hljs-params">(rooms)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rooms:
        <span class="hljs-keyword">return</span>
    
    rows, cols = len(rooms), len(rooms[<span class="hljs-number">0</span>])
    queue = deque()

    <span class="hljs-comment"># Enqueue all gates (cells with value 0)</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> rooms[r][c] == <span class="hljs-number">0</span>:
                queue.append((r, c))

    <span class="hljs-comment"># BFS from all gates at once</span>
    <span class="hljs-keyword">while</span> queue:
        r, c = queue.popleft()
        
        <span class="hljs-comment"># Explore all four directions (up, down, left, right)</span>
        <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
            nr, nc = r + dr, c + dc
            <span class="hljs-comment"># If the new position is within bounds and is an empty room (∞)</span>
            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> rooms[nr][nc] == float(<span class="hljs-string">'inf'</span>):
                <span class="hljs-comment"># Update the distance and add the new position to the queue</span>
                rooms[nr][nc] = rooms[r][c] + <span class="hljs-number">1</span>
                queue.append((nr, nc))

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - for storing the queue</span>

<span class="hljs-comment"># Test the function with the example grid</span>
rooms = [
  [float(<span class="hljs-string">'inf'</span>), <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, float(<span class="hljs-string">'inf'</span>)],
  [float(<span class="hljs-string">'inf'</span>), float(<span class="hljs-string">'inf'</span>), float(<span class="hljs-string">'inf'</span>), <span class="hljs-number">-1</span>],
  [float(<span class="hljs-string">'inf'</span>), <span class="hljs-number">-1</span>, float(<span class="hljs-string">'inf'</span>), <span class="hljs-number">-1</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, float(<span class="hljs-string">'inf'</span>), float(<span class="hljs-string">'inf'</span>)]
]
walls_and_gates(rooms)
print(rooms)  <span class="hljs-comment"># Output: [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. BFS is the most suitable solution for this problem as it guarantees that the shortest distance from each gate to an empty room is computed efficiently.</li>
</ul>
<hr>
<h3 id="problem-5-rotting-oranges">Problem 5: Rotting Oranges</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an <code>m x n</code> grid where each cell can have one of three values:
<ul>
<li><code>0</code> representing an empty cell.</li>
<li><code>1</code> representing a fresh orange.</li>
<li><code>2</code> representing a rotten orange.</li>
</ul>
</li>
</ul>
<p>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return <code>-1</code>.</p>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>grid = [
  [2,1,1],
  [1,1,0],
  [0,1,1]
]
</div></code></pre>
<p>Output: <code>4</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Breadth-First Search (BFS)</strong> to propagate the rot from all initially rotten oranges to adjacent fresh ones, keeping track of the time.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">oranges_rotting</span><span class="hljs-params">(grid)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid:
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    
    rows, cols = len(grid), len(grid[<span class="hljs-number">0</span>])
    queue = deque()
    fresh_oranges = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Initialize the queue with all rotten oranges and count fresh oranges</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-number">2</span>:
                queue.append((r, c))  <span class="hljs-comment"># Add rotten oranges to the queue</span>
            <span class="hljs-keyword">elif</span> grid[r][c] == <span class="hljs-number">1</span>:
                fresh_oranges += <span class="hljs-number">1</span>  <span class="hljs-comment"># Count fresh oranges</span>
    
    <span class="hljs-keyword">if</span> fresh_oranges == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># No fresh oranges to rot, return 0</span>
    
    <span class="hljs-comment"># BFS to rot adjacent oranges</span>
    minutes_passed = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> queue:
        minutes_passed += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(queue)):
            r, c = queue.popleft()
            
            <span class="hljs-comment"># Explore all four directions (up, down, left, right)</span>
            <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
                nr, nc = r + dr, c + dc
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> grid[nr][nc] == <span class="hljs-number">1</span>:
                    grid[nr][nc] = <span class="hljs-number">2</span>  <span class="hljs-comment"># Rot the fresh orange</span>
                    fresh_oranges -= <span class="hljs-number">1</span>  <span class="hljs-comment"># Decrease the count of fresh oranges</span>
                    queue.append((nr, nc))  <span class="hljs-comment"># Add</span>

 the newly rotten orange to the queue
    
    <span class="hljs-comment"># If there are still fresh oranges left, return -1, otherwise return minutes_passed</span>
    <span class="hljs-keyword">return</span> minutes_passed - <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> fresh_oranges == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - for storing the queue</span>

<span class="hljs-comment"># Test the function with the example grid</span>
grid = [
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
]
print(oranges_rotting(grid))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. BFS is the most efficient way to propagate the rotting process and track the time taken.</li>
</ul>
<hr>
<h3 id="problem-6-pacific-atlantic-water-flow">Problem 6: Pacific Atlantic Water Flow</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an <code>m x n</code> matrix of non-negative integers representing the height of each cell, find the list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. Water can only flow in four directions (up, down, left, right) and can flow from a cell to another one with a height equal or lower.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>matrix = [
  [1,2,2,3,5],
  [3,2,3,4,4],
  [2,4,5,3,1],
  [6,7,1,4,5],
  [5,1,1,2,4]
]
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Depth-First Search (DFS)</strong> starting from both the Pacific and Atlantic edges to explore the cells where water can flow. The cells visited by both DFS traversals are the ones where water can flow to both oceans.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pacific_atlantic</span><span class="hljs-params">(matrix)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix:
        <span class="hljs-keyword">return</span> []
    
    rows, cols = len(matrix), len(matrix[<span class="hljs-number">0</span>])
    pacific_reachable = set()  <span class="hljs-comment"># Cells reachable by the Pacific</span>
    atlantic_reachable = set()  <span class="hljs-comment"># Cells reachable by the Atlantic</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(r, c, visited, prev_height)</span>:</span>
        <span class="hljs-comment"># Base case: if out of bounds or if the current cell is lower than the previous one</span>
        <span class="hljs-keyword">if</span> (r, c) <span class="hljs-keyword">in</span> visited <span class="hljs-keyword">or</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &gt;= rows <span class="hljs-keyword">or</span> c &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c &gt;= cols <span class="hljs-keyword">or</span> matrix[r][c] &lt; prev_height:
            <span class="hljs-keyword">return</span>
        visited.add((r, c))  <span class="hljs-comment"># Mark the current cell as visited</span>
        <span class="hljs-comment"># Explore all four directions</span>
        <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
            dfs(r + dr, c + dc, visited, matrix[r][c])

    <span class="hljs-comment"># Start DFS from the Pacific ocean (top and left edges)</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        dfs(r, <span class="hljs-number">0</span>, pacific_reachable, matrix[r][<span class="hljs-number">0</span>])
        dfs(r, cols - <span class="hljs-number">1</span>, atlantic_reachable, matrix[r][cols - <span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        dfs(<span class="hljs-number">0</span>, c, pacific_reachable, matrix[<span class="hljs-number">0</span>][c])
        dfs(rows - <span class="hljs-number">1</span>, c, atlantic_reachable, matrix[rows - <span class="hljs-number">1</span>][c])

    <span class="hljs-comment"># The result is the intersection of cells reachable by both Pacific and Atlantic</span>
    <span class="hljs-keyword">return</span> list(pacific_reachable &amp; atlantic_reachable)

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - for the visited sets and recursion stack</span>

<span class="hljs-comment"># Test the function with the example matrix</span>
matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
  [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
]
print(pacific_atlantic(matrix))  <span class="hljs-comment"># Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. DFS is the best solution for exploring cells where water can flow in multiple directions.</li>
</ul>
<hr>
<h3 id="problem-7-surrounded-regions">Problem 7: Surrounded Regions</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given an <code>m x n</code> matrix board of 'X' and 'O', capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>board = [
  [&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;O&quot;, &quot;O&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;X&quot;, &quot;O&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;O&quot;, &quot;X&quot;, &quot;X&quot;]
]
</div></code></pre>
<p>Output:</p>
<pre class="hljs"><code><div>[
  [&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;],
  [&quot;X&quot;, &quot;O&quot;, &quot;X&quot;, &quot;X&quot;]
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Depth-First Search (DFS)</strong> or <strong>Breadth-First Search (BFS)</strong>. We'll first mark all the 'O's connected to the edges (which can't be surrounded), and then flip all the remaining 'O's to 'X's.</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve</span><span class="hljs-params">(board)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:
        <span class="hljs-keyword">return</span>
    
    rows, cols = len(board), len(board[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># Helper function to perform DFS and mark connected 'O's as safe (not to be flipped)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(r, c)</span>:</span>
        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> r &gt;= rows <span class="hljs-keyword">or</span> c &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c &gt;= cols <span class="hljs-keyword">or</span> board[r][c] != <span class="hljs-string">'O'</span>:
            <span class="hljs-keyword">return</span>
        board[r][c] = <span class="hljs-string">'S'</span>  <span class="hljs-comment"># Mark the 'O' as safe</span>
        <span class="hljs-comment"># Explore the four directions (up, down, left, right)</span>
        dfs(r + <span class="hljs-number">1</span>, c)
        dfs(r - <span class="hljs-number">1</span>, c)
        dfs(r, c + <span class="hljs-number">1</span>)
        dfs(r, c - <span class="hljs-number">1</span>)

    <span class="hljs-comment"># Step 1: Mark all 'O's on the boundary and their connected 'O's as safe</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        dfs(r, <span class="hljs-number">0</span>)
        dfs(r, cols - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        dfs(<span class="hljs-number">0</span>, c)
        dfs(rows - <span class="hljs-number">1</span>, c)

    <span class="hljs-comment"># Step 2: Flip all remaining 'O's to 'X', and convert 'S' back to 'O'</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">'O'</span>:
                board[r][c] = <span class="hljs-string">'X'</span>
            <span class="hljs-keyword">elif</span> board[r][c] == <span class="hljs-string">'S'</span>:
                board[r][c] = <span class="hljs-string">'O'</span>

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the number of rows and n is the number of columns</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - for the recursion stack in DFS</span>

<span class="hljs-comment"># Test the function with the example</span>
board = [
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>]
]
solve(board)
print(board)  <span class="hljs-comment"># Output: [["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "O", "X", "X"]]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Breadth-First Search (BFS)</strong> can also be used to mark the 'O's that should not be flipped. Instead of using recursive DFS, we can use a queue to iteratively mark the connected 'O's.</li>
</ul>
<p>Here's the BFS alternative approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_bfs</span><span class="hljs-params">(board)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:
        <span class="hljs-keyword">return</span>

    rows, cols = len(board), len(board[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># Helper function to perform BFS and mark connected 'O's as safe (not to be flipped)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span><span class="hljs-params">(r, c)</span>:</span>
        queue = deque([(r, c)])
        board[r][c] = <span class="hljs-string">'S'</span>  <span class="hljs-comment"># Mark the 'O' as safe</span>
        <span class="hljs-keyword">while</span> queue:
            r, c = queue.popleft()
            <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]:
                nr, nc = r + dr, c + dc
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; cols <span class="hljs-keyword">and</span> board[nr][nc] == <span class="hljs-string">'O'</span>:
                    board[nr][nc] = <span class="hljs-string">'S'</span>  <span class="hljs-comment"># Mark connected 'O' as safe</span>
                    queue.append((nr, nc))

    <span class="hljs-comment"># Step 1: Mark all 'O's on the boundary and their connected 'O's as safe</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        bfs(r, <span class="hljs-number">0</span>)
        bfs(r, cols - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        bfs(<span class="hljs-number">0</span>, c)
        bfs(rows - <span class="hljs-number">1</span>, c)

    <span class="hljs-comment"># Step 2: Flip all remaining 'O's to 'X', and convert 'S' back to 'O'</span>
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
            <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">'O'</span>:
                board[r][c] = <span class="hljs-string">'X'</span>
            <span class="hljs-keyword">elif</span> board[r][c] == <span class="hljs-string">'S'</span>:
                board[r][c] = <span class="hljs-string">'O'</span>

<span class="hljs-comment"># Test the BFS function</span>
board = [
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>],
  [<span class="hljs-string">"X"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"X"</span>]
]
solve_bfs(board)
print(board)  <span class="hljs-comment"># Output: [["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "O", "X", "X"]]</span>
</div></code></pre>
<hr>
<h3 id="problem-8-course-schedule">Problem 8: Course Schedule</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: There are <code>n</code> courses labeled from <code>0</code> to <code>n-1</code>. Some courses may have prerequisites. Given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you must take course <code>bi</code> before course <code>ai</code>, determine if you can finish all courses.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>n = 2
prerequisites = [[1, 0]]
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Topological Sorting</strong> with <strong>Depth-First Search (DFS)</strong> or <strong>Kahn's Algorithm</strong> (BFS). We need to check for cycles in the directed graph representing the prerequisites.</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_finish</span><span class="hljs-params">(num_courses, prerequisites)</span>:</span>
    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_courses)}
    <span class="hljs-keyword">for</span> course, prereq <span class="hljs-keyword">in</span> prerequisites:
        graph[prereq].append(course)

    <span class="hljs-comment"># To track the state of each node (0 = unvisited, 1 = visiting, 2 = visited)</span>
    visited = [<span class="hljs-number">0</span>] * num_courses

    <span class="hljs-comment"># Helper function to perform DFS and detect cycles</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(course)</span>:</span>
        <span class="hljs-keyword">if</span> visited[course] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># Cycle detected</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> visited[course] == <span class="hljs-number">2</span>:  <span class="hljs-comment"># Already visited, no need to revisit</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

        visited[course] = <span class="hljs-number">1</span>  <span class="hljs-comment"># Mark the node as visiting</span>

        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[course]:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(neighbor):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        
        visited[course] = <span class="hljs-number">2</span>  <span class="hljs-comment"># Mark the node as fully processed</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-comment"># Perform DFS on all nodes</span>
    <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> range(num_courses):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(course):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Cycle detected</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># No cycles, all courses can be completed</span>

<span class="hljs-comment"># Time Complexity: O(n + e) - where n is the number of courses, and e is the number of prerequisites</span>
<span class="hljs-comment"># Space Complexity: O(n + e) - for the graph and the visited array</span>

<span class="hljs-comment"># Test the function with the example</span>
print(can_finish(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Kahn's Algorithm (BFS)</strong> can also be used to perform topological sorting and detect cycles in the graph. This approach processes nodes in topological order using in-degrees.</li>
</ul>
<p>Here's the BFS alternative approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque, defaultdict

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_finish_bfs</span><span class="hljs-params">(num_courses, prerequisites)</span>:</span>
    <span class="hljs-comment"># Build the adjacency list and in-degree array</span>
    graph = defaultdict(list)
    in_degree = [<span class="hljs-number">0</span>] * num_courses
    
    <span class="hljs-keyword">for</span> course, prereq <span class="hljs-keyword">in</span> prerequisites:
        graph[prereq].append(course)
        in_degree[course] += <span class="hljs-number">1</span>

    <span class="hljs-comment"># Initialize the queue with all courses having 0 in-degree (no prerequisites)</span>
    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_courses) <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>])
    courses_taken = <span class="hljs-number">0</span>

    <span class="hljs-comment"># Process nodes in topological order</span>
    <span class="hljs-keyword">while</span> queue:
        course = queue.popleft()
        courses_taken += <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[course]:
            in_degree[neighbor] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># Reduce in-degree</span>
            <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:
                queue.append(neighbor)

    <span class="hljs-comment"># If we've processed all courses, there are</span>

 no cycles
    <span class="hljs-keyword">return</span> courses_taken == num_courses

<span class="hljs-comment"># Test the BFS function</span>
print(can_finish_bfs(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<hr>
<h3 id="problem-9-course-schedule-ii">Problem 9: Course Schedule II</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: There are <code>n</code> courses labeled from <code>0</code> to <code>n-1</code>. Some courses may have prerequisites. Given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you must take course <code>bi</code> before course <code>ai</code>, return the ordering of courses you should take to finish all courses. If there are multiple valid orderings, return any of them. If it is impossible to finish all courses, return an empty array.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>n = 2
prerequisites = [[1, 0]]
</div></code></pre>
<p>Output: <code>[0, 1]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Topological Sorting</strong> with <strong>Depth-First Search (DFS)</strong> or <strong>Kahn's Algorithm</strong> (BFS). We need to return a valid course order if there are no cycles.</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_order</span><span class="hljs-params">(num_courses, prerequisites)</span>:</span>
    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_courses)}
    <span class="hljs-keyword">for</span> course, prereq <span class="hljs-keyword">in</span> prerequisites:
        graph[prereq].append(course)

    visited = [<span class="hljs-number">0</span>] * num_courses
    result = []
    cycle_found = [<span class="hljs-literal">False</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(course)</span>:</span>
        <span class="hljs-keyword">if</span> visited[course] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># Cycle detected</span>
            cycle_found[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> visited[course] == <span class="hljs-number">2</span>:  <span class="hljs-comment"># Already processed</span>
            <span class="hljs-keyword">return</span>

        visited[course] = <span class="hljs-number">1</span>  <span class="hljs-comment"># Mark as visiting</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[course]:
            dfs(neighbor)
        
        visited[course] = <span class="hljs-number">2</span>  <span class="hljs-comment"># Mark as fully processed</span>
        result.append(course)

    <span class="hljs-comment"># Perform DFS on all courses</span>
    <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> range(num_courses):
        <span class="hljs-keyword">if</span> visited[course] == <span class="hljs-number">0</span>:
            dfs(course)
        <span class="hljs-keyword">if</span> cycle_found[<span class="hljs-number">0</span>]:
            <span class="hljs-keyword">return</span> []  <span class="hljs-comment"># If a cycle is detected, return an empty array</span>

    <span class="hljs-keyword">return</span> result[::<span class="hljs-number">-1</span>]  <span class="hljs-comment"># Return the reverse of the result list</span>

<span class="hljs-comment"># Time Complexity: O(n + e) - where n is the number of courses, and e is the number of prerequisites</span>
<span class="hljs-comment"># Space Complexity: O(n + e) - for the graph and visited array</span>

<span class="hljs-comment"># Test the function with the example</span>
print(find_order(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]))  <span class="hljs-comment"># Output: [0, 1]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Kahn's Algorithm (BFS)</strong> can also be used to generate a topological order using in-degrees. Here's the BFS alternative approach:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_order_bfs</span><span class="hljs-params">(num_courses, prerequisites)</span>:</span>
    graph = defaultdict(list)
    in_degree = [<span class="hljs-number">0</span>] * num_courses
    
    <span class="hljs-keyword">for</span> course, prereq <span class="hljs-keyword">in</span> prerequisites:
        graph[prereq].append(course)
        in_degree[course] += <span class="hljs-number">1</span>

    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_courses) <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>])
    order = []

    <span class="hljs-keyword">while</span> queue:
        course = queue.popleft()
        order.append(course)
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[course]:
            in_degree[neighbor] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:
                queue.append(neighbor)

    <span class="hljs-keyword">return</span> order <span class="hljs-keyword">if</span> len(order) == num_courses <span class="hljs-keyword">else</span> []

<span class="hljs-comment"># Test the BFS function</span>
print(find_order_bfs(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]))  <span class="hljs-comment"># Output: [0, 1]</span>
</div></code></pre>
<hr>
<h3 id="problem-10-graph-valid-tree">Problem 10: Graph Valid Tree</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You have a graph with <code>n</code> nodes labeled from <code>0</code> to <code>n-1</code>. You are given a list of edges where <code>edges[i] = [ai, bi]</code> represents an undirected edge between node <code>ai</code> and node <code>bi</code>. Determine if these edges make up a valid tree.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>n = 5
edges = [[0, 1], [0, 2], [0, 3], [1, 4]]
</div></code></pre>
<p>Output: <code>True</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>
<p>A graph is a valid tree if:</p>
<ol>
<li>It is connected (all nodes are reachable).</li>
<li>It contains no cycles.</li>
</ol>
<p>We can use <strong>Depth-First Search (DFS)</strong> or <strong>Breadth-First Search (BFS)</strong> to check both conditions.</p>
</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_tree</span><span class="hljs-params">(n, edges)</span>:</span>
    <span class="hljs-keyword">if</span> len(edges) != n - <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># A tree must have exactly n-1 edges</span>
    
    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)}
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()

    <span class="hljs-comment"># Helper function to perform DFS</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node, parent)</span>:</span>
        visited.add(node)
        <span class="hljs-comment"># Explore all the neighbors of the current node</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:
            <span class="hljs-keyword">if</span> neighbor == parent:
                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># Ignore the edge leading back to the parent</span>
            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> visited:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Found a cycle</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(neighbor, node):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-comment"># Start DFS from node 0</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-comment"># Check if all nodes were visited (i.e., the graph is connected)</span>
    <span class="hljs-keyword">return</span> len(visited) == n

<span class="hljs-comment"># Time Complexity: O(n + e) - where n is the number of nodes and e is the number of edges</span>
<span class="hljs-comment"># Space Complexity: O(n + e) - for the graph and visited set</span>

<span class="hljs-comment"># Test the function with the example</span>
print(valid_tree(<span class="hljs-number">5</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>]]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Breadth-First Search (BFS)</strong> can also be used to check for cycles and connectivity. Instead of using recursion, BFS uses a queue to iteratively explore the graph.</li>
</ul>
<p>Here’s the BFS alternative approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_tree_bfs</span><span class="hljs-params">(n, edges)</span>:</span>
    <span class="hljs-keyword">if</span> len(edges) != n - <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># A tree must have exactly n-1 edges</span>

    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)}
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()
    queue = deque([<span class="hljs-number">0</span>])
    visited.add(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">while</span> queue:
        node = queue.popleft()
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:
            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> visited:
                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># Already visited, skip</span>
            visited.add(neighbor)
            queue.append(neighbor)

    <span class="hljs-comment"># Check if all nodes were visited</span>
    <span class="hljs-keyword">return</span> len(visited) == n

<span class="hljs-comment"># Test the BFS function</span>
print(valid_tree_bfs(<span class="hljs-number">5</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>]]))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<hr>
<h3 id="problem-11-number-of-connected-components-in-an-undirected-graph">Problem 11: Number of Connected Components in an Undirected Graph</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: You are given an integer <code>n</code> representing the number of nodes, and an array <code>edges</code> where <code>edges[i] = [ai, bi]</code> represents an edge between nodes <code>ai</code> and <code>bi</code> in an undirected graph. Return the number of connected components in the graph.</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>n = 5
edges = [[0, 1], [1, 2], [3, 4]]
</div></code></pre>
<p>Output: <code>2</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>We can use <strong>Depth-First Search (DFS)</strong> or <strong>Breadth-First Search (BFS)</strong> to explore all connected components in the graph. We start from each unvisited node and explore all nodes in its connected component, counting how many connected components exist.</li>
</ul>
<h4 id="solution-dfs">Solution (DFS):</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_components</span><span class="hljs-params">(n, edges)</span>:</span>
    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)}
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()
    component_count = <span class="hljs-number">0</span>

    <span class="hljs-comment"># Helper function to perform DFS</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node)</span>:</span>
        visited.add(node)
        <span class="hljs-comment"># Explore all the neighbors of the current node</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:
            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
                dfs(neighbor)

    <span class="hljs-comment"># Perform DFS from every unvisited node</span>
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
            dfs(node)
            component_count += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the count of connected components</span>

    <span class="hljs-keyword">return</span> component_count

<span class="hljs-comment"># Time Complexity: O(n + e) - where n is the number of nodes and e is the number of edges</span>
<span class="hljs-comment"># Space Complexity: O(n + e) - for the graph and visited set</span>

<span class="hljs-comment"># Test the function with the example</span>
print(count_components(<span class="hljs-number">5</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>Breadth-First Search (BFS)</strong> can also be used to explore connected components. Here’s the BFS alternative approach:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_components_bfs</span><span class="hljs-params">(n, edges)</span>:</span>
    <span class="hljs-comment"># Build the adjacency list for the graph</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)}
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()
    component_count = <span class="hljs-number">0</span>

    <span class="hljs-comment"># Perform BFS from every unvisited node</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start)</span>:</span>
        queue = deque([start])
        visited.add(start)
        <span class="hljs-keyword">while</span> queue:
            node = queue.popleft()
            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:
                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
            bfs(node)
            component_count += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the count of connected components</span>

    <span class="hljs-keyword">return</span> component_count

<span class="hljs-comment"># Test the BFS function</span>
print(count_components_bfs(<span class="hljs-number">5</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<hr>
<h3 id="problem-12-redundant-connection">Problem 12: Redundant Connection</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: In this problem, a tree is a connected graph without cycles. You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The task is to find the edge that can be removed so that the resulting graph remains a tree (no cycles).</li>
</ul>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>edges = [[1, 2], [1, 3], [2, 3]]
</div></code></pre>
<p>Output: <code>[2, 3]</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Union-Find (Disjoint Set)</strong> to detect cycles. If adding an edge connects two nodes that are already connected (i.e., belong to the same set), then that edge creates a cycle and can be removed.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-comment"># Initialize each node to be its own parent (disjoint set)</span>
        self.parent = list(range(n))
        self.rank = [<span class="hljs-number">1</span>] * n  <span class="hljs-comment"># Used for union by rank</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-comment"># Find the root of the set containing the node (with path compression)</span>
        <span class="hljs-keyword">if</span> self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        <span class="hljs-keyword">return</span> self.parent[node]
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span><span class="hljs-params">(self, node1, node2)</span>:</span>
        <span class="hljs-comment"># Union by rank to merge two sets</span>
        root1 = self.find(node1)
        root2 = self.find(node2)
        <span class="hljs-keyword">if</span> root1 != root2:
            <span class="hljs-keyword">if</span> self.rank[root1] &gt; self.rank[root2]:
                self.parent[root2] = root1
            <span class="hljs-keyword">elif</span> self.rank[root1] &lt; self.rank[root2]:
                self.parent[root1] = root2
            <span class="hljs-keyword">else</span>:
                self.parent[root2] = root1
                self.rank[root1] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Cycle detected (nodes are already connected)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_redundant_connection</span><span class="hljs-params">(edges)</span>:</span>
    uf = UnionFind(len(edges) + <span class="hljs-number">1</span>)  <span class="hljs-comment"># Initialize union-find for n nodes (1-indexed)</span>

    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> uf.union(u - <span class="hljs-number">1</span>, v - <span class="hljs-number">1</span>):  <span class="hljs-comment"># Adjust for 0-based index</span>
            <span class="hljs-keyword">return</span> [u, v]  <span class="hljs-comment"># Return the edge that forms a cycle</span>

<span class="hljs-comment"># Time Complexity: O(n) - where n is the number of edges</span>
<span class="hljs-comment"># Space Complexity: O(n) - for the Union-F</span>

ind data structure

<span class="hljs-comment"># Test the function with the example</span>
print(find_redundant_connection([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]))  <span class="hljs-comment"># Output: [2, 3]</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. The <strong>Union-Find</strong> (Disjoint Set) data structure is the most efficient solution for this problem as it efficiently detects cycles in an undirected graph.</li>
</ul>
<hr>
<h3 id="problem-13-word-ladder">Problem 13: Word Ladder</h3>
<h4 id="problem-understanding">Problem Understanding:</h4>
<ul>
<li><strong>Problem Explanation</strong>: Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary's word list, return the length of the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>, such that:
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list.</li>
</ol>
</li>
</ul>
<p>If there is no such transformation sequence, return <code>0</code>.</p>
<p><strong>Example</strong>:<br>
Input:</p>
<pre class="hljs"><code><div>beginWord = &quot;hit&quot;
endWord = &quot;cog&quot;
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
</div></code></pre>
<p>Output: <code>5</code></p>
<h4 id="coding-pattern">Coding Pattern:</h4>
<ul>
<li>This problem can be solved using <strong>Breadth-First Search (BFS)</strong>. Each word is treated as a node, and there is an edge between two nodes if they differ by exactly one letter. BFS ensures we find the shortest transformation path.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">word_ladder</span><span class="hljs-params">(beginWord, endWord, wordList)</span>:</span>
    wordSet = set(wordList)  <span class="hljs-comment"># Convert the word list to a set for fast lookup</span>
    <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordSet:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># If endWord is not in the list, there's no valid transformation</span>

    <span class="hljs-comment"># Initialize the BFS queue with the beginWord and transformation length 1</span>
    queue = deque([(beginWord, <span class="hljs-number">1</span>)])

    <span class="hljs-keyword">while</span> queue:
        current_word, steps = queue.popleft()

        <span class="hljs-comment"># If the current word is the end word, return the number of steps</span>
        <span class="hljs-keyword">if</span> current_word == endWord:
            <span class="hljs-keyword">return</span> steps

        <span class="hljs-comment"># Try changing each letter of the current word</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(current_word)):
            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span>:
                next_word = current_word[:i] + c + current_word[i + <span class="hljs-number">1</span>:]
                <span class="hljs-keyword">if</span> next_word <span class="hljs-keyword">in</span> wordSet:
                    queue.append((next_word, steps + <span class="hljs-number">1</span>))  <span class="hljs-comment"># Add the next word to the queue</span>
                    wordSet.remove(next_word)  <span class="hljs-comment"># Remove the word from the set to avoid revisiting</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># If no transformation is found, return 0</span>

<span class="hljs-comment"># Time Complexity: O(m * n) - where m is the length of the words and n is the number of words in the word list</span>
<span class="hljs-comment"># Space Complexity: O(m * n) - for the queue and word set</span>

<span class="hljs-comment"># Test the function with the example</span>
print(word_ladder(<span class="hljs-string">"hit"</span>, <span class="hljs-string">"cog"</span>, [<span class="hljs-string">"hot"</span>, <span class="hljs-string">"dot"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"lot"</span>, <span class="hljs-string">"log"</span>, <span class="hljs-string">"cog"</span>]))  <span class="hljs-comment"># Output: 5</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<ul>
<li><strong>No alternative approach</strong>. BFS is the best way to find the shortest path in this type of transformation problem where each node represents a word, and edges exist between words that differ by only one letter.</li>
</ul>
<hr>
<h3 id="advanced-graphs">Advanced Graphs</h3>
<h4 id="1-reconstruct-itinerary-hard">1. <strong>Reconstruct Itinerary</strong> (Hard)</h4>
<h5 id="problem-understanding">Problem Understanding:</h5>
<p>You are given a list of airline tickets where <code>tickets[i] = [from_i, to_i]</code> represents a flight from <code>from_i</code> to <code>to_i</code>. Reconstruct the itinerary starting from &quot;JFK&quot;. The output itinerary must follow the lexical order when multiple valid itineraries are possible.</p>
<h5 id="problem-explanation">Problem Explanation:</h5>
<p>Given a list of tickets, each ticket represents a one-way flight between two cities. You must use all the tickets to form an itinerary, and the itinerary should start from &quot;JFK&quot;. If there are multiple possible itineraries, return the one that is lexically smallest.</p>
<p>Example:</p>
<pre class="hljs"><code><div>Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]
Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]
</div></code></pre>
<h5 id="coding-pattern">Coding Pattern:</h5>
<p>The problem can be solved using the <strong>Hierholzer's Algorithm</strong> (for Eulerian path/circuit in a graph). This is because every ticket must be used exactly once, and you are constructing a path.</p>
<h5 id="solution">Solution:</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findItinerary</span><span class="hljs-params">(tickets)</span>:</span>
    <span class="hljs-comment"># Step 1: Build the graph to represent the flight routes</span>
    graph = defaultdict(list)  <span class="hljs-comment"># A dictionary where each key points to a list of destinations.</span>
    
    <span class="hljs-comment"># Step 2: Sort tickets by lexical order (reverse=True ensures that we can pop destinations in correct order)</span>
    <span class="hljs-keyword">for</span> origin, destination <span class="hljs-keyword">in</span> sorted(tickets, reverse=<span class="hljs-literal">True</span>):
        graph[origin].append(destination)  <span class="hljs-comment"># Append the destination to the list of possible flights from origin.</span>
    
    result = []  <span class="hljs-comment"># This will hold our final itinerary in reverse order.</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit</span><span class="hljs-params">(airport)</span>:</span>
        <span class="hljs-comment"># While there are destinations we can fly to from this airport</span>
        <span class="hljs-keyword">while</span> graph[airport]:
            next_dest = graph[airport].pop()  <span class="hljs-comment"># Take the lexically smallest destination (since we sorted in reverse)</span>
            visit(next_dest)  <span class="hljs-comment"># Recursively visit the next airport</span>
        result.append(airport)  <span class="hljs-comment"># Once we can no longer fly anywhere from this airport, add it to the itinerary</span>
    
    <span class="hljs-comment"># Start DFS from 'JFK'</span>
    visit(<span class="hljs-string">'JFK'</span>)

    <span class="hljs-comment"># Since the itinerary is built in reverse order, we reverse it at the end to get the correct order</span>
    <span class="hljs-keyword">return</span> result[::<span class="hljs-number">-1</span>]

<span class="hljs-comment"># Example test case</span>
tickets = [[<span class="hljs-string">"MUC"</span>, <span class="hljs-string">"LHR"</span>], [<span class="hljs-string">"JFK"</span>, <span class="hljs-string">"MUC"</span>], [<span class="hljs-string">"SFO"</span>, <span class="hljs-string">"SJC"</span>], [<span class="hljs-string">"LHR"</span>, <span class="hljs-string">"SFO"</span>]]
print(findItinerary(tickets))  <span class="hljs-comment"># Output: ['JFK', 'MUC', 'LHR', 'SFO', 'SJC']</span>

</div></code></pre>
<h5 id="time-complexity">Time Complexity:</h5>
<ul>
<li><strong>Time</strong>: <code>O(E log E)</code> where <code>E</code> is the number of edges (flights). Sorting all the destinations takes <code>E log E</code> time, and the DFS runs in linear time <code>O(E)</code>.</li>
<li><strong>Space</strong>: <code>O(V + E)</code> for storing the graph, where <code>V</code> is the number of vertices (airports) and <code>E</code> is the number of edges.</li>
</ul>
<h5 id="alternative-approach">Alternative Approach:</h5>
<p>There isn't a fundamentally different approach for this problem, as it specifically relies on traversing all tickets exactly once, but there could be optimizations or slight variations in the DFS.</p>
<hr>
<h4 id="2-min-cost-to-connect-all-points-medium">2. <strong>Min Cost to Connect All Points</strong> (Medium)</h4>
<h5 id="problem-understanding">Problem Understanding:</h5>
<p>You are given <code>n</code> points on a 2D plane. The task is to connect all the points such that the total cost is minimized. The cost of connecting two points <code>(x1, y1)</code> and <code>(x2, y2)</code> is the Manhattan distance <code>|x1 - x2| + |y1 - y2|</code>.</p>
<h5 id="problem-explanation">Problem Explanation:</h5>
<p>We need to form a Minimum Spanning Tree (MST) to connect all points with minimum cost. The Manhattan distance between two points is the cost of the edge connecting those points.</p>
<p>Example:</p>
<pre class="hljs"><code><div>Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
</div></code></pre>
<h5 id="coding-pattern">Coding Pattern:</h5>
<p>This problem can be solved using <strong>Kruskal’s Algorithm</strong> or <strong>Prim’s Algorithm</strong>, which are both algorithms for finding the MST in a graph. We’ll use Prim’s Algorithm here.</p>
<h5 id="solution">Solution:</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq  <span class="hljs-comment"># To use a priority queue (min heap)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(points)</span>:</span>
    n = len(points)  <span class="hljs-comment"># Number of points</span>
    
    <span class="hljs-comment"># Helper function to calculate the Manhattan distance between two points</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">manhattan_dist</span><span class="hljs-params">(p1, p2)</span>:</span>
        <span class="hljs-keyword">return</span> abs(p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) + abs(p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>])
    
    <span class="hljs-comment"># Step 1: Priority queue to hold the next point to be added to the MST (cost, point_index)</span>
    pq = [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]  <span class="hljs-comment"># Start with the first point with a cost of 0</span>
    in_mst = [<span class="hljs-literal">False</span>] * n  <span class="hljs-comment"># Track which points are already included in the MST</span>
    total_cost = <span class="hljs-number">0</span>  <span class="hljs-comment"># Total cost to connect all points</span>
    edges_used = <span class="hljs-number">0</span>  <span class="hljs-comment"># Number of edges used to connect points</span>
    
    <span class="hljs-comment"># Step 2: Continue until we have added all points (n points means we need n-1 edges)</span>
    <span class="hljs-keyword">while</span> edges_used &lt; n:
        cost, u = heapq.heappop(pq)  <span class="hljs-comment"># Get the point with the smallest cost</span>
        
        <span class="hljs-comment"># Step 3: If this point is already in the MST, skip it</span>
        <span class="hljs-keyword">if</span> in_mst[u]:
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-comment"># Step 4: Otherwise, add this point to the MST</span>
        in_mst[u] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Mark the point as part of the MST</span>
        total_cost += cost  <span class="hljs-comment"># Add the cost of connecting this point</span>
        edges_used += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment the number of edges used</span>
        
        <span class="hljs-comment"># Step 5: Check all other points and calculate their distance from this point</span>
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> in_mst[v]:  <span class="hljs-comment"># If point v is not already in the MST</span>
                dist = manhattan_dist(points[u], points[v])  <span class="hljs-comment"># Calculate the Manhattan distance</span>
                heapq.heappush(pq, (dist, v))  <span class="hljs-comment"># Push this point and distance into the priority queue</span>
    
    <span class="hljs-keyword">return</span> total_cost  <span class="hljs-comment"># Return the total cost to connect all points</span>

<span class="hljs-comment"># Example test case</span>
points = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>]]
print(minCostConnectPoints(points))  <span class="hljs-comment"># Output: 20</span>

</div></code></pre>
<h5 id="time-complexity">Time Complexity:</h5>
<ul>
<li><strong>Time</strong>: <code>O(n^2 log n)</code> where <code>n</code> is the number of points. We calculate the distance for each pair of points (n^2), and the priority queue operations take <code>log n</code> time.</li>
<li><strong>Space</strong>: <code>O(n^2)</code> for storing the distances between every pair of points.</li>
</ul>
<h5 id="alternative-approach">Alternative Approach:</h5>
<p>An alternative approach is to use <strong>Kruskal’s Algorithm</strong>, which sorts all edges and then connects the smallest available edge that doesn’t form a cycle. The time complexity is the same, but Prim’s is generally more efficient for dense graphs.</p>
<hr>
<h3 id="3-network-delay-time-medium">3. <strong>Network Delay Time</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a network with <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. Each directed edge <code>(u, v, w)</code> represents a signal taking <code>w</code> units of time to travel from node <code>u</code> to node <code>v</code>. Starting from node <code>k</code>, the goal is to find the minimum time it takes for the signal to reach all nodes. If it's impossible to reach all nodes, return <code>-1</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]], n = 4, k = 2
Output: 2

Explanation:
From node 2, the signal reaches:
- Node 1 in 1 unit of time.
- Node 3 in 1 unit of time.
- Node 4 in 2 units of time (travel through node 3).
Thus, the time for the signal to reach the farthest node (node 4) is 2 units.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>The problem can be solved using <strong>Dijkstra's Algorithm</strong>, which is a shortest-path algorithm. It is well-suited for this problem since we are looking for the minimum travel time from the starting node <code>k</code> to all other nodes in a weighted, directed graph.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq  <span class="hljs-comment"># To use a priority queue (min heap)</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(times, n, k)</span>:</span>
    <span class="hljs-comment"># Step 1: Build the graph as an adjacency list</span>
    graph = {i: [] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>)}  <span class="hljs-comment"># Nodes are labeled from 1 to n</span>
    <span class="hljs-keyword">for</span> u, v, w <span class="hljs-keyword">in</span> times:
        graph[u].append((v, w))  <span class="hljs-comment"># Add an edge from u to v with weight w (time w)</span>
    
    <span class="hljs-comment"># Step 2: Priority queue to store (time, node), starting from the source node k</span>
    pq = [(<span class="hljs-number">0</span>, k)]  <span class="hljs-comment"># (time to reach node, node) starting with 0 time from node k</span>
    dist = {}  <span class="hljs-comment"># Dictionary to track the shortest time to reach each node</span>
    
    <span class="hljs-comment"># Step 3: Use Dijkstra's algorithm to find the shortest path</span>
    <span class="hljs-keyword">while</span> pq:
        time, node = heapq.heappop(pq)  <span class="hljs-comment"># Get the node with the smallest travel time</span>
        
        <span class="hljs-comment"># Skip if this node has already been processed</span>
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> dist:
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-comment"># Record the time it takes to reach this node</span>
        dist[node] = time
        
        <span class="hljs-comment"># Step 4: Visit all neighbors of the current node</span>
        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node]:
            <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dist:  <span class="hljs-comment"># Only consider neighbors we haven't visited yet</span>
                heapq.heappush(pq, (time + weight, neighbor))  <span class="hljs-comment"># Push neighbor with updated time</span>
    
    <span class="hljs-comment"># Step 5: If all nodes are reachable, return the maximum time, otherwise return -1</span>
    <span class="hljs-keyword">if</span> len(dist) == n:
        <span class="hljs-keyword">return</span> max(dist.values())  <span class="hljs-comment"># Return the maximum time to reach any node</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># Not all nodes were reachable</span>

<span class="hljs-comment"># Example test case</span>
times = [[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]]
n = <span class="hljs-number">4</span>
k = <span class="hljs-number">2</span>
print(networkDelayTime(times, n, k))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(E log V), where E is the number of edges and V is the number of vertices (nodes).</span>
<span class="hljs-comment"># Each edge is processed once, and each time we process a node, we perform a heap operation that takes log V time.</span>

<span class="hljs-comment"># Space Complexity: O(V + E) for storing the graph (V nodes, E edges) and the distance dictionary.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly better alternative approach for this problem than <strong>Dijkstra’s Algorithm</strong>, as it is optimized for finding the shortest path in weighted graphs.</p>
<hr>
<h3 id="4-swim-in-rising-water-hard">4. <strong>Swim in Rising Water</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an <code>n x n</code> grid, where each cell contains an integer representing the elevation at that point. The water in the grid rises, and at time <code>t</code>, the water has reached a level of <code>t</code>. You need to find the minimum time <code>t</code> required to swim from the top-left corner <code>(0, 0)</code> to the bottom-right corner <code>(n-1, n-1)</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: grid = [[0, 2, 1], [1, 3, 2], [3, 4, 2]]
Output: 3

Explanation:
You can swim from (0, 0) to (2, 2) at time 3 by following the path:
(0, 0) -&gt; (1, 0) -&gt; (1, 1) -&gt; (2, 1) -&gt; (2, 2)
The maximum elevation encountered along the path is 3, which is the minimum time you can swim across.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dijkstra’s Algorithm</strong> or a <strong>Priority Queue</strong>-based <strong>BFS</strong> (Best First Search). The idea is to always explore the path that allows you to reach the next cell with the lowest possible maximum elevation encountered so far.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(grid)</span>:</span>
    n = len(grid)  <span class="hljs-comment"># The size of the grid (n x n grid)</span>
    
    <span class="hljs-comment"># Step 1: Priority queue to store (time, row, col), starting from (0, 0)</span>
    pq = [(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]  <span class="hljs-comment"># (max elevation on the path so far, row, col)</span>
    visited = set()  <span class="hljs-comment"># To track visited cells</span>
    visited.add((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))  <span class="hljs-comment"># Mark the starting cell as visited</span>
    directions = [(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)]  <span class="hljs-comment"># Possible movement directions: right, down, left, up</span>
    
    <span class="hljs-comment"># Step 2: Continue processing the priority queue</span>
    <span class="hljs-keyword">while</span> pq:
        elevation, r, c = heapq.heappop(pq)  <span class="hljs-comment"># Get the cell with the smallest max elevation on the path</span>
        
        <span class="hljs-comment"># Step 3: If we've reached the bottom-right corner, return the time (elevation)</span>
        <span class="hljs-keyword">if</span> r == n<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> c == n<span class="hljs-number">-1</span>:
            <span class="hljs-keyword">return</span> elevation
        
        <span class="hljs-comment"># Step 4: Explore all 4 directions (right, down, left, up)</span>
        <span class="hljs-keyword">for</span> dr, dc <span class="hljs-keyword">in</span> directions:
            nr, nc = r + dr, c + dc  <span class="hljs-comment"># Calculate the new row and column</span>
            
            <span class="hljs-comment"># If the new cell is within bounds and hasn't been visited</span>
            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nr &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nc &lt; n <span class="hljs-keyword">and</span> (nr, nc) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
                visited.add((nr, nc))  <span class="hljs-comment"># Mark the new cell as visited</span>
                <span class="hljs-comment"># Push the new cell into the queue with the max elevation seen so far</span>
                heapq.heappush(pq, (max(elevation, grid[nr][nc]), nr, nc))

<span class="hljs-comment"># Example test case</span>
grid = [
    [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],
    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]
]
print(swimInWater(grid))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2 log n), where n is the size of the grid. </span>
<span class="hljs-comment"># There are n^2 cells, and each cell is processed with a heap operation that takes log n time.</span>

<span class="hljs-comment"># Space Complexity: O(n^2) for the priority queue and visited set.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There are no significantly different alternative approaches for this problem. The priority queue-based approach is optimal for exploring paths with the smallest maximum elevation in such scenarios.</p>
<hr>
<h3 id="5-alien-dictionary-hard">5. <strong>Alien Dictionary</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a list of words sorted in lexicographical order by an alien language. The goal is to derive the order of characters in this alien language. If no valid order exists, return an empty string.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: words = [&quot;wrt&quot;, &quot;wrf&quot;, &quot;er&quot;, &quot;ett&quot;, &quot;rftt&quot;]
Output: &quot;wertf&quot;

Explanation:
The order of characters is:
- 'w' comes before 'e'
- 'e' comes before 'r'
- 'r' comes before 't'
- 't' comes before 'f'
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This is a classic <strong>Topological Sorting</strong> problem, where you need to derive the order of elements based on pairwise dependencies. We can use <strong>Kahn's Algorithm</strong> (BFS) or <strong>DFS</strong> to solve the topological sort problem for directed acyclic graphs (DAGs).</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, deque

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alienOrder</span><span class="hljs-params">(words)</span>:</span>
    <span class="hljs-comment"># Step 1: Build the graph and indegree map</span>
    graph = defaultdict(set)  <span class="hljs-comment"># Adjacency list to store the graph</span>
    indegree = {char: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word}  <span class="hljs-comment"># Indegree of each node</span>

    <span class="hljs-comment"># Step 2: Establish relationships between characters by comparing adjacent words</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(words) - <span class="hljs-number">1</span>):
        word1, word2 = words[i], words[i + <span class="hljs-number">1</span>]
        min_len = min(len(word1), len(word2))
        
        <span class="hljs-comment"># Check if word2 is a valid prefix of word1 (invalid lexicographical order)</span>
        <span class="hljs-keyword">if</span> len(word1) &gt; len(word2) <span class="hljs-keyword">and</span> word1[:min_len] == word2:
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>  <span class="hljs-comment"># Invalid order, return empty string</span>
        
        <span class="hljs-comment"># Find the first difference between the two words and create the edge</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(min_len):
            <span class="hljs-keyword">if</span> word1[j] != word2[j]:
                <span class="hljs-keyword">if</span> word2[j] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph[word1[j]]:
                    graph[word1[j]].add(word2[j])  <span class="hljs-comment"># Create a directed edge</span>
                    indegree[word2[j]] += <span class="hljs-number">1</span>  <span class="hljs-comment"># Increment indegree of word2[j]</span>
                <span class="hljs-keyword">break</span>

    <span class="hljs-comment"># Step 3: Perform topological sort using BFS (Kahn's Algorithm)</span>
    <span class="hljs-comment"># Initialize queue with all nodes having 0 indegree</span>
    queue = deque([char <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> indegree <span class="hljs-keyword">if</span> indegree[char] == <span class="hljs-number">0</span>])
    order = []  <span class="hljs-comment"># To store the result of the topological sort</span>
    
    <span class="hljs-keyword">while</span> queue:
        char = queue.popleft()
        order.append(char)  <span class="hljs-comment"># Add current char to the sorted order</span>
        
        <span class="hljs-comment"># Decrease indegree of all neighbors and add to queue if indegree becomes 0</span>
        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[char]:
            indegree[neighbor] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> indegree[neighbor] == <span class="hljs-number">0</span>:
                queue.append(neighbor)
    
    <span class="hljs-comment"># If the number of characters in the result matches the number of unique characters, return the result</span>
    <span class="hljs-keyword">if</span> len(order) == len(indegree):
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(order)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>  <span class="hljs-comment"># Cycle detected, return empty string</span>

<span class="hljs-comment"># Example test case</span>
words = [<span class="hljs-string">"wrt"</span>, <span class="hljs-string">"wrf"</span>, <span class="hljs-string">"er"</span>, <span class="hljs-string">"ett"</span>, <span class="hljs-string">"rftt"</span>]
print(alienOrder(words))  <span class="hljs-comment"># Output: "wertf"</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(C), where C is the total number of characters in all the words combined.</span>
<span class="hljs-comment"># We build the graph in O(C) time and perform topological sorting in O(C) time.</span>

<span class="hljs-comment"># Space Complexity: O(1) if we consider only the alphabet of 26 characters.</span>
<span class="hljs-comment"># Otherwise, it's O(C) for storing the graph and indegree information.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>We could also use <strong>DFS</strong> to implement the topological sort, but the overall complexity remains the same, and BFS (Kahn’s Algorithm) is generally more intuitive in this case.</p>
<hr>
<h3 id="6-cheapest-flights-within-k-stops-medium">6. <strong>Cheapest Flights Within K Stops</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a list of flights where <code>flights[i] = [from_i, to_i, price_i]</code> represents a flight from city <code>from_i</code> to city <code>to_i</code> with a price of <code>price_i</code>. You are also given the starting city <code>src</code>, the destination <code>dst</code>, and the number of stops <code>k</code>. The goal is to find the cheapest price to travel from <code>src</code> to <code>dst</code> with at most <code>k</code> stops. If no such route exists, return <code>-1</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 4, flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 2, 500]], src = 0, dst = 3, k = 1
Output: 300

Explanation:
The cheapest route is:
- Take flight 0 -&gt; 1 (cost = 100), then flight 1 -&gt; 2 (cost = 100), then flight 2 -&gt; 3 (cost = 100)
Total cost = 300, with exactly 1 stop at city 2.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>BFS</strong> with a <strong>Priority Queue</strong> (similar to Dijkstra’s algorithm), but with an added constraint of <code>k</code> stops. Instead of finding the shortest path, we need to find the cheapest path under the given condition.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(n, flights, src, dst, k)</span>:</span>
    <span class="hljs-comment"># Step 1: Build the adjacency list for the graph</span>
    graph = defaultdict(list)
    <span class="hljs-keyword">for</span> u, v, price <span class="hljs-keyword">in</span> flights:
        graph[u].append((v, price))
    
    <span class="hljs-comment"># Step 2: Use a priority queue to perform BFS with the constraint of k stops</span>
    pq = [(<span class="hljs-number">0</span>, src, <span class="hljs-number">0</span>)]  <span class="hljs-comment"># (current cost, current city, current number of stops)</span>
    visited = {}  <span class="hljs-comment"># Dictionary to track the minimum cost to reach a city with a certain number of stops</span>
    
    <span class="hljs-keyword">while</span> pq:
        cost, city, stops = heapq.heappop(pq)
        
        <span class="hljs-comment"># If we reached the destination, return the cost</span>
        <span class="hljs-keyword">if</span> city == dst:
            <span class="hljs-keyword">return</span> cost
        
        <span class="hljs-comment"># If we have more stops available, continue exploring</span>
        <span class="hljs-keyword">if</span> stops &lt;= k:
            <span class="hljs-keyword">for</span> neighbor, price <span class="hljs-keyword">in</span> graph[city]:
                new_cost = cost + price
                <span class="hljs-comment"># Only add to the queue if it's the first visit or cheaper with fewer stops</span>
                <span class="hljs-keyword">if</span> (neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited) <span class="hljs-keyword">or</span> (visited[neighbor] &gt; stops):
                    visited[neighbor] = stops
                    heapq.heappush(pq, (new_cost, neighbor, stops + <span class="hljs-number">1</span>))
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># If we cannot reach the destination within k stops</span>

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">4</span>
flights = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">500</span>]]
src = <span class="hljs-number">0</span>
dst = <span class="hljs-number">3</span>
k = <span class="hljs-number">1</span>
print(findCheapestPrice(n, flights, src, dst, k))  <span class="hljs-comment"># Output: 300</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2 log n), where n is the number of cities.</span>
<span class="hljs-comment"># In the worst case, we explore all possible connections between cities.</span>

<span class="hljs-comment"># Space Complexity: O(n^2) for storing the graph and priority queue information.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>No other fundamentally different approach exists. The use of BFS with a priority queue is optimal for this type of problem, where we need to account for costs while restricting the number of steps.</p>
<hr>
<h3 id="7-climbing-stairs-easy">7. <strong>Climbing Stairs</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are climbing a staircase with <code>n</code> steps. You can either take 1 step or 2 steps at a time. The task is to find the number of distinct ways you can reach the top.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 3
Output: 3

Explanation:
- You can climb to the top in the following ways:
  1. (1 step) + (1 step) + (1 step)
  2. (1 step) + (2 steps)
  3. (2 steps) + (1 step)
So, there are 3 distinct ways to climb 3 steps.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. It's similar to the Fibonacci sequence because, to reach step <code>n</code>, you can either come from step <code>n-1</code> (1 step) or step <code>n-2</code> (2 steps). Thus, the number of ways to reach step <code>n</code> is the sum of the ways to reach <code>n-1</code> and <code>n-2</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># Only 1 way to climb 1 step</span>
    
    <span class="hljs-comment"># Step 1: Initialize two base cases for dynamic programming</span>
    prev1, prev2 = <span class="hljs-number">2</span>, <span class="hljs-number">1</span>  <span class="hljs-comment"># prev1 is ways to reach step 2, prev2 is ways to reach step 1</span>
    
    <span class="hljs-comment"># Step 2: Use a bottom-up approach to calculate the number of ways to reach each step</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):
        current = prev1 + prev2  <span class="hljs-comment"># The number of ways to reach step i is the sum of the ways to reach i-1 and i-2</span>
        prev2 = prev1  <span class="hljs-comment"># Shift prev2 to prev1 for the next iteration</span>
        prev1 = current  <span class="hljs-comment"># Move current result to prev1 for the next iteration</span>
    
    <span class="hljs-keyword">return</span> prev1  <span class="hljs-comment"># The answer for step n</span>

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">3</span>
print(climbStairs(n))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), because we iterate through each step from 1 to n.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using only two variables to store the intermediate results (constant space).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>No other fundamentally different approach exists, as <strong>Dynamic Programming</strong> is the optimal solution here. We could solve it using recursion with memoization, but the time and space complexity would remain the same.</p>
<hr>
<h3 id="8-min-cost-climbing-stairs-easy">8. <strong>Min Cost Climbing Stairs</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an array <code>cost</code> where <code>cost[i]</code> represents the cost of stepping on the <code>i</code>-th stair. Once you pay the cost, you can either move to the next stair or skip one stair. The task is to find the minimum cost required to reach the top of the staircase.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: cost = [10, 15, 20]
Output: 15

Explanation:
- Start on step 1 (cost = 15), then take a single step to the top (no cost).
- The total cost is 15.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can also be solved using <strong>Dynamic Programming</strong>. To find the minimum cost to reach the top from any step <code>i</code>, you need to consider the minimum cost from the previous two steps <code>i-1</code> and <code>i-2</code>, because you can either take 1 step or 2 steps.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize two base cases for dynamic programming</span>
    prev1, prev2 = cost[<span class="hljs-number">1</span>], cost[<span class="hljs-number">0</span>]  <span class="hljs-comment"># prev1 is cost to reach step 1, prev2 is cost to reach step 0</span>
    
    <span class="hljs-comment"># Step 2: Use a bottom-up approach to calculate the minimum cost for each step</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(cost)):
        current = min(prev1, prev2) + cost[i]  <span class="hljs-comment"># Minimum cost to reach step i</span>
        prev2 = prev1  <span class="hljs-comment"># Shift prev2 to prev1 for the next iteration</span>
        prev1 = current  <span class="hljs-comment"># Move current result to prev1 for the next iteration</span>
    
    <span class="hljs-comment"># Step 3: Return the minimum cost of reaching the top from either the last step or the second last step</span>
    <span class="hljs-keyword">return</span> min(prev1, prev2)

<span class="hljs-comment"># Example test case</span>
cost = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>]
print(minCostClimbingStairs(cost))  <span class="hljs-comment"># Output: 15</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the cost array.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using only two variables to store intermediate results.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There’s no fundamentally different approach. A recursive solution with memoization can also be used, but the time and space complexity would remain the same.</p>
<hr>
<h3 id="9-house-robber-medium">9. <strong>House Robber</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are a robber planning to rob houses along a street. Each house has a certain amount of money, but adjacent houses have security systems connected. If you rob two adjacent houses, the alarm will be triggered. The task is to maximize the amount of money you can rob without triggering the alarm.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [2, 7, 9, 3, 1]
Output: 12

Explanation:
- Rob house 1 (money = 2), skip house 2, rob house 3 (money = 9), skip house 4, and rob house 5 (money = 1).
- The total amount robbed is 2 + 9 + 1 = 12.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem is another example of <strong>Dynamic Programming</strong>. The key idea is that for each house <code>i</code>, you either rob that house and add its value to the total from <code>i-2</code> (since you cannot rob the adjacent house), or you skip it and take the maximum from <code>i-1</code>. Thus, the recurrence relation is: <code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Step 1: Initialize two base cases</span>
    prev1, prev2 = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]), nums[<span class="hljs-number">0</span>]  <span class="hljs-comment"># prev1 is max at step 1, prev2 is max at step 0</span>
    
    <span class="hljs-comment"># Step 2: Use a bottom-up approach to calculate the maximum amount of money that can be robbed</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums)):
        current = max(prev1, prev2 + nums[i])  <span class="hljs-comment"># Max value at house i is either robbing it or skipping it</span>
        prev2 = prev1  <span class="hljs-comment"># Shift prev2 to prev1 for the next iteration</span>
        prev1 = current  <span class="hljs-comment"># Move current result to prev1 for the next iteration</span>
    
    <span class="hljs-keyword">return</span> prev1

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]
print(rob(nums))  <span class="hljs-comment"># Output: 12</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the nums array.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using only two variables to store the intermediate results.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>A recursive solution with memoization can also be used to solve this problem, but it would have a similar time complexity of <code>O(n)</code> and a space complexity of <code>O(n)</code> due to the recursion stack.</p>
<hr>
<p>Let's continue with the next set of problems.</p>
<hr>
<h3 id="10-house-robber-ii-medium">10. <strong>House Robber II</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>This problem is a variation of the <strong>House Robber</strong> problem. Now, the houses are arranged in a circle, meaning the first and last houses are adjacent. The task is to maximize the amount of money you can rob without robbing two adjacent houses, taking the circular arrangement into account.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [2, 3, 2]
Output: 3

Explanation:
- You can either rob house 1 (money = 2) and house 3 (money = 2), or rob house 2 (money = 3). 
- The maximum money you can rob is 3.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong> similar to <strong>House Robber</strong>. However, because the first and last houses are adjacent, we need to consider two scenarios:</p>
<ol>
<li>Rob houses from the first house to the second last house.</li>
<li>Rob houses from the second house to the last house.
The solution is the maximum result from these two scenarios.</li>
</ol>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob_helper</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Helper function to perform the normal House Robber logic</span>
    <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
    
    prev1, prev2 = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]), nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(nums)):
        current = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = current
    
    <span class="hljs-keyword">return</span> prev1

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Step 1: Consider robbing houses from the first house to the second last house</span>
    case1 = rob_helper(nums[:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># Exclude the last house</span>
    
    <span class="hljs-comment"># Step 2: Consider robbing houses from the second house to the last house</span>
    case2 = rob_helper(nums[<span class="hljs-number">1</span>:])  <span class="hljs-comment"># Exclude the first house</span>
    
    <span class="hljs-comment"># Step 3: The maximum result is the answer</span>
    <span class="hljs-keyword">return</span> max(case1, case2)

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
print(rob(nums))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the nums array.</span>
<span class="hljs-comment"># We perform two runs of the House Robber algorithm (linear time).</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using only two variables to store intermediate results in the helper function.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly different alternative approach for this problem. We could solve this with recursion and memoization, but it would still be <code>O(n)</code> in time complexity and <code>O(n)</code> in space complexity due to the recursion stack.</p>
<hr>
<h3 id="11-longest-palindromic-substring-medium">11. <strong>Longest Palindromic Substring</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a string <code>s</code>, find the longest palindromic substring in <code>s</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;babad&quot;
Output: &quot;bab&quot;

Explanation:
- &quot;bab&quot; is a palindrome, and it is the longest palindromic substring in the input string.
- Note: &quot;aba&quot; is also a valid answer.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using the <strong>Expand Around Center</strong> approach. A palindrome mirrors around its center. To find all palindromes, we can expand around every possible center of the string (which can be between two characters or at a character itself).</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(s, left, right)</span>:</span>
        <span class="hljs-comment"># Expand around the given center and return the longest palindrome</span>
        <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right &lt; len(s) <span class="hljs-keyword">and</span> s[left] == s[right]:
            left -= <span class="hljs-number">1</span>
            right += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> s[left+<span class="hljs-number">1</span>:right]  <span class="hljs-comment"># Return the valid palindrome</span>
    
    longest = <span class="hljs-string">""</span>
    
    <span class="hljs-comment"># Step 1: Consider each character and each pair of characters as a center and expand around it</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
        <span class="hljs-comment"># Odd-length palindromes (centered at a single character)</span>
        odd_palindrome = expandAroundCenter(s, i, i)
        <span class="hljs-keyword">if</span> len(odd_palindrome) &gt; len(longest):
            longest = odd_palindrome
        
        <span class="hljs-comment"># Even-length palindromes (centered between two characters)</span>
        even_palindrome = expandAroundCenter(s, i, i + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> len(even_palindrome) &gt; len(longest):
            longest = even_palindrome
    
    <span class="hljs-keyword">return</span> longest

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"babad"</span>
print(longestPalindrome(s))  <span class="hljs-comment"># Output: "bab"</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2), where n is the length of the string.</span>
<span class="hljs-comment"># We expand around each possible center, and each expansion can take O(n) time.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are only using a few extra variables (constant space).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>A <strong>Dynamic Programming</strong> approach can also be used to solve this problem by keeping track of whether a substring is a palindrome. However, the time complexity remains <code>O(n^2)</code> due to the nested loops, and the space complexity is <code>O(n^2)</code> due to the DP table. The <strong>Expand Around Center</strong> approach is generally preferred for its simplicity.</p>
<hr>
<h3 id="12-palindromic-substrings-medium">12. <strong>Palindromic Substrings</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a string <code>s</code>, return the number of palindromic substrings in <code>s</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;aaa&quot;
Output: 6

Explanation:
The palindromic substrings are &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, and &quot;aaa&quot;.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can also be solved using the <strong>Expand Around Center</strong> approach. For each center in the string, we can expand outwards and count all valid palindromes.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(s, left, right)</span>:</span>
        count = <span class="hljs-number">0</span>
        <span class="hljs-comment"># Expand around the given center and count palindromes</span>
        <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right &lt; len(s) <span class="hljs-keyword">and</span> s[left] == s[right]:
            count += <span class="hljs-number">1</span>
            left -= <span class="hljs-number">1</span>
            right += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> count
    
    total_palindromes = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Consider each character and each pair of characters as a center and expand around it</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
        total_palindromes += expandAroundCenter(s, i, i)  <span class="hljs-comment"># Odd-length palindromes</span>
        total_palindromes += expandAroundCenter(s, i, i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># Even-length palindromes</span>
    
    <span class="hljs-keyword">return</span> total_palindromes

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"aaa"</span>
print(countSubstrings(s))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2), where n is the length of the string.</span>
<span class="hljs-comment"># We expand around each possible center, and each expansion can take O(n) time.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are only using a few extra variables (constant space).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>We can solve this problem using a <strong>Dynamic Programming</strong> approach, where we build a DP table that tracks whether a substring is a palindrome. This would also have <code>O(n^2)</code> time and space complexity, but the <strong>Expand Around Center</strong> approach is simpler.</p>
<hr>
<p>Let's continue with the next set of problems following the same detailed format.</p>
<hr>
<h3 id="13-decode-ways-medium">13. <strong>Decode Ways</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>A message containing letters from A-Z is encoded as follows:</p>
<ul>
<li>'A' -&gt; &quot;1&quot;</li>
<li>'B' -&gt; &quot;2&quot;</li>
<li>...</li>
<li>'Z' -&gt; &quot;26&quot;</li>
</ul>
<p>You are given a string <code>s</code> representing the encoded message. The task is to determine the total number of ways to decode it.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;226&quot;
Output: 3

Explanation:
The string &quot;226&quot; can be decoded as:
- &quot;B&quot; -&gt; &quot;2&quot; and &quot;B&quot; -&gt; &quot;2&quot; and &quot;F&quot; -&gt; &quot;6&quot; (i.e., &quot;BBF&quot;)
- &quot;B&quot; -&gt; &quot;2&quot; and &quot;V&quot; -&gt; &quot;26&quot; (i.e., &quot;BV&quot;)
- &quot;Z&quot; -&gt; &quot;22&quot; and &quot;6&quot; -&gt; &quot;6&quot; (i.e., &quot;ZZ&quot;)
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We keep track of the number of ways to decode the string up to each character. For each character, we check if it can be decoded as a single digit or a valid two-digit number.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>:  <span class="hljs-comment"># No valid decoding if the string starts with '0'</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Initialize dp array to store the number of ways to decode up to each index</span>
    n = len(s)
    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># Base case: an empty string has 1 way to be decoded</span>
    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] != <span class="hljs-string">'0'</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># The first character must not be '0' for a valid decoding</span>
    
    <span class="hljs-comment"># Step 2: Fill the dp array using the recursive relation</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):
        one_digit = int(s[i<span class="hljs-number">-1</span>:i])  <span class="hljs-comment"># Single digit number (last character)</span>
        two_digits = int(s[i<span class="hljs-number">-2</span>:i])  <span class="hljs-comment"># Two digit number (last two characters)</span>
        
        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &lt;= one_digit &lt;= <span class="hljs-number">9</span>:  <span class="hljs-comment"># If the single digit number is valid (1-9)</span>
            dp[i] += dp[i<span class="hljs-number">-1</span>]
        
        <span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt;= two_digits &lt;= <span class="hljs-number">26</span>:  <span class="hljs-comment"># If the two-digit number is valid (10-26)</span>
            dp[i] += dp[i<span class="hljs-number">-2</span>]
    
    <span class="hljs-keyword">return</span> dp[n]

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"226"</span>
print(numDecodings(s))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the input string.</span>
<span class="hljs-comment"># We process each character of the string exactly once.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use a dp array of size n + 1 to store the results.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be reduced to <code>O(1)</code> by using two variables to store only the last two results instead of the entire dp array. Here's the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    n = len(s)
    prev2, prev1 = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>  <span class="hljs-comment"># Base cases for dp[-2] and dp[-1]</span>
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
        current = <span class="hljs-number">0</span>
        one_digit = int(s[i:i+<span class="hljs-number">1</span>])
        two_digits = int(s[i<span class="hljs-number">-1</span>:i+<span class="hljs-number">1</span>])
        
        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &lt;= one_digit &lt;= <span class="hljs-number">9</span>:
            current += prev1
        
        <span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt;= two_digits &lt;= <span class="hljs-number">26</span>:
            current += prev2
        
        prev2, prev1 = prev1, current  <span class="hljs-comment"># Move the previous values forward</span>
    
    <span class="hljs-keyword">return</span> prev1
</div></code></pre>
<hr>
<h3 id="14-coin-change-medium">14. <strong>Coin Change</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an integer array <code>coins</code> representing different denominations of coins and an integer <code>amount</code> representing a total amount of money. The task is to find the fewest number of coins needed to make up that amount. If it's not possible to make the amount, return <code>-1</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: coins = [1, 2, 5], amount = 11
Output: 3

Explanation:
To make amount 11, we can use three coins: 5 + 5 + 1.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We need to find the minimum number of coins for every amount from <code>0</code> to <code>amount</code>. The recurrence relation is: <code>dp[i] = min(dp[i], dp[i - coin] + 1)</code> for every coin.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins, amount)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize dp array with an initial value higher than any possible number of coins</span>
    dp = [float(<span class="hljs-string">'inf'</span>)] * (amount + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Base case: it takes 0 coins to make amount 0</span>
    
    <span class="hljs-comment"># Step 2: Fill the dp array using the recursive relation</span>
    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(coin, amount + <span class="hljs-number">1</span>):
            dp[i] = min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>)  <span class="hljs-comment"># Take the minimum number of coins for amount i</span>
    
    <span class="hljs-comment"># Step 3: Return the result, if dp[amount] is still infinity, it means it's not possible to make the amount</span>
    <span class="hljs-keyword">return</span> dp[amount] <span class="hljs-keyword">if</span> dp[amount] != float(<span class="hljs-string">'inf'</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>

<span class="hljs-comment"># Example test case</span>
coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
amount = <span class="hljs-number">11</span>
print(coinChange(coins, amount))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n * m), where n is the amount and m is the number of coins.</span>
<span class="hljs-comment"># We fill the dp array of size n for each coin.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use a dp array of size amount + 1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different alternative approach for this problem that improves upon <strong>Dynamic Programming</strong>. We could use BFS to explore all possible combinations of coins, but it would have similar time complexity.</p>
<hr>
<h3 id="15-maximum-product-subarray-medium">15. <strong>Maximum Product Subarray</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest product.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [2, 3, -2, 4]
Output: 6

Explanation:
The subarray [2, 3] has the largest product 6.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong> with a twist. We need to keep track of both the maximum and minimum product at each position because multiplying a negative number by the minimum product can result in the maximum product.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Initialize the maximum and minimum products at the first position</span>
    max_prod = min_prod = result = nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Step 2: Traverse the array and update the maximum and minimum products at each step</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(nums)):
        <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># If the current number is negative, swap the max and min</span>
            max_prod, min_prod = min_prod, max_prod
        
        max_prod = max(nums[i], max_prod * nums[i])
        min_prod = min(nums[i], min_prod * nums[i])
        
        result = max(result, max_prod)
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">4</span>]
print(maxProduct(nums))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the input array.</span>
<span class="hljs-comment"># We iterate through the array once to calculate the maximum product.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using only a few variables to store the results.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly different approach that improves upon this <strong>Dynamic Programming</strong> solution. The space complexity is already optimized to <code>O(1)</code>.</p>
<hr>
<p>Let's continue with the next set of problems in the same detailed format.</p>
<hr>
<h3 id="16-word-break-medium">16. <strong>Word Break</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a string <code>s</code> and a dictionary of words <code>wordDict</code>. Determine if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words. The same word in the dictionary may be reused multiple times in the segmentation.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
Output: true

Explanation:
The string &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This is a classic <strong>Dynamic Programming</strong> problem. We use a <code>dp</code> array where <code>dp[i]</code> indicates whether the substring <code>s[0:i]</code> can be segmented using the dictionary. For each position <code>i</code>, we check all possible words in the dictionary and see if <code>dp[j]</code> is <code>True</code> for any valid prefix <code>s[0:j]</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s, wordDict)</span>:</span>
    <span class="hljs-comment"># Step 1: Convert the wordDict to a set for faster lookup</span>
    word_set = set(wordDict)
    
    <span class="hljs-comment"># Step 2: Initialize a dp array where dp[i] indicates whether s[0:i] can be segmented</span>
    dp = [<span class="hljs-literal">False</span>] * (len(s) + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Base case: an empty string can always be segmented</span>
    
    <span class="hljs-comment"># Step 3: Fill the dp array by checking each substring s[j:i]</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):
            <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> word_set:
                dp[i] = <span class="hljs-literal">True</span>
                <span class="hljs-keyword">break</span>
    
    <span class="hljs-keyword">return</span> dp[len(s)]  <span class="hljs-comment"># The result is whether the entire string can be segmented</span>

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"leetcode"</span>
wordDict = [<span class="hljs-string">"leet"</span>, <span class="hljs-string">"code"</span>]
print(wordBreak(s, wordDict))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2), where n is the length of the input string.</span>
<span class="hljs-comment"># We check every substring s[j:i] for each index i, and checking whether a word exists in the dictionary takes O(1) with a set.</span>

<span class="hljs-comment"># Space Complexity: O(n), where n is the length of the input string.</span>
<span class="hljs-comment"># We use a dp array of size n+1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly different alternative approach for this problem that improves upon <strong>Dynamic Programming</strong>. We could use recursion with memoization to achieve the same result.</p>
<hr>
<h3 id="17-longest-increasing-subsequence-medium">17. <strong>Longest Increasing Subsequence</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]
Output: 4

Explanation:
The longest increasing subsequence is [2, 3, 7, 101], so the length is 4.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We maintain a <code>dp</code> array where <code>dp[i]</code> represents the length of the longest increasing subsequence ending at index <code>i</code>. For each index <code>i</code>, we check all previous indices <code>j &lt; i</code> and update <code>dp[i]</code> based on whether <code>nums[i] &gt; nums[j]</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Initialize dp array where dp[i] represents the LIS ending at index i</span>
    dp = [<span class="hljs-number">1</span>] * len(nums)  <span class="hljs-comment"># Every element is its own subsequence of length 1</span>
    
    <span class="hljs-comment"># Step 2: Fill the dp array by checking previous elements for each i</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(nums)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):
            <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:
                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)
    
    <span class="hljs-keyword">return</span> max(dp)  <span class="hljs-comment"># The answer is the maximum value in dp</span>

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>]
print(lengthOfLIS(nums))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2), where n is the length of the input array.</span>
<span class="hljs-comment"># We compare every pair of indices i and j.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use a dp array of size n to store the results.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>A more optimized approach involves using <strong>Binary Search</strong> and a greedy algorithm. Instead of maintaining a <code>dp</code> array, we use a list to keep track of the smallest possible ending values of increasing subsequences of various lengths. The time complexity for this approach is <code>O(n log n)</code>.</p>
<p>Here’s the optimized solution:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> bisect

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Use a list to keep track of the smallest possible ending values</span>
    lis = []
    
    <span class="hljs-comment"># Step 2: Traverse the array and maintain the lis using binary search</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        pos = bisect.bisect_left(lis, num)
        <span class="hljs-keyword">if</span> pos &lt; len(lis):
            lis[pos] = num  <span class="hljs-comment"># Replace the current value with the new one</span>
        <span class="hljs-keyword">else</span>:
            lis.append(num)  <span class="hljs-comment"># Extend the lis with the new number</span>
    
    <span class="hljs-keyword">return</span> len(lis)

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>]
print(lengthOfLIS(nums))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<hr>
<h3 id="18-partition-equal-subset-sum-medium">18. <strong>Partition Equal Subset Sum</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a non-empty array <code>nums</code> containing positive integers, determine if you can partition the array into two subsets such that the sum of elements in both subsets is equal.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [1, 5, 11, 5]
Output: true

Explanation:
The array can be partitioned as [1, 5, 5] and [11].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This is another classic <strong>Dynamic Programming</strong> problem. It’s equivalent to the subset sum problem. We want to find if there exists a subset whose sum equals <code>total_sum / 2</code>, where <code>total_sum</code> is the sum of all elements in the array. If <code>total_sum</code> is odd, it's impossible to partition the array, so we return <code>False</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums)</span>:</span>
    total_sum = sum(nums)
    
    <span class="hljs-comment"># Step 1: If the total sum is odd, it's impossible to partition it into two equal subsets</span>
    <span class="hljs-keyword">if</span> total_sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    target = total_sum // <span class="hljs-number">2</span>
    
    <span class="hljs-comment"># Step 2: Initialize a dp array where dp[i] indicates whether we can achieve sum i</span>
    dp = [<span class="hljs-literal">False</span>] * (target + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Base case: we can always form the sum 0 by choosing no elements</span>
    
    <span class="hljs-comment"># Step 3: For each number in nums, update the dp array</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        <span class="hljs-comment"># Traverse the dp array backwards to avoid overwriting results for the current iteration</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(target, num - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>):
            dp[i] = dp[i] <span class="hljs-keyword">or</span> dp[i - num]
    
    <span class="hljs-keyword">return</span> dp[target]

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]
print(canPartition(nums))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n * target), where n is the number of elements and target is the sum of half the total array.</span>

<span class="hljs-comment"># Space Complexity: O(target), because we use a dp array of size target + 1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach, but you could use recursion with memoization to solve this problem. However, it would have a similar time complexity of <code>O(n * target)</code>.</p>
<hr>
<h2 id="2-d-dynamic-programming">2-D Dynamic Programming</h2>
<h3 id="1-unique-paths-medium">1. <strong>Unique Paths</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an <code>m x n</code> grid, and you are a robot located at the top-left corner. Your goal is to reach the bottom-right corner. You can only move either down or right. The task is to find how many unique paths there are from the top-left corner to the bottom-right corner.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: m = 3, n = 7
Output: 28

Explanation:
There are 28 unique paths from the top-left to the bottom-right in a 3x7 grid.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We maintain a 2D <code>dp</code> array where <code>dp[i][j]</code> represents the number of unique paths to reach the cell <code>(i, j)</code> from the top-left corner. The recurrence relation is:</p>
<pre class="hljs"><code><div>dp[i][j] = dp[i-1][j] + dp[i][j-1]
</div></code></pre>
<p>since you can either come from the top or from the left.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m, n)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize a 2D dp array with all elements set to 1</span>
    dp = [[<span class="hljs-number">1</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]
    
    <span class="hljs-comment"># Step 2: Fill the dp array using the recurrence relation</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]
    
    <span class="hljs-comment"># Step 3: The bottom-right corner contains the total number of unique paths</span>
    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]

<span class="hljs-comment"># Example test case</span>
m = <span class="hljs-number">3</span>
n = <span class="hljs-number">7</span>
print(uniquePaths(m, n))  <span class="hljs-comment"># Output: 28</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), because we fill a 2D array of size m * n.</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the number of unique paths for each cell.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>A more optimized solution involves reducing the space complexity to <code>O(n)</code> by only maintaining the current and previous row in a 1D array, as we only need the previous row to compute the current one.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m, n)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize a 1D dp array with all elements set to 1</span>
    dp = [<span class="hljs-number">1</span>] * n
    
    <span class="hljs-comment"># Step 2: Update the dp array for each row</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
            dp[j] += dp[j<span class="hljs-number">-1</span>]  <span class="hljs-comment"># Add the value from the left to the current cell</span>
    
    <span class="hljs-comment"># Step 3: The last element contains the total number of unique paths</span>
    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]

<span class="hljs-comment"># Example test case</span>
m = <span class="hljs-number">3</span>
n = <span class="hljs-number">7</span>
print(uniquePaths(m, n))  <span class="hljs-comment"># Output: 28</span>
</div></code></pre>
<hr>
<h3 id="2-longest-common-subsequence-medium">2. <strong>Longest Common Subsequence</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order but not necessarily contiguously.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;
Output: 3

Explanation:
The longest common subsequence is &quot;ace&quot; with length 3.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We maintain a 2D <code>dp</code> array where <code>dp[i][j]</code> represents the length of the longest common subsequence of <code>text1[0:i]</code> and <code>text2[0:j]</code>. The recurrence relation is:</p>
<pre class="hljs"><code><div>if text1[i-1] == text2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
</div></code></pre>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1, text2)</span>:</span>
    m, n = len(text1), len(text2)
    
    <span class="hljs-comment"># Step 1: Initialize a 2D dp array with dimensions (m+1) x (n+1)</span>
    dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>)]
    
    <span class="hljs-comment"># Step 2: Fill the dp array using the recurrence relation</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:
                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])
    
    <span class="hljs-comment"># Step 3: The bottom-right corner contains the length of the LCS</span>
    <span class="hljs-keyword">return</span> dp[m][n]

<span class="hljs-comment"># Example test case</span>
text1 = <span class="hljs-string">"abcde"</span>
text2 = <span class="hljs-string">"ace"</span>
print(longestCommonSubsequence(text1, text2))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the length of text1 and n is the length of text2.</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the LCS for each substring.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be reduced to <code>O(min(m, n))</code> by only maintaining the current and previous row in a 1D array, as we only need the values from the previous row to compute the current row.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1, text2)</span>:</span>
    <span class="hljs-keyword">if</span> len(text1) &lt; len(text2):
        text1, text2 = text2, text1  <span class="hljs-comment"># Ensure text1 is the longer string</span>
    
    previous = [<span class="hljs-number">0</span>] * (len(text2) + <span class="hljs-number">1</span>)
    
    <span class="hljs-comment"># Step 1: Update the dp array row by row</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(text1) + <span class="hljs-number">1</span>):
        current = [<span class="hljs-number">0</span>] * (len(text2) + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(text2) + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:
                current[j] = previous[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                current[j] = max(previous[j], current[j - <span class="hljs-number">1</span>])
        previous = current
    
    <span class="hljs-keyword">return</span> previous[len(text2)]

<span class="hljs-comment"># Example test case</span>
text1 = <span class="hljs-string">"abcde"</span>
text2 = <span class="hljs-string">"ace"</span>
print(longestCommonSubsequence(text1, text2))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<hr>
<p>Let's continue with the next set of problems from the <strong>2-D Dynamic Programming</strong> section.</p>
<hr>
<h3 id="3-best-time-to-buy-and-sell-stock-with-cooldown-medium">3. <strong>Best Time to Buy and Sell Stock with Cooldown</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an array where each element represents the price of a stock on a given day. You can buy and sell the stock multiple times, but after you sell the stock, you cannot buy again for one day (cooldown). The task is to maximize your profit.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: prices = [1, 2, 3, 0, 2]
Output: 3

Explanation:
- Buy on day 0 (price = 1), sell on day 2 (price = 3), cooldown on day 3, and buy on day 4, then sell on day 4 (price = 2).
- Total profit = (3 - 1) + (2 - 0) = 3.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We define three states:</p>
<ol>
<li><code>hold[i]</code>: the maximum profit on day <code>i</code> if we hold a stock.</li>
<li><code>sold[i]</code>: the maximum profit on day <code>i</code> if we just sold a stock.</li>
<li><code>rest[i]</code>: the maximum profit on day <code>i</code> if we are in cooldown.</li>
</ol>
<p>The recurrence relations are:</p>
<pre class="hljs"><code><div>hold[i] = max(hold[i-1], rest[i-1] - prices[i])  # Either keep holding or buy a new stock
sold[i] = hold[i-1] + prices[i]  # Sell the stock we were holding
rest[i] = max(rest[i-1], sold[i-1])  # Either stay in cooldown or just sold the previous day
</div></code></pre>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    n = len(prices)
    
    <span class="hljs-comment"># Step 1: Initialize the states</span>
    hold = [<span class="hljs-number">0</span>] * n
    sold = [<span class="hljs-number">0</span>] * n
    rest = [<span class="hljs-number">0</span>] * n
    
    hold[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]  <span class="hljs-comment"># On day 0, the only option is to buy the stock</span>
    
    <span class="hljs-comment"># Step 2: Fill the dp arrays using the recurrence relations</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
        hold[i] = max(hold[i<span class="hljs-number">-1</span>], rest[i<span class="hljs-number">-1</span>] - prices[i])
        sold[i] = hold[i<span class="hljs-number">-1</span>] + prices[i]
        rest[i] = max(rest[i<span class="hljs-number">-1</span>], sold[i<span class="hljs-number">-1</span>])
    
    <span class="hljs-comment"># Step 3: The maximum profit will be the maximum of either selling or resting on the last day</span>
    <span class="hljs-keyword">return</span> max(sold[<span class="hljs-number">-1</span>], rest[<span class="hljs-number">-1</span>])

<span class="hljs-comment"># Example test case</span>
prices = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]
print(maxProfit(prices))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of days (length of prices).</span>
<span class="hljs-comment"># We iterate through the prices array once.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use three arrays of size n to store the states.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be reduced to <code>O(1)</code> by using only variables to store the current and previous states instead of entire arrays.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    hold = -prices[<span class="hljs-number">0</span>]
    sold = <span class="hljs-number">0</span>
    rest = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Iterate over the prices and update the states</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(prices)):
        prev_hold, prev_sold, prev_rest = hold, sold, rest
        hold = max(prev_hold, prev_rest - prices[i])
        sold = prev_hold + prices[i]
        rest = max(prev_rest, prev_sold)
    
    <span class="hljs-keyword">return</span> max(sold, rest)

<span class="hljs-comment"># Example test case</span>
prices = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]
print(maxProfit(prices))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<hr>
<h3 id="4-coin-change-ii-medium">4. <strong>Coin Change II</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an integer array <code>coins</code> representing different denominations of coins and an integer <code>amount</code> representing a total amount of money. The task is to count the number of different ways to make up the amount using the available coins. The order of coins does not matter.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: amount = 5, coins = [1, 2, 5]
Output: 4

Explanation:
There are 4 ways to make the amount 5:
1. 5
2. 2 + 2 + 1
3. 2 + 1 + 1 + 1
4. 1 + 1 + 1 + 1 + 1
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem is solved using <strong>Dynamic Programming</strong> similar to the &quot;Knapsack Problem&quot;. We use a <code>dp</code> array where <code>dp[i]</code> represents the number of ways to make the amount <code>i</code>. For each coin, we iterate through all possible amounts and update the number of ways to form the amount using that coin.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span><span class="hljs-params">(amount, coins)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize a dp array of size amount+1 with dp[0] = 1</span>
    dp = [<span class="hljs-number">0</span>] * (amount + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># There is one way to make amount 0, by using no coins</span>
    
    <span class="hljs-comment"># Step 2: Iterate over each coin and update the dp array</span>
    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(coin, amount + <span class="hljs-number">1</span>):
            dp[i] += dp[i - coin]  <span class="hljs-comment"># Update the number of ways to form amount i</span>
    
    <span class="hljs-keyword">return</span> dp[amount]

<span class="hljs-comment"># Example test case</span>
amount = <span class="hljs-number">5</span>
coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
print(change(amount, coins))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n * m), where n is the amount and m is the number of coins.</span>
<span class="hljs-comment"># We iterate through the dp array for each coin.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use a dp array of size amount+1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach. This dynamic programming method efficiently solves the problem in linear space and time complexity.</p>
<hr>
<h3 id="5-target-sum-medium">5. <strong>Target Sum</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an integer array <code>nums</code> and an integer <code>S</code>. Each element in the array can either be assigned a positive or negative sign. The task is to find the number of ways to assign the signs such that the sum of the elements is equal to <code>S</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [1, 1, 1, 1, 1], S = 3
Output: 5

Explanation:
There are 5 ways to assign signs to make the sum equal to 3:
1. +1 -1 +1 +1 +1
2. -1 +1 +1 +1 +1
3. +1 +1 -1 +1 +1
4. +1 +1 +1 -1 +1
5. +1 +1 +1 +1 -1
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be transformed into a <strong>Subset Sum</strong> problem. The key idea is to partition the array into two subsets where the difference between their sums equals <code>S</code>. We use <strong>Dynamic Programming</strong> to solve this.</p>
<p>The problem becomes finding subsets with sum <code>(sum(nums) + S) // 2</code>. If this value is not an integer or if <code>sum(nums) + S</code> is odd, there is no solution.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums, S)</span>:</span>
    total_sum = sum(nums)
    
    <span class="hljs-comment"># Step 1: If the sum of nums + S is odd or if S &gt; total_sum, return 0</span>
    <span class="hljs-keyword">if</span> total_sum &lt; S <span class="hljs-keyword">or</span> (total_sum + S) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    target = (total_sum + S) // <span class="hljs-number">2</span>
    
    <span class="hljs-comment"># Step 2: Initialize a dp array where dp[i] represents the number of ways to form sum i</span>
    dp = [<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># There is one way to form sum 0, by using no elements</span>
    
    <span class="hljs-comment"># Step 3: Iterate over nums and update the dp array</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(target, num - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>):
            dp[i] += dp[i - num]
    
    <span class="hljs-keyword">return</span> dp[target]

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
S = <span class="hljs-number">3</span>
print(findTargetSumWays(nums, S))  <span class="hljs-comment"># Output: 5</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n * target), where n is the number of elements and target is the new target sum.</span>

<span class="hljs-comment"># Space Complexity: O(target), because we use a dp array of size target+1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach, though recursion with memoization could be used. However, this dynamic programming approach is more efficient for this type of problem.</p>
<hr>
<p>Let's continue with the next set of problems from the <strong>2-D Dynamic Programming</strong> section.</p>
<hr>
<h3 id="6-interleaving-string-medium">6. <strong>Interleaving String</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given three strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, determine if <code>s3</code> is formed by an interleaving of <code>s1</code> and <code>s2</code>. An interleaving of two strings maintains the order of the characters from each string but mixes them together.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true

Explanation:
&quot;s3&quot; can be formed by interleaving &quot;aabcc&quot; and &quot;dbbca&quot;.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We define a 2D <code>dp</code> array where <code>dp[i][j]</code> indicates whether <code>s3[0:i+j]</code> can be formed by interleaving <code>s1[0:i]</code> and <code>s2[0:j]</code>. The recurrence relation is:</p>
<pre class="hljs"><code><div>dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
</div></code></pre>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(s1, s2, s3)</span>:</span>
    <span class="hljs-keyword">if</span> len(s1) + len(s2) != len(s3):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># Step 1: Initialize a 2D dp array where dp[i][j] means s3[0:i+j] can be formed</span>
    dp = [[<span class="hljs-literal">False</span>] * (len(s2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(s1) + <span class="hljs-number">1</span>)]
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Base case: an empty s1 and s2 can form an empty s3</span>
    
    <span class="hljs-comment"># Step 2: Fill the dp array</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s1) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s2) + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span>:
                dp[i][j] = dp[i][j] <span class="hljs-keyword">or</span> (dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-keyword">and</span> s1[i<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>])
            <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span>:
                dp[i][j] = dp[i][j] <span class="hljs-keyword">or</span> (dp[i][j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> s2[j<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>])
    
    <span class="hljs-keyword">return</span> dp[len(s1)][len(s2)]

<span class="hljs-comment"># Example test case</span>
s1 = <span class="hljs-string">"aabcc"</span>
s2 = <span class="hljs-string">"dbbca"</span>
s3 = <span class="hljs-string">"aadbbcbcac"</span>
print(isInterleave(s1, s2, s3))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the length of s1 and n is the length of s2.</span>
<span class="hljs-comment"># We fill a 2D array of size (m+1) x (n+1).</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the results for each substring combination.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be optimized to <code>O(n)</code> by only maintaining the current and previous rows of the <code>dp</code> array, as we only need the previous row to compute the current one.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(s1, s2, s3)</span>:</span>
    <span class="hljs-keyword">if</span> len(s1) + len(s2) != len(s3):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    dp = [<span class="hljs-literal">False</span>] * (len(s2) + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>
    
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s2) + <span class="hljs-number">1</span>):
        dp[j] = dp[j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> s2[j<span class="hljs-number">-1</span>] == s3[j<span class="hljs-number">-1</span>]
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s1) + <span class="hljs-number">1</span>):
        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> s1[i<span class="hljs-number">-1</span>] == s3[i<span class="hljs-number">-1</span>]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s2) + <span class="hljs-number">1</span>):
            dp[j] = (dp[j] <span class="hljs-keyword">and</span> s1[i<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> (dp[j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> s2[j<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>])
    
    <span class="hljs-keyword">return</span> dp[len(s2)]

<span class="hljs-comment"># Example test case</span>
s1 = <span class="hljs-string">"aabcc"</span>
s2 = <span class="hljs-string">"dbbca"</span>
s3 = <span class="hljs-string">"aadbbcbcac"</span>
print(isInterleave(s1, s2, s3))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<hr>
<h3 id="7-longest-increasing-path-in-a-matrix-hard">7. <strong>Longest Increasing Path in a Matrix</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an <code>m x n</code> matrix of integers, return the length of the longest increasing path in the matrix. You can move in four directions: up, down, left, or right, and you may not move diagonally or outside the boundary of the matrix.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: matrix = [
  [9, 9, 4],
  [6, 6, 8],
  [2, 1, 1]
]
Output: 4

Explanation:
The longest increasing path is [1, 2, 6, 9].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong> with <strong>DFS</strong> and memoization. For each cell, we explore all four possible directions and compute the longest increasing path starting from that cell. We use memoization to avoid redundant computations.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(matrix)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    m, n = len(matrix), len(matrix[<span class="hljs-number">0</span>])
    memo = [[<span class="hljs-number">-1</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(i, j)</span>:</span>
        <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">-1</span>:
            <span class="hljs-keyword">return</span> memo[i][j]
        
        directions = [(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)]
        max_path = <span class="hljs-number">1</span>
        
        <span class="hljs-keyword">for</span> di, dj <span class="hljs-keyword">in</span> directions:
            ni, nj = i + di, j + dj
            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= ni &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= nj &lt; n <span class="hljs-keyword">and</span> matrix[ni][nj] &gt; matrix[i][j]:
                max_path = max(max_path, <span class="hljs-number">1</span> + dfs(ni, nj))
        
        memo[i][j] = max_path
        <span class="hljs-keyword">return</span> max_path
    
    <span class="hljs-keyword">return</span> max(dfs(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n))

<span class="hljs-comment"># Example test case</span>
matrix = [
  [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>],
  [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
]
print(longestIncreasingPath(matrix))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the number of rows and n is the number of columns.</span>
<span class="hljs-comment"># Each cell is visited only once due to memoization.</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a memo array to store the results of each cell.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly different alternative approach that would improve the time complexity, as DFS with memoization is already optimal for this type of problem.</p>
<hr>
<h3 id="8-distinct-subsequences-hard">8. <strong>Distinct Subsequences</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given two strings <code>s</code> and <code>t</code>, return the number of distinct subsequences of <code>s</code> that equal <code>t</code>. A subsequence is a sequence derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;
Output: 3

Explanation:
There are 3 distinct ways to form &quot;rabbit&quot; from &quot;rabbbit&quot;:
1. &quot;rabbbit&quot; → remove the first 'b'
2. &quot;rabbbit&quot; → remove the second 'b'
3. &quot;rabbbit&quot; → remove the third 'b'
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We define a 2D <code>dp</code> array where <code>dp[i][j]</code> represents the number of distinct subsequences of <code>s[0:i]</code> that match <code>t[0:j]</code>. The recurrence relation is:</p>
<pre class="hljs"><code><div>dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]
else dp[i][j] = dp[i-1][j]
</div></code></pre>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s, t)</span>:</span>
    m, n = len(s), len(t)
    
    <span class="hljs-comment"># Step 1: Initialize a dp array of size (m+1) x (n+1)</span>
    dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>)]
    
    <span class="hljs-comment"># Step 2: If t is an empty string, there is exactly one subsequence that matches (the empty subsequence)</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>):
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Step 3: Fill the dp array</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]:
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                dp[i][j] = dp[i

 - <span class="hljs-number">1</span>][j]
    
    <span class="hljs-keyword">return</span> dp[m][n]

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"rabbbit"</span>
t = <span class="hljs-string">"rabbit"</span>
print(numDistinct(s, t))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the length of s and n is the length of t.</span>
<span class="hljs-comment"># We fill a 2D dp array of size (m+1) x (n+1).</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the number of distinct subsequences.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be optimized to <code>O(n)</code> by only maintaining the current and previous rows of the <code>dp</code> array.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s, t)</span>:</span>
    m, n = len(s), len(t)
    
    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># Base case: an empty t can be formed by an empty s</span>
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        prev = dp[:]  <span class="hljs-comment"># Make a copy of the previous dp state</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]:
                dp[j] = prev[j] + prev[j - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                dp[j] = prev[j]
    
    <span class="hljs-keyword">return</span> dp[n]

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"rabbbit"</span>
t = <span class="hljs-string">"rabbit"</span>
print(numDistinct(s, t))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<hr>
<p>Let's continue with the next set of problems from the <strong>2-D Dynamic Programming</strong> section.</p>
<hr>
<h3 id="9-edit-distance-medium">9. <strong>Edit Distance</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of operations required to convert <code>word1</code> to <code>word2</code>. You have three operations available:</p>
<ol>
<li>Insert a character.</li>
<li>Delete a character.</li>
<li>Replace a character.</li>
</ol>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3

Explanation:
- Replace 'h' with 'r'
- Remove 'o'
- Remove 'e'
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We define a 2D <code>dp</code> array where <code>dp[i][j]</code> represents the minimum number of operations required to convert <code>word1[0:i]</code> to <code>word2[0:j]</code>. The recurrence relation is:</p>
<pre class="hljs"><code><div>if word1[i-1] == word2[j-1]:
    dp[i][j] = dp[i-1][j-1]
else:
    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
</div></code></pre>
<p>This relation covers three cases:</p>
<ul>
<li><code>dp[i-1][j]</code> → delete from <code>word1</code>.</li>
<li><code>dp[i][j-1]</code> → insert into <code>word1</code>.</li>
<li><code>dp[i-1][j-1]</code> → replace in <code>word1</code>.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1, word2)</span>:</span>
    m, n = len(word1), len(word2)
    
    <span class="hljs-comment"># Step 1: Initialize a dp array with dimensions (m+1) x (n+1)</span>
    dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>)]
    
    <span class="hljs-comment"># Step 2: Fill the base cases for transforming an empty string to any string</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        dp[i][<span class="hljs-number">0</span>] = i
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        dp[<span class="hljs-number">0</span>][j] = j
    
    <span class="hljs-comment"># Step 3: Fill the dp array using the recurrence relation</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]:
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                dp[i][j] = <span class="hljs-number">1</span> + min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">return</span> dp[m][n]

<span class="hljs-comment"># Example test case</span>
word1 = <span class="hljs-string">"horse"</span>
word2 = <span class="hljs-string">"ros"</span>
print(minDistance(word1, word2))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the length of word1 and n is the length of word2.</span>
<span class="hljs-comment"># We fill a 2D array of size (m+1) x (n+1).</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the minimum operations for each substring.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The space complexity can be optimized to <code>O(n)</code> by only maintaining the current and previous rows of the <code>dp</code> array, as we only need the previous row to compute the current row.</p>
<p>Here’s the space-optimized approach:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1, word2)</span>:</span>
    m, n = len(word1), len(word2)
    
    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    
    <span class="hljs-comment"># Step 1: Initialize the base case</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        dp[j] = j
    
    <span class="hljs-comment"># Step 2: Fill the dp array row by row</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        prev = dp[:]  <span class="hljs-comment"># Copy the current dp state</span>
        dp[<span class="hljs-number">0</span>] = i  <span class="hljs-comment"># Base case: transforming from word1[0:i] to an empty string</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]:
                dp[j] = prev[j - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                dp[j] = <span class="hljs-number">1</span> + min(prev[j], dp[j - <span class="hljs-number">1</span>], prev[j - <span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">return</span> dp[n]

<span class="hljs-comment"># Example test case</span>
word1 = <span class="hljs-string">"horse"</span>
word2 = <span class="hljs-string">"ros"</span>
print(minDistance(word1, word2))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<hr>
<h3 id="10-burst-balloons-hard">10. <strong>Burst Balloons</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given <code>n</code> balloons, indexed from 0 to <code>n - 1</code>. Each balloon has a number printed on it. You are asked to burst all the balloons. If you burst the <code>i</code>-th balloon, you will get <code>nums[left] * nums[i] * nums[right]</code> coins. The left and right neighbors are considered for the next steps. Your task is to find the maximum number of coins you can collect by bursting the balloons wisely.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [3, 1, 5, 8]
Output: 167

Explanation:
By bursting balloons in the order of [1, 5, 8, 3], you get the maximum coins.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong> with a bottom-up approach. We define <code>dp[left][right]</code> as the maximum coins we can get by bursting balloons between <code>left</code> and <code>right</code>. The idea is to consider each balloon <code>k</code> between <code>left</code> and <code>right</code> as the last balloon to burst in that range and compute the coins from bursting it.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Step 1: Add virtual balloons with value 1 at both ends</span>
    nums = [<span class="hljs-number">1</span>] + nums + [<span class="hljs-number">1</span>]
    n = len(nums)
    
    <span class="hljs-comment"># Step 2: Initialize the dp array</span>
    dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]
    
    <span class="hljs-comment"># Step 3: Fill the dp array using a bottom-up approach</span>
    <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n):  <span class="hljs-comment"># length is the distance between left and right boundaries</span>
        <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n - length):
            right = left + length
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(left + <span class="hljs-number">1</span>, right):
                dp[left][right] = max(dp[left][right], dp[left][k] + dp[k][right] + nums[left] * nums[k] * nums[right])
    
    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>]

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]
print(maxCoins(nums))  <span class="hljs-comment"># Output: 167</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^3), where n is the length of the nums array.</span>
<span class="hljs-comment"># We fill a 2D array and for each subproblem, we iterate through all possible middle points.</span>

<span class="hljs-comment"># Space Complexity: O(n^2), because we use a 2D array to store the maximum coins for each subarray.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly different alternative approach. Dynamic Programming is the optimal solution for this problem due to its overlapping subproblems and optimal substructure properties.</p>
<hr>
<h3 id="11-regular-expression-matching-hard">11. <strong>Regular Expression Matching</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>.</code> and <code>*</code>.</p>
<ul>
<li><code>.</code> matches any single character.</li>
<li><code>*</code> matches zero or more of the preceding element.</li>
</ul>
<p>The matching should cover the entire input string, not partial matches.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;aab&quot;, p = &quot;c*a*b&quot;
Output: true

Explanation:
The pattern &quot;c*a*b&quot; can match &quot;aab&quot; because &quot;c*&quot; can be ignored, &quot;a*&quot; matches &quot;aa&quot;, and &quot;b&quot; matches &quot;b&quot;.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Dynamic Programming</strong>. We define a 2D <code>dp</code> array where <code>dp[i][j]</code> indicates whether <code>s[0:i]</code> matches <code>p[0:j]</code>. The key cases are:</p>
<ul>
<li>If <code>p[j-1] == s[i-1]</code> or <code>p[j-1] == '.'</code>, then <code>dp[i][j] = dp[i-1][j-1]</code>.</li>
<li>If <code>p[j-1] == '*'</code>, we have two options:
<ul>
<li>If <code>p[j-2]</code> is ignored: <code>dp[i][j] = dp[i][j-2]</code>.</li>
<li>If <code>p[j-2] == s[i-1]</code> or <code>p[j-2] == '.'</code>, then <code>dp[i][j] = dp[i-1][j]</code>.</li>
</ul>
</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s, p)</span>:</span>
    m, n = len(s), len(p)
    
    <span class="hljs-comment"># Step 1: Initialize the dp array with dimensions (m+1) x (n+1)</span>
    dp = [[<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>)]
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># Empty string matches an empty pattern</span>
    
    <span class="hljs-comment"># Step 2: Handle patterns with '*' at the start (they can match an empty string)</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> p

[j - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>:
            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>]
    
    <span class="hljs-comment"># Step 3: Fill the dp array</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span> <span class="hljs-keyword">or</span> p[j - <span class="hljs-number">1</span>] == s[i - <span class="hljs-number">1</span>]:
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]
            <span class="hljs-keyword">elif</span> p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>:
                dp[i][j] = dp[i][j - <span class="hljs-number">2</span>]  <span class="hljs-comment"># '*' matches zero occurrences</span>
                <span class="hljs-keyword">if</span> p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">'.'</span> <span class="hljs-keyword">or</span> p[j - <span class="hljs-number">2</span>] == s[i - <span class="hljs-number">1</span>]:
                    dp[i][j] = dp[i][j] <span class="hljs-keyword">or</span> dp[i - <span class="hljs-number">1</span>][j]  <span class="hljs-comment"># '*' matches one or more occurrences</span>
    
    <span class="hljs-keyword">return</span> dp[m][n]

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"aab"</span>
p = <span class="hljs-string">"c*a*b"</span>
print(isMatch(s, p))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the length of s and n is the length of p.</span>
<span class="hljs-comment"># We fill a 2D array of size (m+1) x (n+1).</span>

<span class="hljs-comment"># Space Complexity: O(m * n), because we use a 2D array to store the match results for each substring combination.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach. The <strong>Dynamic Programming</strong> method is the optimal solution for this problem.</p>
<hr>
<p>Let's now move on to the <strong>Greedy</strong> section, continuing from the first problem listed.</p>
<hr>
<h3 id="1-maximum-subarray-medium">1. <strong>Maximum Subarray</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) that has the largest sum and return its sum.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6

Explanation:
The subarray [4,-1,2,1] has the largest sum = 6.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Greedy</strong> and <strong>Kadane’s Algorithm</strong>. We maintain a running sum and reset it to 0 if it becomes negative. At each step, we update the maximum sum.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize variables for the current sum and maximum sum</span>
    current_sum = max_sum = nums[<span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Step 2: Iterate through the array</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums[<span class="hljs-number">1</span>:]:
        current_sum = max(num, current_sum + num)  <span class="hljs-comment"># Either extend the current subarray or start a new one</span>
        max_sum = max(max_sum, current_sum)  <span class="hljs-comment"># Update the maximum sum</span>
    
    <span class="hljs-keyword">return</span> max_sum

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]
print(maxSubArray(nums))  <span class="hljs-comment"># Output: 6</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the input array.</span>
<span class="hljs-comment"># We traverse the array once.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few variables to keep track of the current and maximum sum.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This problem is most optimally solved using <strong>Kadane’s Algorithm</strong>, which is already <code>O(n)</code> in time complexity and <code>O(1)</code> in space complexity. There is no more efficient approach.</p>
<hr>
<h3 id="2-jump-game-medium">2. <strong>Jump Game</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of non-negative integers <code>nums</code>, where each element represents your maximum jump length at that position, determine if you are able to reach the last index.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [2,3,1,1,4]
Output: true

Explanation:
Start at index 0. You can jump 1 step to index 1, then 3 steps to the last index.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Greedy</strong>. We maintain a variable <code>farthest</code> to track the farthest index we can reach. As we iterate through the array, we update <code>farthest</code> based on the current index and the maximum jump possible from that index.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums)</span>:</span>
    farthest = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Iterate through the array and update the farthest index we can reach</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
        <span class="hljs-keyword">if</span> i &gt; farthest:  <span class="hljs-comment"># If we can't reach index i, return False</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        farthest = max(farthest, i + nums[i])  <span class="hljs-comment"># Update the farthest index we can reach</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># If we complete the loop, it means we can reach the last index</span>

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]
print(canJump(nums))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the input array.</span>
<span class="hljs-comment"># We traverse the array once to check if we can reach the last index.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few variables to track the farthest index.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach that improves upon this greedy solution. It is already optimal in terms of time and space complexity.</p>
<hr>
<h3 id="3-jump-game-ii-medium">3. <strong>Jump Game II</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of non-negative integers <code>nums</code>, where each element represents your maximum jump length at that position, return the minimum number of jumps needed to reach the last index.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [2,3,1,1,4]
Output: 2

Explanation:
The minimum number of jumps is 2. Jump 1 step from index 0 to index 1, then 3 steps to the last index.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can also be solved using <strong>Greedy</strong>. We maintain a <code>farthest</code> variable to track how far we can reach, and a <code>jumps</code> counter to count how many jumps we need. Whenever we reach the end of the current range, we increase the jump count and update the range.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums)</span>:</span>
    jumps = <span class="hljs-number">0</span>
    farthest = <span class="hljs-number">0</span>
    current_end = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Iterate through the array (but we don't need to check the last element)</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums) - <span class="hljs-number">1</span>):
        farthest = max(farthest, i + nums[i])  <span class="hljs-comment"># Update the farthest we can reach</span>
        
        <span class="hljs-comment"># Step 2: If we've reached the end of the current range, we need to make a jump</span>
        <span class="hljs-keyword">if</span> i == current_end:
            jumps += <span class="hljs-number">1</span>
            current_end = farthest  <span class="hljs-comment"># Update the current range to the farthest index we can reach</span>
    
    <span class="hljs-keyword">return</span> jumps

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]
print(jump(nums))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the input array.</span>
<span class="hljs-comment"># We traverse the array once, updating the farthest point we can reach at each step.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few variables to track the farthest point, current range, and jump count.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach is optimal and solves the problem with the minimum number of jumps in <code>O(n)</code> time and <code>O(1)</code> space. There is no more efficient approach.</p>
<hr>
<h3 id="4-gas-station-medium">4. <strong>Gas Station</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at station <code>i</code> is <code>gas[i]</code>. You have a car with an unlimited gas tank, but it costs <code>cost[i]</code> of gas to travel from station <code>i</code> to station <code>i + 1</code>. You begin the journey with an empty tank at one of the gas stations. Return the starting gas station index if you can complete the circuit once, otherwise return <code>-1</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3

Explanation:
Start at station 3 (index 3), and you can complete the circuit.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Greedy</strong>. We need to check if the total gas is greater than or equal to the total cost. If it is, then we can complete the circuit. While traversing the gas stations, we keep track of the current tank of gas. If at any point the current tank becomes negative, we reset the starting station to the next one.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas, cost)</span>:</span>
    total_tank, current_tank = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    start_station = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Iterate through all gas stations</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(gas)):
        total_tank += gas[i] - cost[i]
        current_tank += gas[i] - cost[i]
        
        <span class="hljs-comment"># Step 2: If current tank is negative, we can't start from this station, reset start station</span>
        <span class="hljs-keyword">if</span> current_tank &lt; <span class="hljs-number">0</span>:
            start_station = i + <span class="hljs-number">1</span>
            current_tank = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 3: If total gas is less than total cost, return -1, otherwise return the starting station</span>
    <span class="hljs-keyword">return</span> start_station <span class="hljs-keyword">if</span> total_tank &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>

<span class="hljs-comment"># Example test case</span>
gas = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
cost = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
print(canCompleteCircuit(gas, cost))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of gas stations.</span>
<span class="hljs-comment"># We traverse the list of gas stations once, updating the tank at each step.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few variables to track the total tank, current tank, and starting station.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach is optimal, solving the problem in linear time with constant space. There is no need for a more complex approach, as this is the most efficient.</p>
<hr>
<p>Let's continue with the remaining problems from the <strong>Greedy</strong> section.</p>
<hr>
<h3 id="5-hand-of-straights-medium">5. <strong>Hand of Straights</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an array of integers <code>hand</code>, where <code>hand[i]</code> represents the number of a card, and an integer <code>groupSize</code>. The task is to determine if you can rearrange the cards into groups of <code>groupSize</code>, where each group consists of consecutive cards.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
Output: true

Explanation:
You can rearrange the cards into groups of 3: [1,2,3], [2,3,4], [6,7,8].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Greedy</strong> approach. The idea is to always try to form a group starting with the smallest available card. We use a frequency map to count the occurrences of each card and reduce the count as we form valid groups.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isNStraightHand</span><span class="hljs-params">(hand, groupSize)</span>:</span>
    <span class="hljs-keyword">if</span> len(hand) % groupSize != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-comment"># Step 1: Count the occurrences of each card</span>
    card_count = Counter(hand)
    
    <span class="hljs-comment"># Step 2: Iterate through the sorted cards and try to form groups</span>
    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> sorted(card_count):
        <span class="hljs-keyword">if</span> card_count[card] &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(groupSize):
                <span class="hljs-keyword">if</span> card_count[card + i] &lt; card_count[card]:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
                card_count[card + i] -= card_count[card]
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-comment"># Example test case</span>
hand = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]
groupSize = <span class="hljs-number">3</span>
print(isNStraightHand(hand, groupSize))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n log n), where n is the number of cards in the hand.</span>
<span class="hljs-comment"># Sorting the hand takes O(n log n), and iterating over the cards takes O(n).</span>

<span class="hljs-comment"># Space Complexity: O(n), because we use a frequency map to store the count of each card.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally different approach, as the greedy solution with a frequency map is optimal in terms of time complexity. Sorting is necessary to ensure that consecutive groups are formed.</p>
<hr>
<h3 id="6-merge-triplets-to-form-target-triplet-medium">6. <strong>Merge Triplets to Form Target Triplet</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a list of triplets <code>triplets</code>, where <code>triplets[i] = [ai, bi, ci]</code> describes the values of the <code>i-th</code> triplet. You are also given a target triplet <code>target = [x, y, z]</code>. The task is to check if it is possible to pick some triplets from the list and merge them to form the target triplet. Merging two triplets means taking the maximum value from each position.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: triplets = [[2,5,3], [1,8,4], [1,7,5]], target = [2,7,5]
Output: true

Explanation:
- Select the triplet [2,5,3] and [1,7,5].
- Merge them: max(2,1) = 2, max(5,7) = 7, max(3,5) = 5 → The result is [2,7,5].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>We can solve this using a <strong>Greedy</strong> approach. We try to merge triplets that are component-wise less than or equal to the target triplet. For each valid triplet, we update a result array that tracks the maximum values seen so far. At the end, we check if the result matches the target.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTriplets</span><span class="hljs-params">(triplets, target)</span>:</span>
    result = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    
    <span class="hljs-comment"># Step 1: Iterate through the triplets</span>
    <span class="hljs-keyword">for</span> triplet <span class="hljs-keyword">in</span> triplets:
        <span class="hljs-keyword">if</span> triplet[<span class="hljs-number">0</span>] &lt;= target[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> triplet[<span class="hljs-number">1</span>] &lt;= target[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> triplet[<span class="hljs-number">2</span>] &lt;= target[<span class="hljs-number">2</span>]:
            result = [max(result[i], triplet[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)]
    
    <span class="hljs-comment"># Step 2: Check if the result matches the target</span>
    <span class="hljs-keyword">return</span> result == target

<span class="hljs-comment"># Example test case</span>
triplets = [[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]]
target = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]
print(mergeTriplets(triplets, target))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of triplets in the list.</span>
<span class="hljs-comment"># We iterate through the list once and update the result array.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a fixed-size result array.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no more efficient approach for this problem. The greedy approach of selecting triplets that are less than or equal to the target in all components is optimal.</p>
<hr>
<h3 id="7-partition-labels-medium">7. <strong>Partition Labels</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a string <code>s</code>. The task is to partition the string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;ababcbacadefegdehijhklij&quot;
Output: [9,7,8]

Explanation:
- The first partition is &quot;ababcbaca&quot;, the second is &quot;defegde&quot;, and the third is &quot;hijhklij&quot;.
- Each letter appears in at most one part.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Greedy</strong> approach. We first find the last occurrence of each character in the string. Then, we iterate through the string, maintaining the farthest point we can reach for the current partition. When the current index reaches this farthest point, we record the size of the partition and start a new one.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-comment"># Step 1: Record the last occurrence of each character</span>
    last_occurrence = {char: i <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> enumerate(s)}
    
    result = []
    start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 2: Iterate through the string</span>
    <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> enumerate(s):
        end = max(end, last_occurrence[char])  <span class="hljs-comment"># Extend the current partition to the farthest last occurrence</span>
        
        <span class="hljs-comment"># Step 3: If we reach the end of the partition, record its size</span>
        <span class="hljs-keyword">if</span> i == end:
            result.append(i - start + <span class="hljs-number">1</span>)
            start = i + <span class="hljs-number">1</span>  <span class="hljs-comment"># Start a new partition</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"ababcbacadefegdehijhklij"</span>
print(partitionLabels(s))  <span class="hljs-comment"># Output: [9, 7, 8]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the string.</span>
<span class="hljs-comment"># We traverse the string twice: once to record the last occurrence of each character, and once to determine the partitions.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a fixed-size map to store the last occurrences of characters.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach is optimal, and there is no better method. The key observation is to form the partitions based on the last occurrences of characters.</p>
<hr>
<h3 id="8-valid-parenthesis-string-medium">8. <strong>Valid Parenthesis String</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a string <code>s</code> containing only three types of characters: <code>'('</code>, <code>')'</code>, and <code>'*'</code>, return <code>True</code> if the string is valid. The string is considered valid if it can be turned into a valid parenthesis string by replacing each '*' with either <code>'('</code>, <code>')'</code>, or an empty string.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: s = &quot;(*))&quot;
Output: true

Explanation:
The string can be made valid by replacing '*' with an empty string.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Greedy</strong> approach. We maintain two counts: <code>low</code> (the minimum possible open parentheses) and <code>high</code> (the maximum possible open parentheses). For each character:</p>
<ul>
<li>If it’s <code>'('</code>, both <code>low</code> and <code>high</code> are incremented.</li>
<li>If it’s <code>')'</code>, both are decremented.</li>
<li>If it’s <code>'*'</code>, we consider it can be either <code>'('</code>, <code>')'</code>, or an empty string, so <code>low</code> is decremented, and <code>high</code> is incremented.
Finally, if <code>low</code> is 0, it means that there is a valid sequence of parentheses.</li>
</ul>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(s)</span>:</span>
    low = <span class="hljs-number">0</span>  <span class="hljs-comment"># Minimum possible open parentheses</span>
    high = <span class="hljs-number">0</span>  <span class="hljs-comment"># Maximum possible open parentheses</span>
    
    <span class="hljs-comment"># Step 1: Iterate through the string</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> char == <span class="hljs-string">'('</span>:
            low += <span class="hljs-number">1</span>
            high += <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> char == <span class="hljs-string">')'</span>:
            low -= <span class="hljs-number">1</span>
            high -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># char == '*'</span>
            low -= <span class="hljs-number">1</span>  <span class="hljs-comment"># Consider '*' as ')'</span>
            high += <span class="hljs-number">1</span>  <span class="hljs-comment"># Consider '*' as '('</span>
        
        <span class="hljs-comment"># Step 2: Ensure low does not drop below 0</span>
        <span class="hljs-keyword">if</span> high &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># Too many</span>

 closing parentheses
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        low = max(low, <span class="hljs-number">0</span>)
    
    <span class="hljs-keyword">return</span> low == <span class="hljs-number">0</span>

<span class="hljs-comment"># Example test case</span>
s = <span class="hljs-string">"(*))"</span>
print(checkValidString(s))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the string.</span>
<span class="hljs-comment"># We traverse the string once, updating the counts at each step.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few variables to track the possible number of open parentheses.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach is optimal, solving the problem in <code>O(n)</code> time with <code>O(1)</code> space complexity. There is no more efficient approach.</p>
<hr>
<h2 id="intervals"><strong>INTERVALS</strong></h2>
<h3 id="1-insert-interval-medium">1. <strong>Insert Interval</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code> represent the start and end of the <code>i-th</code> interval, and the intervals are sorted in ascending order by <code>start_i</code>. You are also given a new interval <code>newInterval = [start, end]</code> that you need to insert into the intervals. The resulting intervals should still be non-overlapping and sorted in ascending order.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[1,3], [6,9]], newInterval = [2,5]
Output: [[1,5], [6,9]]

Explanation:
- The interval [2, 5] overlaps with [1, 3]. We merge them to form [1, 5].
- The resulting intervals are [[1, 5], [6, 9]].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using an <strong>Interval Merging</strong> pattern. The key steps are:</p>
<ol>
<li>Iterate through the intervals and add all intervals that come before the <code>newInterval</code> (i.e., intervals that do not overlap with it).</li>
<li>Merge all intervals that overlap with <code>newInterval</code>.</li>
<li>Add all remaining intervals that come after the <code>newInterval</code>.</li>
</ol>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(intervals, newInterval)</span>:</span>
    result = []
    i = <span class="hljs-number">0</span>
    n = len(intervals)
    
    <span class="hljs-comment"># Step 1: Add all intervals that end before the new interval starts (no overlap).</span>
    <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]:
        result.append(intervals[i])
        i += <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Step 2: Merge all intervals that overlap with the new interval.</span>
    <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]:
        newInterval[<span class="hljs-number">0</span>] = min(newInterval[<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>])  <span class="hljs-comment"># Adjust start to the smallest</span>
        newInterval[<span class="hljs-number">1</span>] = max(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])  <span class="hljs-comment"># Adjust end to the largest</span>
        i += <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Add the merged interval to the result.</span>
    result.append(newInterval)
    
    <span class="hljs-comment"># Step 3: Add the remaining intervals that start after the new interval ends.</span>
    <span class="hljs-keyword">while</span> i &lt; n:
        result.append(intervals[i])
        i += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>]]
newInterval = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
print(insert(intervals, newInterval))  <span class="hljs-comment"># Output: [[1, 5], [6, 9]]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of intervals.</span>
<span class="hljs-comment"># We iterate through all the intervals exactly once to either add or merge them.</span>

<span class="hljs-comment"># Space Complexity: O(n), where n is the number of intervals.</span>
<span class="hljs-comment"># We store the result in a list of intervals, which takes linear space.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no significantly better alternative approach, as the greedy solution efficiently handles interval merging in a single pass through the list. Here’s a more detailed step-by-step explanation with comments.</p>
<hr>
<h3 id="2-merge-intervals-medium">2. <strong>Merge Intervals</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of intervals where <code>intervals[i] = [start_i, end_i]</code>, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

Explanation:
- Intervals [1,3] and [2,6] overlap, so we merge them into [1,6].
- The other intervals do not overlap, so they remain as they are.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can also be solved using the <strong>Interval Merging</strong> pattern. The key steps are:</p>
<ol>
<li>Sort the intervals by their start time.</li>
<li>Iterate through the sorted intervals and merge any overlapping intervals.</li>
</ol>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals)</span>:</span>
    <span class="hljs-comment"># Step 1: Sort intervals by their start times.</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    
    result = []
    
    <span class="hljs-comment"># Step 2: Iterate through intervals and merge overlapping ones.</span>
    <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals:
        <span class="hljs-comment"># If result is empty or the current interval does not overlap with the last one, add it.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result <span class="hljs-keyword">or</span> result[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]:
            result.append(interval)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Merge the current interval with the last interval in result.</span>
            result[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(result[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">18</span>]]
print(merge(intervals))  <span class="hljs-comment"># Output: [[1, 6], [8, 10], [15, 18]]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n log n), where n is the number of intervals.</span>
<span class="hljs-comment"># Sorting the intervals takes O(n log n), and iterating through them takes O(n).</span>

<span class="hljs-comment"># Space Complexity: O(n), where n is the number of intervals.</span>
<span class="hljs-comment"># We store the merged intervals in a result list, which takes linear space.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The greedy interval merging approach is optimal and commonly used for interval problems. We could use a divide-and-conquer approach, but the complexity would still involve sorting, so the overall time complexity remains O(n log n).</p>
<hr>
<h3 id="3-non-overlapping-intervals-medium">3. <strong>Non-overlapping Intervals</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1

Explanation:
- We remove the interval [1, 3] to make the rest of the intervals non-overlapping.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Greedy</strong>. We can sort the intervals by their end time and then iterate through the intervals, counting how many intervals need to be removed to ensure no overlap.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(intervals)</span>:</span>
    <span class="hljs-comment"># Step 1: Sort intervals by their end times.</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
    
    count = <span class="hljs-number">0</span>
    prev_end = float(<span class="hljs-string">'-inf'</span>)
    
    <span class="hljs-comment"># Step 2: Iterate through intervals and count overlapping intervals.</span>
    <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> intervals:
        <span class="hljs-keyword">if</span> start &gt;= prev_end:
            <span class="hljs-comment"># No overlap, update prev_end.</span>
            prev_end = end
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Overlapping, increment count.</span>
            count += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> count

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]]
print(eraseOverlapIntervals(intervals))  <span class="hljs-comment"># Output: 1</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n log n), where n is the number of intervals.</span>
<span class="hljs-comment"># Sorting the intervals takes O(n log n), and iterating through them takes O(n).</span>

<span class="hljs-comment"># Space Complexity: O(1), since we are only using a few extra variables.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach is optimal for minimizing the number of intervals removed. There’s no better solution in terms of time or space complexity.</p>
<hr>
<h3 id="4-meeting-rooms-easy">4. <strong>Meeting Rooms</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, determine if a person can attend all meetings. If no intervals overlap, return <code>True</code>, otherwise return <code>False</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[0,30],[5,10],[15,20]]
Output: false

Explanation:
- The meeting [0, 30] overlaps with [5, 10], so it's not possible to attend all meetings.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Greedy</strong>. We sort the intervals by their start time and check if any two consecutive intervals overlap.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canAttendMeetings</span><span class="hljs-params">(intervals)</span>:</span>
    <span class="hljs-comment"># Step 1: Sort intervals by their start time.</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    
    <span class="hljs-comment"># Step 2: Check for overlapping intervals.</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(intervals)):
        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># Overlap found</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">0</span>, <span class="hljs-number">30</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">20</span>]]
print(canAttendMeetings(intervals))  <span class="hljs-comment"># Output: False</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n log n), where n is the number of intervals.</span>
<span class="hljs-comment"># Sorting the intervals takes O(n log n), and checking for overlap takes O(n).</span>

<span class="hljs-comment"># Space Complexity: O(1), since we only use a few variables.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The greedy approach of sorting and checking for overlaps is optimal. There’s no faster way to determine if all meetings can be attended.</p>
<hr>
<h3 id="5-meeting-rooms-ii-medium">5. <strong>Meeting Rooms II</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

Explanation:
- Two meetings overlap, so at least two conference rooms are required.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Greedy + Two Pointers</strong> approach. We track the start and end times of meetings and determine the minimum number of overlapping intervals using a two-pointer technique.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(intervals)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Extract start and end times, and sort them separately.</span>
    start_times = sorted([interval[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals])
    end_times = sorted([interval[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals])
    
    start_ptr, end_ptr = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    rooms_needed, max_rooms = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 2: Use two pointers to track the number of overlapping meetings.</span>
    <span class="hljs-keyword">while</span> start_ptr &lt; len(intervals):
        <span class="hljs-keyword">if</span> start_times[start_ptr] &lt; end_times[end_ptr]:
            rooms_needed += <span class="hljs-number">1</span>
            start_ptr += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            rooms_needed -= <span class="hljs-number">1</span>
            end_ptr += <span class="hljs-number">1</span>
        max_rooms = max(max_rooms, rooms_needed)
    
    <span class="hljs-keyword">return</span> max_rooms

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">0</span>, <span class="hljs-number">30</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">20</span>]]
print(minMeetingRooms(intervals))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n log n), where n is the number of intervals.</span>
<span class="hljs-comment"># Sorting the start and end times takes O(n log n), and the two-pointer technique takes O(n).</span>

<span class="hljs-comment"># Space Complexity: O(n), because we store the start and end times in two separate lists.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The two-pointer technique is optimal for minimizing the number of conference rooms. Another approach could involve using a priority queue to track ongoing meetings, but the time complexity would remain the same.</p>
<hr>
<p>Let's continue with the remaining problems from the <strong>Intervals</strong> section and then move on to the <strong>Math &amp; Geometry</strong> and <strong>Bit Manipulation</strong> sections.</p>
<hr>
<h3 id="6-minimum-interval-to-include-each-query-hard">6. <strong>Minimum Interval to Include Each Query</strong> (Hard)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an array of intervals <code>intervals</code>, where <code>intervals[i] = [start_i, end_i]</code> represent the start and end of the <code>i-th</code> interval. You are also given an array of queries <code>queries</code>, where each query represents a point. For each query, find the minimum size of an interval from the list of intervals that includes the query point. If no interval contains the query, return <code>-1</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: intervals = [[1, 4], [2, 4], [3, 6], [4, 4]], queries = [2, 3, 4, 5]
Output: [3, 3, 1, 4]

Explanation:
- For query 2, the smallest interval that includes it is [1, 4] or [2, 4] (size 3).
- For query 3, the smallest interval that includes it is [2, 4] or [3, 6] (size 3).
- For query 4, the smallest interval is [4, 4] (size 1).
- For query 5, the smallest interval is [3, 6] (size 4).
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be efficiently solved using a <strong>Greedy + Sorting</strong> technique. The idea is to first sort both intervals and queries. Then, for each query, maintain a list of intervals that include the query, and remove any intervals that no longer apply. A min-heap can help us efficiently find the smallest interval that contains each query.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minInterval</span><span class="hljs-params">(intervals, queries)</span>:</span>
    <span class="hljs-comment"># Step 1: Sort intervals by their start time</span>
    intervals.sort()
    <span class="hljs-comment"># Step 2: Sort queries and store the original indices to return results in order</span>
    sorted_queries = sorted((q, i) <span class="hljs-keyword">for</span> i, q <span class="hljs-keyword">in</span> enumerate(queries))
    
    result = [<span class="hljs-number">-1</span>] * len(queries)  <span class="hljs-comment"># To store results in the original query order</span>
    min_heap = []  <span class="hljs-comment"># Min-heap to track intervals that can cover the query</span>
    i = <span class="hljs-number">0</span>  <span class="hljs-comment"># Pointer for intervals</span>
    
    <span class="hljs-comment"># Step 3: Process each query</span>
    <span class="hljs-keyword">for</span> query, index <span class="hljs-keyword">in</span> sorted_queries:
        <span class="hljs-comment"># Add all intervals that can start before or at the current query</span>
        <span class="hljs-keyword">while</span> i &lt; len(intervals) <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= query:
            start, end = intervals[i]
            <span class="hljs-comment"># If the interval can cover the query, add it to the heap</span>
            <span class="hljs-keyword">if</span> end &gt;= query:
                heapq.heappush(min_heap, (end - start + <span class="hljs-number">1</span>, end))  <span class="hljs-comment"># Store the interval length and end time</span>
            i += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Remove intervals that end before the query</span>
        <span class="hljs-keyword">while</span> min_heap <span class="hljs-keyword">and</span> min_heap[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt; query:
            heapq.heappop(min_heap)
        
        <span class="hljs-comment"># The smallest valid interval is at the top of the heap</span>
        <span class="hljs-keyword">if</span> min_heap:
            result[index] = min_heap[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
intervals = [[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>]]
queries = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
print(minInterval(intervals, queries))  <span class="hljs-comment"># Output: [3, 3, 1, 4]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O((n + m) log n), where n is the number of intervals and m is the number of queries.</span>
<span class="hljs-comment"># Sorting the intervals takes O(n log n), sorting the queries takes O(m log m), and we process each query in O(log n).</span>

<span class="hljs-comment"># Space Complexity: O(n), where n is the number of intervals stored in the min-heap at any point.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This greedy approach combined with a min-heap is efficient for minimizing the interval size. Other approaches, such as using brute force to check all intervals for each query, would result in O(n * m) complexity, which is much slower.</p>
<hr>
<p>Now, let's move on to the <strong>Math &amp; Geometry</strong> section.</p>
<hr>
<h3 id="7-rotate-image-medium">7. <strong>Rotate Image</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given an <code>n x n</code> 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) in-place, meaning you cannot use extra space for another matrix.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
Output: [
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Matrix Rotation</strong> pattern. First, transpose the matrix (convert rows to columns), and then reverse each row to achieve a 90-degree clockwise rotation.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix)</span>:</span>
    n = len(matrix)
    
    <span class="hljs-comment"># Step 1: Transpose the matrix (convert rows to columns)</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    <span class="hljs-comment"># Step 2: Reverse each row to get the rotated matrix</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        matrix[i].reverse()

<span class="hljs-comment"># Example test case</span>
matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
]
rotate(matrix)
print(matrix)  <span class="hljs-comment"># Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n^2), where n is the dimension of the matrix.</span>
<span class="hljs-comment"># We iterate through the matrix twice: once for the transpose and once for reversing the rows.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we perform the rotation in place without using additional space.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>There is no fundamentally better approach than transposing and reversing the matrix. The solution efficiently performs the rotation in place with O(1) space complexity.</p>
<hr>
<h3 id="8-spiral-matrix-medium">8. <strong>Spiral Matrix</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an <code>m x n</code> matrix, return all elements of the matrix in spiral order.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Spiral Traversal</strong> pattern. The key is to keep track of the boundaries of the matrix (top, bottom, left, right) and adjust these boundaries as we traverse in a spiral manner.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix)</span>:</span>
    result = []
    
    <span class="hljs-comment"># Step 1: Define the boundaries of the spiral</span>
    top, bottom = <span class="hljs-number">0</span>, len(matrix) - <span class="hljs-number">1</span>
    left, right = <span class="hljs-number">0</span>, len(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>
    
    <span class="hljs-comment"># Step 2: Traverse the matrix in a spiral manner</span>
    <span class="hljs-keyword">while</span> top &lt;= bottom <span class="hljs-keyword">and</span> left &lt;= right:
        <span class="hljs-comment"># Traverse from left to right</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(left, right + <span class="hljs-number">1</span>):
            result.append(matrix[top][i])
        top += <span class="hljs-number">1</span>
        
        <span class="hljs-comment"># Traverse from top to bottom</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(top, bottom + <span class="hljs-number">1</span>):
            result.append(matrix[i][right])
        right -= <span class="hljs-number">1</span>
        
        <span class="hljs-keyword">if</span> top &lt;= bottom:
            <span class="hljs-comment"># Traverse from right to left</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(right, left - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>):
                result.append(matrix[bottom][i])
            bottom -= <span class="hljs-number">1</span>
        
        <span class="hljs-keyword">if</span> left &lt;= right:
            <span class="hljs-comment"># Traverse from bottom to top</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(bottom, top - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>):
                result.append(matrix[i][left])
            left += <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
]
print(spiralOrder(matrix))  <span class="hljs-comment"># Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the number of rows and n is the number of columns.</span>
<span class="hljs-comment"># We visit each element of the matrix exactly once.</span>

<span class="hljs-comment"># Space Complexity: O(1), ignoring the space used for the result list, as we don't use any additional data structures.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The spiral traversal pattern is optimal for this problem. Any alternative approach would involve traversing the matrix in some other order, but the time complexity would remain O(m * n).</p>
<hr>
<p>Let's continue with the remaining problems from the <strong>Math &amp; Geometry</strong> section and then move on to the <strong>Bit Manipulation</strong> section.</p>
<hr>
<h3 id="9-set-matrix-zeroes-medium">9. <strong>Set Matrix Zeroes</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an <code>m x n</code> matrix, if an element is 0, set its entire row and column to 0. You must do this in place, without using extra space for another matrix.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: matrix = [
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: [
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using the <strong>Matrix Manipulation</strong> pattern. We will use the first row and the first column as markers to store whether the entire row or column should be set to zero. Then, in a second pass, we update the matrix.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix)</span>:</span>
    <span class="hljs-comment"># Step 1: Use the first row and first column as markers</span>
    rows, cols = len(matrix), len(matrix[<span class="hljs-number">0</span>])
    first_row_has_zero = any(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols))
    first_col_has_zero = any(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows))
    
    <span class="hljs-comment"># Step 2: Mark the rows and columns that need to be set to zero</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, rows):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, cols):
            <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:
                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Mark the row</span>
                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Mark the column</span>
    
    <span class="hljs-comment"># Step 3: Zero out cells based on the markers</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, rows):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, cols):
            <span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>:
                matrix[i][j] = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 4: Zero out the first row if needed</span>
    <span class="hljs-keyword">if</span> first_row_has_zero:
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(cols):
            matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 5: Zero out the first column if needed</span>
    <span class="hljs-keyword">if</span> first_col_has_zero:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rows):
            matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>

<span class="hljs-comment"># Example test case</span>
matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
]
setZeroes(matrix)
print(matrix)  <span class="hljs-comment"># Output: [[1, 0, 1], [0, 0, 0], [1, 0, 1]]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(m * n), where m is the number of rows and n is the number of columns.</span>
<span class="hljs-comment"># We traverse the entire matrix twice: once to set markers and once to update the matrix.</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are not using any extra space beyond the matrix itself.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This in-place solution using the first row and column as markers is optimal. Using additional space (e.g., separate arrays to track rows and columns to zero) would increase space complexity to O(m + n).</p>
<hr>
<h3 id="10-happy-number-easy">10. <strong>Happy Number</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Write an algorithm to determine if a number <code>n</code> is a happy number. A happy number is defined by repeatedly replacing the number with the sum of the squares of its digits until the number equals 1 (where it becomes happy) or it loops endlessly in a cycle that does not include 1.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 19
Output: true

Explanation:
19 -&gt; 1^2 + 9^2 = 82
82 -&gt; 8^2 + 2^2 = 68
68 -&gt; 6^2 + 8^2 = 100
100 -&gt; 1^2 + 0^2 + 0^2 = 1 (happy)
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using the <strong>Cycle Detection</strong> pattern. We can use Floyd's Cycle Detection Algorithm (also known as the tortoise and hare) to detect if the sequence enters a cycle.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_next</span><span class="hljs-params">(number)</span>:</span>
        <span class="hljs-keyword">return</span> sum(int(digit) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> str(number))
    
    slow = n
    fast = get_next(n)
    
    <span class="hljs-comment"># Step 1: Use the two-pointer technique to detect cycles</span>
    <span class="hljs-keyword">while</span> fast != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    
    <span class="hljs-keyword">return</span> fast == <span class="hljs-number">1</span>

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">19</span>
print(isHappy(n))  <span class="hljs-comment"># Output: True</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(log n), where n is the value of the number.</span>
<span class="hljs-comment"># Each step reduces the number of digits, and squaring each digit takes O(log n).</span>

<span class="hljs-comment"># Space Complexity: O(1), because we are using a constant amount of extra space (two pointers).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>An alternative approach is to use a set to track numbers we have seen before and detect cycles by checking if the number repeats. However, Floyd's Cycle Detection is more space-efficient with O(1) space.</p>
<hr>
<h3 id="11-plus-one-easy">11. <strong>Plus One</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>You are given a large integer represented as an array of digits. Increment the integer by one and return the resulting array of digits.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: digits = [1, 2, 9]
Output: [1, 3, 0]

Explanation:
- The number 129 is incremented to 130, so the output is [1, 3, 0].
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Simple Arithmetic</strong>. We start from the last digit and propagate any carry to the left.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plusOne</span><span class="hljs-params">(digits)</span>:</span>
    n = len(digits)
    
    <span class="hljs-comment"># Step 1: Start from the last digit and propagate the carry</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):
        <span class="hljs-keyword">if</span> digits[i] &lt; <span class="hljs-number">9</span>:
            digits[i] += <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> digits
        digits[i] = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 2: If all digits were 9, we need to add an additional digit</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>] + digits

<span class="hljs-comment"># Example test case</span>
digits = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>]
print(plusOne(digits))  <span class="hljs-comment"># Output: [1, 3, 0]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of digits.</span>
<span class="hljs-comment"># We may need to traverse all digits in the worst case (e.g., [9, 9, 9]).</span>

<span class="hljs-comment"># Space Complexity: O(1), ignoring the output array (in-place modification of the input).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>The greedy approach of modifying digits from the least significant to the most significant digit is optimal. There are no faster methods to achieve this.</p>
<hr>
<p>Now, let's move on to the <strong>Bit Manipulation</strong> section.</p>
<hr>
<h3 id="12-single-number-easy">12. <strong>Single Number</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a non-empty array of integers <code>nums</code>, every element appears twice except for one. Find that single element. Your algorithm should have a linear runtime complexity and use only constant extra space.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [4,1,2,1,2]
Output: 4

Explanation:
All elements except 4 appear twice, so 4 is the single number.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Bit Manipulation</strong>. We can use the XOR operator (<code>^</code>), which cancels out any number that appears twice, leaving only the single number.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums)</span>:</span>
    result = <span class="hljs-number">0</span>
    <span class="hljs-comment"># Step 1: XOR all numbers. Pairs cancel each other, leaving the single number.</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
        result ^= num
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
print(singleNumber(nums))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the length of the array.</span>
<span class="hljs-comment"># We iterate through the array once, performing XOR on each element.</span>

<span class="hljs-comment"># Space Complexity: O(1), since we are only using a constant amount of extra space (the result variable).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This XOR approach is optimal for finding the single number in linear time and constant space. An alternative approach could involve using a set or hash map to track occurrences, but this would increase the space complexity to O(n).</p>
<hr>
<h3 id="13-number-of-1-bits-easy">13. <strong>Number of 1 Bits</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 00000000000000000000000000001011
Output: 3

Explanation:
The binary representation of 11 has three '1' bits.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Bit Manipulation</strong>. We can repeatedly shift the number right and count how many times the least significant bit is <code>1</code>.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(n)</span>:</span>
    count = <span class="hljs-number">0</span>


    <span class="hljs-comment"># Step 1: Count the number of '1' bits in the binary representation of n</span>
    <span class="hljs-keyword">while</span> n:
        count += n &amp; <span class="hljs-number">1</span>  <span class="hljs-comment"># Check if the least significant bit is 1</span>
        n &gt;&gt;= <span class="hljs-number">1</span>  <span class="hljs-comment"># Right shift n by 1 to check the next bit</span>
    <span class="hljs-keyword">return</span> count

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">0b00000000000000000000000000001011</span>
print(hammingWeight(n))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(1), since n is a fixed 32-bit or 64-bit integer.</span>
<span class="hljs-comment"># The loop runs a fixed number of iterations (up to 32 or 64).</span>

<span class="hljs-comment"># Space Complexity: O(1), because we only use a few extra variables (count and n).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>An alternative approach is to repeatedly clear the least significant <code>1</code> bit using <code>n &amp; (n - 1)</code>. This approach is slightly faster in cases where there are fewer <code>1</code> bits, but the overall complexity remains O(1).</p>
<hr>
<p>Let’s continue with the remaining problems from the <strong>Bit Manipulation</strong> section.</p>
<hr>
<h3 id="14-counting-bits-easy">14. <strong>Counting Bits</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an integer <code>n</code>, return an array <code>ans</code> of length <code>n + 1</code> such that for each <code>i</code> (0 &lt;= i &lt;= n), <code>ans[i]</code> is the number of <code>1</code> bits in the binary representation of <code>i</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 5
Output: [0,1,1,2,1,2]

Explanation:
- 0 has 0 '1' bits.
- 1 has 1 '1' bit.
- 2 has 1 '1' bit.
- 3 has 2 '1' bits.
- 4 has 1 '1' bit.
- 5 has 2 '1' bits.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using a <strong>Dynamic Programming + Bit Manipulation</strong> pattern. The key observation is that the number of <code>1</code> bits in a number <code>i</code> can be related to the number of <code>1</code> bits in <code>i // 2</code> (right shift) plus the last bit (<code>i % 2</code>).</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countBits</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-comment"># Step 1: Initialize the result array with 0 for all values</span>
    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    
    <span class="hljs-comment"># Step 2: Fill the array using the relation dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1)</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        dp[i] = dp[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>)
    
    <span class="hljs-keyword">return</span> dp

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">5</span>
print(countBits(n))  <span class="hljs-comment"># Output: [0, 1, 1, 2, 1, 2]</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the input integer.</span>
<span class="hljs-comment"># We iterate from 1 to n, filling the result array.</span>

<span class="hljs-comment"># Space Complexity: O(n), because we store the result in an array of size n + 1.</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This approach is optimal, using dynamic programming to compute the number of <code>1</code> bits in linear time. There’s no faster approach since we need to compute the bits for all numbers from <code>0</code> to <code>n</code>.</p>
<hr>
<h3 id="15-reverse-bits-easy">15. <strong>Reverse Bits</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Reverse the bits of a given 32-bit unsigned integer.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: n = 43261596 (00000010100101000001111010011100 in binary)
Output: 964176192 (00111001011110000010100101000000 in binary)
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Bit Manipulation</strong>. We can reverse the bits by iterating over the 32 bits, shifting them into a new number.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(n)</span>:</span>
    result = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Iterate through all 32 bits</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):
        <span class="hljs-comment"># Shift result to the left and add the current bit from n</span>
        result = (result &lt;&lt; <span class="hljs-number">1</span>) | (n &amp; <span class="hljs-number">1</span>)
        n &gt;&gt;= <span class="hljs-number">1</span>  <span class="hljs-comment"># Shift n to the right</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
n = <span class="hljs-number">43261596</span>  <span class="hljs-comment"># In binary: 00000010100101000001111010011100</span>
print(reverseBits(n))  <span class="hljs-comment"># Output: 964176192 (00111001011110000010100101000000)</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(1), since we always perform exactly 32 iterations (constant number of bits).</span>

<span class="hljs-comment"># Space Complexity: O(1), as we only use a few extra variables (n and result).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This approach is optimal for reversing the bits of a 32-bit integer. Using a different method (like bit shifts or masks) would result in the same complexity.</p>
<hr>
<h3 id="16-missing-number-easy">16. <strong>Missing Number</strong> (Easy)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return the only number in the range that is missing from the array.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: nums = [3, 0, 1]
Output: 2

Explanation:
- The numbers in the range [0, 3] are {0, 1, 2, 3}.
- The number 2 is missing from the array.
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Bit Manipulation</strong> (XOR). The idea is that XORing all numbers from <code>0</code> to <code>n</code> with the numbers in the array will result in the missing number because all other numbers cancel out.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(nums)</span>:</span>
    result = len(nums)
    
    <span class="hljs-comment"># Step 1: XOR all indices and elements together</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
        result ^= i ^ nums[i]
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
nums = [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
print(missingNumber(nums))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(n), where n is the number of elements in the array.</span>
<span class="hljs-comment"># We iterate through the array once.</span>

<span class="hljs-comment"># Space Complexity: O(1), as we only use a constant amount of extra space (the result variable).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>An alternative approach is to use the sum formula for arithmetic sequences:</p>
<pre class="hljs"><code><div>sum([0, 1, ..., n]) - sum(nums) = missing number
</div></code></pre>
<p>However, the XOR approach is preferable because it avoids potential integer overflow issues with very large numbers.</p>
<hr>
<h3 id="17-sum-of-two-integers-medium">17. <strong>Sum of Two Integers</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given two integers <code>a</code> and <code>b</code>, return the sum of the two integers without using the operators <code>+</code> and <code>-</code>.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: a = 1, b = 2
Output: 3
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Bit Manipulation</strong> (using XOR for sum and AND for carry). The basic idea is that XOR (<code>^</code>) can sum bits without carry, while AND (<code>&amp;</code>) followed by a left shift gives the carry.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSum</span><span class="hljs-params">(a, b)</span>:</span>
    <span class="hljs-comment"># Step 1: Repeat until there is no carry</span>
    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>:
        carry = a &amp; b  <span class="hljs-comment"># AND gives the carry</span>
        a = a ^ b  <span class="hljs-comment"># XOR gives the sum without carry</span>
        b = carry &lt;&lt; <span class="hljs-number">1</span>  <span class="hljs-comment"># Shift carry to the left by 1 (carry into the next position)</span>
    
    <span class="hljs-keyword">return</span> a <span class="hljs-keyword">if</span> a &lt;= <span class="hljs-number">0x7FFFFFFF</span> <span class="hljs-keyword">else</span> ~(a ^ <span class="hljs-number">0xFFFFFFFF</span>)  <span class="hljs-comment"># Handle negative numbers (32-bit signed integer)</span>

<span class="hljs-comment"># Example test case</span>
a = <span class="hljs-number">1</span>
b = <span class="hljs-number">2</span>
print(getSum(a, b))  <span class="hljs-comment"># Output: 3</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(1), since the number of iterations is constant (a fixed number of bits in integers).</span>

<span class="hljs-comment"># Space Complexity: O(1), as we only use a few extra variables (a, b, carry).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This bit manipulation approach is optimal for performing addition without using arithmetic operators. There are no better alternatives.</p>
<hr>
<h3 id="18-reverse-integer-medium">18. <strong>Reverse Integer</strong> (Medium)</h3>
<h4 id="problem-explanation">Problem Explanation:</h4>
<p>Given a 32-bit signed integer <code>x</code>, return <code>x</code> with its digits reversed. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, return 0.</p>
<h4 id="numeric-example">Numeric Example:</h4>
<pre class="hljs"><code><div>Input: x = 123
Output: 321

Input: x = -123
Output: -321
</div></code></pre>
<h4 id="coding-pattern">Coding Pattern:</h4>
<p>This problem can be solved using <strong>Simple Arithmetic</strong>. We repeatedly extract the last digit of the number, build the reverse number, and check for overflow.</p>
<h4 id="solution">Solution:</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(x)</span>:</span>
    sign = <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
    x *= sign
    result = <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Extract digits and reverse the number</span>
    <span class="hljs-keyword">while</span> x:
        result = result * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>
        x //= <span class="hljs-number">10</span>
    
    result *= sign
    
    <span class="hljs-comment"># Step 2: Check for overflow (32-bit signed integer range)</span>
    <span class="hljs-keyword">if</span> result &lt; <span class="hljs-number">-2</span>**<span class="hljs-number">31</span> <span class="hljs-keyword">or</span> result &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span> - <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Example test case</span>
x = <span class="hljs-number">123</span>
print(reverse(x))  <span class="hljs-comment"># Output: 321</span>

x = <span class="hljs-number">-123</span>
print(reverse(x))  <span class="hljs-comment"># Output: -321</span>
</div></code></pre>
<h4 id="time-and-space-complexity">Time and Space Complexity:</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Time Complexity: O(log(x)), where x is the value of the input number.</span>
<span class="hljs-comment"># We extract the digits of x, and the number of digits is proportional to log(x).</span>

<span class="hljs-comment"># Space Complexity: O(1), as we only use a few extra variables (sign, result).</span>
</div></code></pre>
<h4 id="alternative-approach">Alternative Approach:</h4>
<p>This approach is optimal for reversing an integer. Other methods (e.g., converting the number to a string and reversing it) would increase space complexity.</p>
<hr>

</body>
</html>
