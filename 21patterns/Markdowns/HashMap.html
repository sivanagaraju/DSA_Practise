<!DOCTYPE html>
<html>
<head>
<title>HashMap.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="comprehensive-guide-to-hash-map-pattern">Comprehensive Guide to Hash Map Pattern</h1>
<h3 id="1-core-concepts-and-coding-patterns">1. Core Concepts and Coding Patterns</h3>
<p>Hash Map (or Hash Table) is a data structure that stores key-value pairs and provides efficient lookup, insertion, and deletion operations. The keys are used to index values, making it ideal for scenarios where fast data retrieval is needed.</p>
<ul>
<li><strong>Hashing</strong>: The core concept behind Hash Map is hashing, which involves applying a hash function to the key to determine the index in an underlying array. This ensures  average time complexity for operations.</li>
<li><strong>Collisions</strong>: When multiple keys hash to the same index, this is called a collision. Hash Maps handle collisions using methods like chaining (linked lists to store values) or open addressing (finding another index).</li>
<li><strong>Typical Use Cases</strong>: Hash Maps are useful for counting frequencies, maintaining mappings, or solving problems involving quick lookups and checking for duplicates.</li>
</ul>
<h3 id="2-examples">2. Examples</h3>
<p>Consider an example where you need to count the occurrence of each number in a list:</p>
<pre class="hljs"><code><div>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]
</div></code></pre>
<p>Using a Hash Map:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Resultant Hash Map:</span>
<span class="hljs-comment"># {</span>
<span class="hljs-comment">#   1: 3,</span>
<span class="hljs-comment">#   2: 2,</span>
<span class="hljs-comment">#   3: 1,</span>
<span class="hljs-comment">#   4: 1,</span>
<span class="hljs-comment">#   5: 1</span>
<span class="hljs-comment"># }</span>
</div></code></pre>
<p>Here, the key is each unique number, and the value is the count of its occurrence.</p>
<h3 id="3-problem-identification-checklist">3. Problem Identification Checklist</h3>
<p>A Hash Map is suitable for problems involving:</p>
<table>
<thead>
<tr>
<th>Criteria</th>
<th>Example Problem</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counting frequencies</td>
<td>Count character occurrences in a string</td>
</tr>
<tr>
<td>Maintaining mappings</td>
<td>Find the first unique character</td>
</tr>
<tr>
<td>Tracking index relationships</td>
<td>Two-sum problem</td>
</tr>
</tbody>
</table>
<h3 id="4-general-templates-with-detailed-comments-and-explanations">4. General Templates with Detailed Comments and Explanations</h3>
<h4 id="template-1-counting-frequencies">Template 1: Counting Frequencies</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Template to count frequencies of elements in a list.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_frequencies</span><span class="hljs-params">(arr)</span>:</span>
    <span class="hljs-comment"># Initialize an empty dictionary to store frequency counts.</span>
    frequency_map = {}
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:
        <span class="hljs-comment"># Check if the current number is already in the map.</span>
        <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> frequency_map:
            <span class="hljs-comment"># If present, increment the count by 1.</span>
            frequency_map[num] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># If not present, add the number to the map with an initial count of 1.</span>
            frequency_map[num] = <span class="hljs-number">1</span>
    <span class="hljs-comment"># Return the frequency map containing counts of all elements.</span>
    <span class="hljs-keyword">return</span> frequency_map

<span class="hljs-comment"># Example usage:</span>
arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
print(count_frequencies(arr))  <span class="hljs-comment"># Output: {1: 3, 2: 2, 3: 1}</span>
</div></code></pre>
<ul>
<li><strong>Use Cases</strong>: This template is useful for counting occurrences in lists or strings, such as counting character frequencies or counting item occurrences in a collection.</li>
<li><strong>Complexity</strong>: The time complexity is , where  is the length of the list, and the space complexity is  for storing the frequency counts.</li>
</ul>
<h4 id="template-2-using-hash-map-to-find-two-numbers-that-sum-to-a-target">Template 2: Using Hash Map to Find Two Numbers that Sum to a Target</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Template to find indices of two numbers that sum up to a given target.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">two_sum</span><span class="hljs-params">(nums, target)</span>:</span>
    <span class="hljs-comment"># Initialize an empty dictionary to store the index of each number encountered.</span>
    index_map = {}  <span class="hljs-comment"># Key: number, Value: index of the number</span>
    <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> enumerate(nums):
        <span class="hljs-comment"># Calculate the complement that, when added to the current number, equals the target.</span>
        complement = target - num
        <span class="hljs-comment"># Check if the complement is already in the map.</span>
        <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> index_map:
            <span class="hljs-comment"># If complement is found, return the indices of the complement and current number.</span>
            <span class="hljs-keyword">return</span> [index_map[complement], i]
        <span class="hljs-comment"># Store the current number with its index in the map.</span>
        index_map[num] = i
    <span class="hljs-comment"># If no such pair is found, return an empty list.</span>
    <span class="hljs-keyword">return</span> []

<span class="hljs-comment"># Example usage:</span>
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>]
target = <span class="hljs-number">9</span>
print(two_sum(nums, target))  <span class="hljs-comment"># Output: [0, 1]</span>
</div></code></pre>
<ul>
<li><strong>Use Cases</strong>: This template is most applicable for finding pairs with a given sum, such as finding two numbers in an array that add up to a specific value.</li>
<li><strong>Complexity</strong>: The time complexity is , where  is the number of elements in the list, and the space complexity is  for storing indices in the map.</li>
</ul>
<h4 id="template-3-grouping-elements-by-frequency">Template 3: Grouping Elements by Frequency</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Template to group elements by their frequency.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group_elements_by_frequency</span><span class="hljs-params">(arr)</span>:</span>
    <span class="hljs-comment"># Step 1: Count the frequency of each element.</span>
    frequency_map = {}
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:
        <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> frequency_map:
            frequency_map[num] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            frequency_map[num] = <span class="hljs-number">1</span>

    <span class="hljs-comment"># Step 2: Group elements by frequency.</span>
    grouped_map = {}  <span class="hljs-comment"># Key: frequency, Value: list of elements with that frequency</span>
    <span class="hljs-keyword">for</span> num, frequency <span class="hljs-keyword">in</span> frequency_map.items():
        <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> grouped_map:
            grouped_map[frequency] = []
        grouped_map[frequency].append(num)

    <span class="hljs-keyword">return</span> grouped_map

<span class="hljs-comment"># Example usage:</span>
arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
print(group_elements_by_frequency(arr))  <span class="hljs-comment"># Output: {3: [1], 2: [2], 1: [3]}</span>
</div></code></pre>
<ul>
<li><strong>Use Cases</strong>: Useful for problems where elements need to be grouped based on their occurrence frequency, such as finding elements that occur the most or least.</li>
<li><strong>Complexity</strong>: The time complexity is  for counting and grouping elements, and the space complexity is  for storing both frequency and grouping maps.</li>
</ul>
<h3 id="5-complexity-analysis">5. Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: Operations like lookup, insertion, and deletion have an average complexity of , but can degrade to  in the worst case due to collisions.</li>
<li><strong>Space Complexity</strong>: Hash Maps generally require  space for storing key-value pairs.</li>
<li><strong>Optimization Opportunities</strong>: Minimizing collisions by choosing an efficient hash function can significantly improve performance.</li>
</ul>
<h3 id="6-discussion-on-templates-and-patterns">6. Discussion on Templates and Patterns</h3>
<ul>
<li>Templates like frequency counting or mapping indices are versatile. Adjustments might be needed for specific edge cases, such as when dealing with negative values or non-numeric keys.</li>
</ul>
<h3 id="7-multiple-approaches-and-implementations">7. Multiple Approaches and Implementations</h3>
<h4 id="iterative-approach">Iterative Approach</h4>
<p>The iterative approach for counting or tracking is efficient in most cases. It involves traversing the list once and updating the Hash Map.</p>
<h4 id="recursive-approach">Recursive Approach</h4>
<p>For problems like DFS that require maintaining a history, recursive Hash Map usage might be suitable but should be used with care due to stack limitations.</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterative</td>
<td>Easy to implement, efficient</td>
<td>May require extra state management</td>
</tr>
<tr>
<td>Recursive</td>
<td>Natural fit for tree-like problems</td>
<td>Higher risk of stack overflow</td>
</tr>
</tbody>
</table>
<h3 id="8-practice-problems">8. Practice Problems</h3>
<table>
<thead>
<tr>
<th>S.No</th>
<th>Question</th>
<th>Example</th>
<th>Difficulty Level</th>
<th>Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Count character frequencies</td>
<td>Given the string &quot;banana&quot;, count the frequency of each character. Numeric Example: {'b': 1, 'a': 3, 'n': 2}. Output: {'b': 1, 'a': 3, 'n': 2}</td>
<td>Easy</td>
<td>Use counting frequency template. Variables: frequency_map. Loop through each character in string.</td>
</tr>
<tr>
<td>2</td>
<td>Two-sum problem</td>
<td>Given the list [2, 7, 11, 15] and target = 9, find indices of two numbers that sum to target. Numeric Example: Complement of 2 is 7. Output: [0, 1]</td>
<td>Easy</td>
<td>Use two-sum template. Variables: index_map. Track complement indices.</td>
</tr>
<tr>
<td>3</td>
<td>Find first unique character</td>
<td>Given the string &quot;swiss&quot;, find the first unique character. Numeric Example: 'w' is the first character with a count of 1. Output: 'w'</td>
<td>Easy</td>
<td>Use counting frequency template. Track the index of first unique character.</td>
</tr>
<tr>
<td>4</td>
<td>Group anagrams</td>
<td>Given a list of strings, group anagrams together. Numeric Example: ['eat', 'tea', 'tan', 'ate', 'nat', 'bat'] -&gt; [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]. Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</td>
<td>Medium</td>
<td>Use sorting and hash map to group strings that have the same sorted form.</td>
</tr>
<tr>
<td>5</td>
<td>Subarray sum equals k</td>
<td>Find the number of subarrays that sum to k in the list [1, 2, 3, -2, 1, 4, 5]. Numeric Example: Sum of [1, 2, 3, -2, 1] is 5. Output: 2</td>
<td>Medium</td>
<td>Use prefix sum hash map to track occurrences of sums.</td>
</tr>
<tr>
<td>6</td>
<td>Longest consecutive sequence</td>
<td>Given [100, 4, 200, 1, 3, 2], find the length of the longest consecutive elements sequence. Numeric Example: Sequence [1, 2, 3, 4]. Output: 4</td>
<td>Medium</td>
<td>Use hash set to track and find the longest sequence.</td>
</tr>
<tr>
<td>7</td>
<td>Find duplicates in array</td>
<td>Find all the duplicates in a list [4, 3, 2, 7, 8, 2, 3, 1]. Numeric Example: Duplicate elements are 2 and 3. Output: [2, 3]</td>
<td>Easy</td>
<td>Use counting frequency template to identify elements with count &gt; 1.</td>
</tr>
<tr>
<td>8</td>
<td>Top k frequent elements</td>
<td>Find the top 2 frequent elements from [1, 1, 1, 2, 2, 3]. Numeric Example: Frequencies are {1: 3, 2: 2, 3: 1}. Output: [1, 2]</td>
<td>Medium</td>
<td>Use frequency counting and max heap to identify top k elements.</td>
</tr>
<tr>
<td>9</td>
<td>Minimum window substring</td>
<td>Given strings &quot;ADOBECODEBANC&quot; and &quot;ABC&quot;, find the minimum window that contains all characters of &quot;ABC&quot;. Numeric Example: Minimum window is &quot;BANC&quot;. Output: &quot;BANC&quot;</td>
<td>Hard</td>
<td>Use sliding window with character frequency hash map.</td>
</tr>
<tr>
<td>10</td>
<td>First recurring character</td>
<td>Find the first recurring character in the string &quot;abcdefga&quot;. Numeric Example: 'a' is the first repeating character. Output: 'a'</td>
<td>Easy</td>
<td>Use hash map to track first occurrence of each character.</td>
</tr>
<tr>
<td>11</td>
<td>Longest substring without repeating characters</td>
<td>Find the longest substring without repeating characters in &quot;abcabcbb&quot;. Numeric Example: &quot;abc&quot; has length 3. Output: &quot;abc&quot;</td>
<td>Medium</td>
<td>Use sliding window and hash set to track characters.</td>
</tr>
<tr>
<td>12</td>
<td>Intersection of two arrays</td>
<td>Given arrays [1, 2, 2, 1] and [2, 2], find their intersection. Numeric Example: Intersection is [2]. Output: [2]</td>
<td>Easy</td>
<td>Use hash map to store counts of elements in one array and find matches in the other.</td>
</tr>
<tr>
<td>13</td>
<td>Isomorphic strings</td>
<td>Determine if two strings &quot;egg&quot; and &quot;add&quot; are isomorphic. Numeric Example: Mapping 'e' to 'a', 'g' to 'd'. Output: True</td>
<td>Easy</td>
<td>Use two hash maps to store character mappings between strings.</td>
</tr>
<tr>
<td>14</td>
<td>K-diff pairs in an array</td>
<td>Find pairs with difference k = 2 in array [3, 1, 4, 1, 5]. Numeric Example: Pairs are (1, 3) and (3, 5). Output: 2</td>
<td>Medium</td>
<td>Use hash map to track occurrences and look for complements.</td>
</tr>
<tr>
<td>15</td>
<td>Maximum size subarray sum equals k</td>
<td>Given array [1, -1, 5, -2, 3] and k = 3, find the maximum length of a subarray that sums to k. Numeric Example: Maximum length is 4 for subarray [1, -1, 5, -2]. Output: 4</td>
<td>Medium</td>
<td>Use prefix sum with hash map to track indices of cumulative sums.</td>
</tr>
<tr>
<td>16</td>
<td>Happy number</td>
<td>Determine if 19 is a happy number. Numeric Example: Sum of squares: 1^2 + 9^2 = 82. Eventually reaches 1. Output: True</td>
<td>Easy</td>
<td>Use hash set to track sums of squares and detect cycles.</td>
</tr>
<tr>
<td>17</td>
<td>Longest palindrome substring</td>
<td>Find the longest palindromic substring in &quot;babad&quot;. Numeric Example: Longest palindromes are &quot;bab&quot; or &quot;aba&quot;. Output: &quot;bab&quot; or &quot;aba&quot;</td>
<td>Medium</td>
<td>Use dynamic programming and hash map to track possible palindromes.</td>
</tr>
<tr>
<td>18</td>
<td>Longest harmonious subsequence</td>
<td>Find the longest harmonious subsequence in [1, 3, 2, 2, 5, 2, 3, 7]. Numeric Example: Harmonious subsequence is [3, 2, 2, 2, 3]. Output: 5</td>
<td>Medium</td>
<td>Use hash map to track counts of elements and their neighbors.</td>
</tr>
<tr>
<td>19</td>
<td>Bulls and Cows game</td>
<td>Given secret &quot;1807&quot; and guess &quot;7810&quot;, calculate bulls and cows. Numeric Example: Bulls = 1 (&quot;8&quot;), Cows = 3 (&quot;7&quot;, &quot;1&quot;, &quot;0&quot;). Output: &quot;1A3B&quot;</td>
<td>Medium</td>
<td>Use hash map to track frequency counts of digits for bulls and cows calculation.</td>
</tr>
<tr>
<td>20</td>
<td>Word pattern</td>
<td>Check if pattern &quot;abba&quot; matches string &quot;dog cat cat dog&quot;. Numeric Example: Mapping pattern 'a' to 'dog' and 'b' to 'cat'. Output: True</td>
<td>Easy</td>
<td>Use two hash maps to establish mapping between pattern and words.</td>
</tr>
<tr>
<td>21</td>
<td>Subarray sum divisible by k</td>
<td>Find the number of subarrays divisible by k = 5 in [4, 5, 0, -2, -3, 1]. Numeric Example: Total subarrays = 7. Output: 7</td>
<td>Medium</td>
<td>Use prefix sum with hash map to track modulo results.</td>
</tr>
<tr>
<td>22</td>
<td>Fraction to recurring decimal</td>
<td>Convert 4/333 to a recurring decimal. Numeric Example: Decimal is &quot;0.(012)&quot;. Output: &quot;0.(012)&quot;</td>
<td>Medium</td>
<td>Use hash map to store remainders to detect cycles.</td>
</tr>
<tr>
<td>23</td>
<td>Find all anagrams in a string</td>
<td>Find all start indices of anagrams of &quot;abc&quot; in &quot;cbaebabacd&quot;. Numeric Example: Start indices are [0, 6]. Output: [0, 6]</td>
<td>Medium</td>
<td>Use sliding window and character frequency hash map.</td>
</tr>
<tr>
<td>24</td>
<td>Maximum width of binary tree</td>
<td>Find the maximum width of a binary tree given its nodes. Numeric Example: Width of binary tree = 4. Output: Integer</td>
<td>Medium</td>
<td>Use BFS with hash map to track positions at each level.</td>
</tr>
<tr>
<td>25</td>
<td>Valid Sudoku</td>
<td>Determine if a 9x9 Sudoku board is valid. Numeric Example: Check rows, columns, and 3x3 boxes for duplicates. Output: True/False</td>
<td>Medium</td>
<td>Use hash map to track rows, columns, and 3x3 sub-boxes.</td>
</tr>
<tr>
<td>26</td>
<td>Continuous subarray sum</td>
<td>Given an array, find if there is a subarray with sum that is a multiple of k. Numeric Example: Subarray sum is multiple of k. Output: True</td>
<td>Medium</td>
<td>Use prefix sum and hash map to track mod values.</td>
</tr>
<tr>
<td>27</td>
<td>Find duplicate subtrees</td>
<td>Find all duplicate subtrees in a binary tree. Numeric Example: List of duplicate root nodes. Output: List of duplicate root nodes</td>
<td>Hard</td>
<td>Use hash map with serialization to detect duplicates.</td>
</tr>
<tr>
<td>28</td>
<td>Longest repeating character replacement</td>
<td>Replace characters to get the longest repeating character sequence. Numeric Example: Length of longest sequence = Integer. Output: Integer</td>
<td>Medium</td>
<td>Use sliding window and hash map to track character counts.</td>
</tr>
<tr>
<td>29</td>
<td>Binary tree vertical order traversal</td>
<td>Traverse a binary tree vertically and return nodes in each vertical level. Numeric Example: Nodes at each vertical level. Output: List</td>
<td>Hard</td>
<td>Use BFS with hash map to track nodes in vertical columns.</td>
</tr>
<tr>
<td>30</td>
<td>Find all pairs with a given difference</td>
<td>Given an array and a difference value, find all unique pairs. Numeric Example: Unique pairs are found. Output: List of pairs</td>
<td>Medium</td>
<td>Use hash map to track values and find complements.</td>
</tr>
</tbody>
</table>
<h3 id="9-key-takeaways-tips-and-summary">9. Key Takeaways, Tips, and Summary</h3>
<ul>
<li><strong>Key Takeaways</strong>: Hash Maps provide efficient lookup and insertion capabilities, making them ideal for problems requiring quick access.</li>
<li><strong>Practical Tips</strong>: Always handle edge cases, such as collisions or non-unique keys, appropriately.</li>
<li><strong>Summary</strong>: Hash Maps are versatile and efficient for a wide range of problems, especially those involving frequency counting, mapping relationships, or finding pairs.</li>
</ul>
<h3 id="10-common-pitfalls">10. Common Pitfalls</h3>
<ul>
<li><strong>Mistakes to Avoid</strong>: Forgetting to handle key collisions or assuming keys are unique can lead to incorrect results.</li>
<li><strong>Troubleshooting Tips</strong>: Use print statements or a debugger to inspect the Hash Map at each step to ensure keys are being added and updated as expected.</li>
</ul>
<p>Here are detailed explanations for 7 random practice problems from the list:</p>
<h3 id="1-problem-3-find-first-unique-character">1. Problem 3: Find First Unique Character</h3>
<p><strong>Problem Statement</strong>: Given the string <code>&quot;swiss&quot;</code>, find the first unique character.<br>
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>&quot;swiss&quot;</code></li>
<li>The character occurrences are: <code>'s': 3, 'w': 1, 'i': 1</code>.</li>
<li>The first character with a count of <code>1</code> is <code>'w'</code>.</li>
<li><strong>Output</strong>: <code>'w'</code>.</li>
</ul>
<p><strong>Explanation</strong>:
We iterate through the string and use a hash map to count the frequency of each character. After building the frequency map, we iterate again through the string to find the first character with a count of <code>1</code>.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Python implementation to find the first unique character.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first_unique_character</span><span class="hljs-params">(s)</span>:</span>
    frequency_map = {}
    <span class="hljs-comment"># Count frequencies of each character.</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:
        frequency_map[char] = frequency_map.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
    <span class="hljs-comment"># Find the first unique character.</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> frequency_map[char] == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> char
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

s = <span class="hljs-string">"swiss"</span>
print(first_unique_character(s))  <span class="hljs-comment"># Output: 'w'</span>
</div></code></pre>
<h3 id="2-problem-4-group-anagrams">2. Problem 4: Group Anagrams</h3>
<p><strong>Problem Statement</strong>: Given a list of strings, group anagrams together.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>['eat', 'tea', 'tan', 'ate', 'nat', 'bat']</code></li>
<li>Anagrams are grouped as: <code>[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</code></li>
<li><strong>Output</strong>: <code>[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a hash map to group words by their sorted form. The sorted form is used as the key, and the values are lists of words that are anagrams.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Python implementation to group anagrams.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">group_anagrams</span><span class="hljs-params">(words)</span>:</span>
    anagrams = {}
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:
        sorted_word = <span class="hljs-string">''</span>.join(sorted(word))
        <span class="hljs-keyword">if</span> sorted_word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> anagrams:
            anagrams[sorted_word] = []
        anagrams[sorted_word].append(word)
    <span class="hljs-keyword">return</span> list(anagrams.values())

words = [<span class="hljs-string">'eat'</span>, <span class="hljs-string">'tea'</span>, <span class="hljs-string">'tan'</span>, <span class="hljs-string">'ate'</span>, <span class="hljs-string">'nat'</span>, <span class="hljs-string">'bat'</span>]
print(group_anagrams(words))  <span class="hljs-comment"># Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]</span>
</div></code></pre>
<h3 id="3-problem-6-longest-consecutive-sequence">3. Problem 6: Longest Consecutive Sequence</h3>
<p><strong>Problem Statement</strong>: Given <code>[100, 4, 200, 1, 3, 2]</code>, find the length of the longest consecutive elements sequence.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>[100, 4, 200, 1, 3, 2]</code></li>
<li>The longest sequence is <code>[1, 2, 3, 4]</code>.</li>
<li><strong>Output</strong>: <code>4</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a hash set to store the numbers. For each number, if it's the start of a sequence (i.e., <code>num - 1</code> is not in the set), we count how long the sequence continues.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Python implementation to find the longest consecutive sequence.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest_consecutive</span><span class="hljs-params">(nums)</span>:</span>
    num_set = set(nums)
    longest_streak = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_set:
        <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_set:
            current_num = num
            current_streak = <span class="hljs-number">1</span>

            <span class="hljs-keyword">while</span> current_num + <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> num_set:
                current_num += <span class="hljs-number">1</span>
                current_streak += <span class="hljs-number">1</span>

            longest_streak = max(longest_streak, current_streak)

    <span class="hljs-keyword">return</span> longest_streak

nums = [<span class="hljs-number">100</span>, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
print(longest_consecutive(nums))  <span class="hljs-comment"># Output: 4</span>
</div></code></pre>
<h3 id="4-problem-7-find-duplicates-in-array">4. Problem 7: Find Duplicates in Array</h3>
<p><strong>Problem Statement</strong>: Find all the duplicates in a list <code>[4, 3, 2, 7, 8, 2, 3, 1]</code>.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>[4, 3, 2, 7, 8, 2, 3, 1]</code></li>
<li>Duplicate elements are <code>2</code> and <code>3</code>.</li>
<li><strong>Output</strong>: <code>[2, 3]</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a hash map to count occurrences of each element. Elements with counts greater than <code>1</code> are duplicates.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Python implementation to find duplicates in an array.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_duplicates</span><span class="hljs-params">(arr)</span>:</span>
    frequency_map = {}
    duplicates = []

    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:
        frequency_map[num] = frequency_map.get(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>

    <span class="hljs-keyword">for</span> num, count <span class="hljs-keyword">in</span> frequency_map.items():
        <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span>:
            duplicates.append(num)

    <span class="hljs-keyword">return</span> duplicates

arr = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]
print(find_duplicates(arr))  <span class="hljs-comment"># Output: [2, 3]</span>
</div></code></pre>
<h3 id="5-problem-8-top-k-frequent-elements">5. Problem 8: Top K Frequent Elements</h3>
<p><strong>Problem Statement</strong>: Find the top <code>2</code> frequent elements from <code>[1, 1, 1, 2, 2, 3]</code>.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>[1, 1, 1, 2, 2, 3]</code></li>
<li>Frequencies are: <code>{1: 3, 2: 2, 3: 1}</code></li>
<li>Top <code>2</code> frequent elements are <code>[1, 2]</code>.</li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a hash map to count frequencies, and a max heap to keep track of the top <code>k</code> frequent elements.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
<span class="hljs-keyword">import</span> heapq

<span class="hljs-comment"># Python implementation to find the top k frequent elements.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_k_frequent</span><span class="hljs-params">(nums, k)</span>:</span>
    frequency_map = Counter(nums)
    <span class="hljs-keyword">return</span> heapq.nlargest(k, frequency_map.keys(), key=frequency_map.get)

nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
k = <span class="hljs-number">2</span>
print(top_k_frequent(nums, k))  <span class="hljs-comment"># Output: [1, 2]</span>
</div></code></pre>
<h3 id="6-problem-9-minimum-window-substring">6. Problem 9: Minimum Window Substring</h3>
<p><strong>Problem Statement</strong>: Given strings <code>&quot;ADOBECODEBANC&quot;</code> and <code>&quot;ABC&quot;</code>, find the minimum window that contains all characters of <code>&quot;ABC&quot;</code>.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>&quot;ADOBECODEBANC&quot;</code>, <code>&quot;ABC&quot;</code></li>
<li>The minimum window that contains <code>'A'</code>, <code>'B'</code>, <code>'C'</code> is <code>&quot;BANC&quot;</code>.</li>
<li><strong>Output</strong>: <code>&quot;BANC&quot;</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a sliding window approach to adjust the window size dynamically and keep track of the character count needed using a hash map.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

<span class="hljs-comment"># Python implementation to find the minimum window substring.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_window</span><span class="hljs-params">(s, t)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>

    dict_t = Counter(t)
    required = len(dict_t)
    l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    formed = <span class="hljs-number">0</span>
    window_counts = {}
    ans = float(<span class="hljs-string">"inf"</span>), <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>

    <span class="hljs-keyword">while</span> r &lt; len(s):
        char = s[r]
        window_counts[char] = window_counts.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> dict_t <span class="hljs-keyword">and</span> window_counts[char] == dict_t[char]:
            formed += <span class="hljs-number">1</span>

        <span class="hljs-keyword">while</span> l &lt;= r <span class="hljs-keyword">and</span> formed == required:
            char = s[l]
            <span class="hljs-keyword">if</span> r - l + <span class="hljs-number">1</span> &lt; ans[<span class="hljs-number">0</span>]:
                ans = (r - l + <span class="hljs-number">1</span>, l, r)

            window_counts[char] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> dict_t <span class="hljs-keyword">and</span> window_counts[char] &lt; dict_t[char]:
                formed -= <span class="hljs-number">1</span>

            l += <span class="hljs-number">1</span>

        r += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> <span class="hljs-keyword">if</span> ans[<span class="hljs-number">0</span>] == float(<span class="hljs-string">"inf"</span>) <span class="hljs-keyword">else</span> s[ans[<span class="hljs-number">1</span>]: ans[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>]

s = <span class="hljs-string">"ADOBECODEBANC"</span>
t = <span class="hljs-string">"ABC"</span>
print(min_window(s, t))  <span class="hljs-comment"># Output: "BANC"</span>
</div></code></pre>
<h3 id="7-problem-11-longest-substring-without-repeating-characters">7. Problem 11: Longest Substring Without Repeating Characters</h3>
<p><strong>Problem Statement</strong>: Find the longest substring without repeating characters in <code>&quot;abcabcbb&quot;</code>.
<strong>Numeric Example</strong>:</p>
<ul>
<li>Input: <code>&quot;abcabcbb&quot;</code></li>
<li>The longest substring without repeating characters is <code>&quot;abc&quot;</code>.</li>
<li><strong>Output</strong>: <code>&quot;abc&quot;</code></li>
</ul>
<p><strong>Explanation</strong>:
We use a sliding window approach to keep track of the current substring without repeating characters, adjusting the window as we encounter duplicates.</p>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Python implementation to find the longest substring without repeating characters.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longest_substring_without_repeating</span><span class="hljs-params">(s)</span>:</span>
    char_index_map = {}
    left = <span class="hljs-number">0</span>
    max_length = <span class="hljs-number">0</span>
    start = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> range(len(s)):
        <span class="hljs-keyword">if</span> s[right] <span class="hljs-keyword">in</span> char_index_map <span class="hljs-keyword">and</span> char_index_map[s[right]] &gt;= left:
            left = char_index_map[s[right]] + <span class="hljs-number">1</span>
        char_index_map[s[right]] = right
        <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &gt; max_length:
            max_length = right - left + <span class="hljs-number">1</span>
            start = left

    <span class="hljs-keyword">return</span> s[start:start + max_length]

s = <span class="hljs-string">"abcabcbb"</span>
print(longest_substring_without_repeating(s))  <span class="hljs-comment"># Output: "abc"</span>
</div></code></pre>
<p>These explanations include the problem statement, a detailed numeric example, and Python code implementations for solving each problem.</p>

</body>
</html>
