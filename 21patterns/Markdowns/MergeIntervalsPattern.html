<!DOCTYPE html>
<html>
<head>
<title>MergeIntervalsPattern.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="merge-intervals-comprehensive-guide"><strong>Merge Intervals: Comprehensive Guide</strong></h1>
<p>The Merge Intervals pattern is a fundamental technique for dealing with overlapping intervals in a variety of scenarios. It is commonly used in scheduling problems, merging time slots, and finding the union of ranges. This pattern ensures that overlapping ranges are consolidated into non-overlapping intervals, making it an essential tool in interval-based problem solving.</p>
<h2 id="1-core-concepts-and-coding-patterns">1. Core Concepts and Coding Patterns</h2>
<p>The <strong>Merge Intervals</strong> pattern is used to deal with overlapping intervals. The fundamental idea is to <strong>sort the intervals</strong> based on the starting point, then iterate over the sorted list to merge overlapping intervals. This approach ensures that all overlapping ranges are consolidated into one, resulting in a set of non-overlapping intervals.</p>
<p><strong>Typical Use Cases</strong>:</p>
<ul>
<li>Merging overlapping meeting times</li>
<li>Identifying free time slots from a schedule</li>
<li>Finding union of time-based data</li>
</ul>
<h2 id="2-example">2. Example</h2>
<p>This example demonstrates how to apply the Merge Intervals pattern to combine overlapping intervals into a set of non-overlapping intervals. It illustrates the steps of sorting the intervals and merging them as needed. Given a set of intervals, such as: <strong>[[1, 3], [2, 6], [8, 10], [15, 18]]</strong></p>
<ul>
<li><strong>Step 1</strong>: Sort intervals by starting value: <strong>[[1, 3], [2, 6], [8, 10], [15, 18]]</strong></li>
<li><strong>Step 2</strong>: Iterate through intervals:
<ul>
<li>Merge <strong>[1, 3]</strong> and <strong>[2, 6]</strong> into <strong>[1, 6]</strong>.</li>
<li>No overlap between <strong>[1, 6]</strong> and <strong>[8, 10]</strong>.</li>
<li>No overlap between <strong>[8, 10]</strong> and <strong>[15, 18]</strong>.</li>
</ul>
</li>
<li><strong>Result</strong>: <strong>[[1, 6], [8, 10], [15, 18]]</strong></li>
</ul>
<h3 id="3-problem-identification-checklist">3. Problem Identification Checklist</h3>
<p>To identify problems suitable for the Merge Intervals pattern, look for:</p>
<ul>
<li><strong>Intervals that need to be combined</strong> due to overlaps.</li>
<li><strong>Union or scheduling problems</strong>.</li>
<li><strong>Range-based operations</strong> such as finding free slots or removing overlaps.</li>
</ul>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Indicators</th>
</tr>
</thead>
<tbody>
<tr>
<td>Merge overlapping time slots</td>
<td>Intervals with start and end times that overlap.</td>
</tr>
<tr>
<td>Consolidate free meeting slots</td>
<td>Given busy times, determine free intervals.</td>
</tr>
</tbody>
</table>
<h3 id="4-general-templates-with-comments">4. General Templates with Comments</h3>
<h4 id="template-1-basic-merge-intervals">Template 1: Basic Merge Intervals</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_intervals</span><span class="hljs-params">(intervals: List[List[int]])</span> -&gt; List[List[int]]:</span>
    <span class="hljs-comment"># Step 1: Sort the intervals by the starting value</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    merged = []

    <span class="hljs-comment"># Step 2: Iterate through each interval</span>
    <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals:
        <span class="hljs-comment"># If the merged list is empty or current interval does not overlap</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> merged <span class="hljs-keyword">or</span> merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]:
            merged.append(interval)  <span class="hljs-comment"># No overlap, add the interval</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Overlapping intervals, merge them</span>
            merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])

    <span class="hljs-keyword">return</span> merged
</div></code></pre>
<p><strong>Use Case</strong>: This template is applicable to any problem where the goal is to <strong>merge overlapping intervals</strong>, such as scheduling.</p>
<p><strong>Time Complexity</strong>: <strong>O(N log N)</strong> due to sorting, where <strong>N</strong> is the number of intervals.</p>
<p><strong>Space Complexity</strong>: <strong>O(N)</strong> for the output list.</p>
<h3 id="5-complexity-analysis">5. Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: Sorting takes <strong>O(N log N)</strong>, and merging takes <strong>O(N)</strong>, resulting in <strong>O(N log N)</strong> overall.</li>
<li><strong>Space Complexity</strong>: Since we use extra space for the merged output, the space complexity is <strong>O(N)</strong>.</li>
<li><strong>Optimization Opportunities</strong>: Use in-place merging where applicable to save space.</li>
</ul>
<h3 id="6-discussion-on-templates-and-patterns">6. Discussion on Templates and Patterns</h3>
<p>The basic template works well for a variety of merging tasks, but adjustments may be needed depending on <strong>additional constraints</strong> (e.g., finding the gaps between merged intervals).</p>
<h3 id="7-multiple-approaches-and-implementations">7. Multiple Approaches and Implementations</h3>
<h4 id="iterative-vs-recursive">Iterative vs. Recursive</h4>
<ul>
<li><strong>Iterative</strong>: The above template is iterative, providing a straightforward way to merge intervals.</li>
<li><strong>Recursive</strong>: A recursive approach is possible but usually results in higher space complexity due to function call stacks.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_intervals_recursive</span><span class="hljs-params">(intervals: List[List[int]], index: int = <span class="hljs-number">0</span>)</span> -&gt; List[List[int]]:</span>
    <span class="hljs-keyword">if</span> index == len(intervals) - <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> [intervals[index]]
    
    <span class="hljs-comment"># Recursive call to merge the remaining intervals</span>
    merged_intervals = merge_intervals_recursive(intervals, index + <span class="hljs-number">1</span>)
    current_interval = intervals[index]
    
    <span class="hljs-comment"># If there is overlap, merge the current interval with the first in merged_intervals</span>
    <span class="hljs-keyword">if</span> merged_intervals <span class="hljs-keyword">and</span> current_interval[<span class="hljs-number">1</span>] &gt;= merged_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:
        merged_intervals[<span class="hljs-number">0</span>] = [
            min(current_interval[<span class="hljs-number">0</span>], merged_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]),
            max(current_interval[<span class="hljs-number">1</span>], merged_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])
        ]
    <span class="hljs-keyword">else</span>:
        merged_intervals.insert(<span class="hljs-number">0</span>, current_interval)
    
    <span class="hljs-keyword">return</span> merged_intervals
</div></code></pre>
<h4 id="iterative-vs-recursive">Iterative vs. Recursive</h4>
<ul>
<li><strong>Iterative</strong>: The above template is iterative, providing a straightforward way to merge intervals.</li>
<li><strong>Recursive</strong>: A recursive approach is possible but usually results in higher space complexity due to function call stacks.</li>
</ul>
<h3 id="8-comparative-analysis">8. Comparative Analysis</h3>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterative</td>
<td>Simple, more efficient</td>
<td>Can be verbose in edge cases</td>
</tr>
<tr>
<td>Recursive</td>
<td>Elegant in theory</td>
<td>Higher space complexity, harder to debug</td>
</tr>
</tbody>
</table>
<h3 id="9-practice-problems">9. Practice Problems</h3>
<table>
<thead>
<tr>
<th>S.No</th>
<th>Question</th>
<th>Example (detailed explanation with numeric details and output)</th>
<th>Difficulty Level</th>
<th>Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Merge overlapping intervals</td>
<td>Given intervals [[1, 4], [2, 5]], the intervals overlap as 2 is within [1, 4]. Hence, we merge them into [1, 5]. The output is [[1, 5]].</td>
<td>Easy</td>
<td>Basic Merge Intervals Template. Sort the intervals, iterate through them, and merge overlapping ones using a merged list. No extra variables are required beyond the merged list.</td>
</tr>
<tr>
<td>2</td>
<td>Find free time slots</td>
<td>Given busy time intervals [[1, 3], [6, 9]], the free time slot between them is from 3 to 6. Thus, the output is [[3, 6]].</td>
<td>Medium</td>
<td>Modified Merge Intervals Template. Sort intervals and find gaps between them. Use additional variables to track previous interval end times.</td>
</tr>
<tr>
<td>3</td>
<td>Insert interval</td>
<td>Given intervals [[1, 3], [6, 9]] and a new interval [2, 5], we insert [2, 5] and merge it with [1, 3] resulting in [1, 5]. The output is [[1, 5], [6, 9]].</td>
<td>Medium</td>
<td>Insert and Merge Pattern. Insert the interval into the correct position, then apply the Merge Intervals Template. Use extra variables for insertion index and merged result tracking.</td>
</tr>
<tr>
<td>4</td>
<td>Employee free time</td>
<td>Given busy schedules [[1, 3], [5, 6]] and [[2, 3], [6, 8]], the free time available for all employees is from 3 to 5. Thus, the output is [[3, 5]].</td>
<td>Hard</td>
<td>Merge Intervals followed by Gap Identification. First, merge all intervals, then iterate to find gaps. Use extra variables to store merged results and track free time intervals.</td>
</tr>
<tr>
<td>5</td>
<td>Interval list intersections</td>
<td>Given two lists of intervals [[1, 3], [5, 9]] and [[2, 5], [7, 10]], the intersections are [2, 3], [5, 5], and [7, 9]. Thus, the output is [[2, 3], [5, 5], [7, 9]].</td>
<td>Medium</td>
<td>Two Pointers Approach. Traverse both interval lists simultaneously using pointers, and find overlapping sections. Use two pointers to track current intervals in both lists.</td>
</tr>
<tr>
<td>6</td>
<td>Meeting rooms II</td>
<td>Given meeting intervals [[0, 30], [5, 10], [15, 20]], we need to find the minimum number of meeting rooms required. The result is 2 because the intervals overlap such that two rooms are required at most.</td>
<td>Medium</td>
<td>Heap / Priority Queue Pattern. Use a min-heap to keep track of ongoing meetings and determine room requirements. Extra variables include a heap for meeting end times.</td>
</tr>
<tr>
<td>7</td>
<td>Minimum number of arrows to burst balloons</td>
<td>Given intervals representing the range of balloons [[10, 16], [2, 8], [1, 6], [7, 12]], the minimum number of arrows required to burst all the balloons is 2, as some of the ranges overlap and can be burst with the same arrow.</td>
<td>Medium</td>
<td>Basic Merge Intervals Template. Sort intervals by their end points, then iterate through to determine the number of non-overlapping groups. Extra variable for counting arrows.</td>
</tr>
<tr>
<td>8</td>
<td>Merge k sorted interval lists</td>
<td>Given k sorted lists of intervals [[[1, 4], [7, 10]], [[3, 5], [8, 12]]], the merged result is [[1, 5], [7, 12]]. This is done by merging overlapping intervals across all lists.</td>
<td>Hard</td>
<td>Merge Intervals with Min-Heap. Use a heap to efficiently track the smallest current interval across k lists. Extra variable for heap structure to maintain sorted order.</td>
</tr>
<tr>
<td>9</td>
<td>Remove covered intervals</td>
<td>Given intervals [[1, 4], [3, 6], [2, 8]], we need to remove intervals that are covered by others. In this case, [1, 4] and [3, 6] are covered by [2, 8], so the output is [[2, 8]].</td>
<td>Medium</td>
<td>Sort Intervals by Start and Length, then iterate to identify covered intervals. Use an extra variable to track the maximum end encountered so far.</td>
</tr>
<tr>
<td>10</td>
<td>Car pooling</td>
<td>Given trip requests [[2, 1, 5], [3, 3, 7]], where each trip is represented as [num_passengers, start_location, end_location], we need to determine if it is possible to pick up and drop off all passengers with the given capacity. The output is False as the car capacity is exceeded at one point.</td>
<td>Medium</td>
<td>Sweep Line Algorithm. Use events for start and end points of trips, and calculate the number of passengers at each point. Extra variables for storing events and passenger counts.</td>
</tr>
<tr>
<td>11</td>
<td>Add bold tag in string</td>
<td>Given string &quot;abcxyz123&quot; and intervals [[1, 3], [2, 4]], we need to add bold tags around the specified intervals. After merging overlapping intervals, the output string is &quot;abcxyz123&quot;.</td>
<td>Medium</td>
<td>Merge Intervals Template. First merge the overlapping intervals, then use the merged intervals to add the bold tags. Extra variable for storing the merged intervals and applying the bold tags in the string.</td>
</tr>
<tr>
<td>12</td>
<td>Split intervals to avoid overlaps</td>
<td>Given intervals [[1, 5], [2, 3], [4, 6]], we need to determine the minimum number of intervals to remove to avoid any overlaps. The output is 2, as removing [2, 3] and [4, 6] avoids overlaps.</td>
<td>Hard</td>
<td>Greedy Approach. Sort intervals by end time, and iterate to find the minimum number of intervals to remove. Use an extra variable to keep track of the last non-overlapping interval's end time.</td>
</tr>
<tr>
<td>13</td>
<td>Maximum CPU load</td>
<td>Given tasks represented by intervals with CPU load [[1, 4, 3], [2, 5, 4], [7, 9, 6]], the maximum CPU load at any point in time is 7. This is found by summing the overlapping intervals' loads.</td>
<td>Hard</td>
<td>Sweep Line + Heap. Use a sweep line approach to add and remove CPU loads as intervals start and end. Use a heap to efficiently keep track of the current loads. Extra variables for tracking load events and the heap.</td>
</tr>
<tr>
<td>14</td>
<td>Count of range sums</td>
<td>Given an array [-2, 5, -1] and a range [0, 2], we need to find the count of range sums that lie in the given range. The result is 3, as three subarrays have sums within this range.</td>
<td>Hard</td>
<td>Divide and Conquer. Split the array and count the range sums in each part, then combine results. Extra variables for storing temporary sums during merge steps.</td>
</tr>
<tr>
<td>15</td>
<td>Range addition</td>
<td>Given operations [[1, 3, 2], [2, 4, 3], [0, 2, -2]], we need to apply the additions to an initial array of zeros. The result after applying all operations is [2, 3, 1, 3, -2].</td>
<td>Medium</td>
<td>Difference Array Technique. Use a difference array to efficiently apply range updates, then compute the final values. Extra variable for storing the difference array before applying the prefix sum.</td>
</tr>
<tr>
<td>16</td>
<td>Maximum intervals overlap</td>
<td>Given intervals [[1, 5], [2, 6], [3, 7], [10, 15]], the maximum number of overlapping intervals is 3, occurring between times 3 and 5.</td>
<td>Medium</td>
<td>Sweep Line Approach. Use start and end events to determine the number of overlapping intervals at any time. Extra variables for tracking events and maintaining the count of current overlaps.</td>
</tr>
<tr>
<td>17</td>
<td>Merge strings</td>
<td>Given two strings &quot;abc&quot; and &quot;def&quot;, the result of merging them is &quot;abcdef&quot;.</td>
<td>Easy</td>
<td>Simple String Concatenation. Directly concatenate both strings without any additional variables.</td>
</tr>
<tr>
<td>18</td>
<td>Find the intersection of two intervals</td>
<td>Given intervals [1, 5] and [4, 8], the intersection is [4, 5], where the two intervals overlap.</td>
<td>Easy</td>
<td>Basic Interval Intersection. Compare the start and end points of the two intervals to find their intersection. No extra variables required.</td>
</tr>
<tr>
<td>19</td>
<td>Partition labels</td>
<td>Given string &quot;ababcbacadefegdehijhklij&quot;, we need to partition the string into as many parts as possible so that each letter appears in at most one part. The output partitions are [9, 7, 8].</td>
<td>Medium</td>
<td>Greedy + HashMap. Track the last occurrence of each character and partition greedily based on this information. Extra variable for storing the last occurrence index of each character.</td>
</tr>
<tr>
<td>20</td>
<td>Non-overlapping intervals</td>
<td>Given intervals [[1, 2], [2, 3], [3, 4], [1, 3]], we need to remove the minimum number of intervals to make the rest non-overlapping. The output is 1, as removing [1, 3] achieves this.</td>
<td>Medium</td>
<td>Greedy Approach. Sort by end time and iterate to determine the maximum number of non-overlapping intervals. Use an extra variable to track the end time of the last added interval.</td>
</tr>
</tbody>
</table>
<h3 id="10-key-takeaways-tips-and-summary">10. Key Takeaways, Tips, and Summary</h3>
<ul>
<li><strong>Key Takeaways</strong>: Always <strong>sort</strong> intervals first to simplify merging.</li>
<li><strong>Practical Tips</strong>: For complex merging, use a <strong>stack</strong> or <strong>linked list</strong> to keep track of merged intervals. For example, a stack can be particularly useful when you need to compare the latest merged interval with the next incoming interval, allowing you to backtrack easily when overlaps occur.</li>
<li><strong>Summary</strong>: Merge Intervals is a versatile pattern for solving interval-based problems.</li>
</ul>
<h3 id="11-common-pitfalls">11. Common Pitfalls</h3>
<ul>
<li><strong>Mistake</strong>: Forgetting to <strong>sort</strong> the intervals.</li>
<li><strong>Troubleshooting Tips</strong>: Always check the <strong>boundary conditions</strong> for each interval (start and end values).</li>
</ul>
<p>Sure! Here are detailed explanations of 5 randomly selected practice problems along with examples, visualizations, and Python code comments:</p>
<h3 id="1-merge-overlapping-intervals">1. <strong>Merge Overlapping Intervals</strong></h3>
<p><strong>Problem</strong>: Given a list of intervals, merge all overlapping intervals.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
<li>Explanation:
<ul>
<li>Interval <code>[1, 4]</code> overlaps with <code>[2, 5]</code>. Therefore, we merge them to get <code>[1, 5]</code>.</li>
<li><code>[1, 5]</code> does not overlap with <code>[7, 9]</code>.</li>
<li>Final output: <code>[[1, 5], [7, 9]]</code>.</li>
</ul>
</li>
</ul>
<p><strong>Visualization</strong>:</p>
<pre class="hljs"><code><div>   [1, 4]
      [2, 5]
           [7, 9]
After merging: [1, 5], [7, 9]
</div></code></pre>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_intervals</span><span class="hljs-params">(intervals: List[List[int]])</span> -&gt; List[List[int]]:</span>
    <span class="hljs-comment"># Step 1: Sort intervals by start time</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    merged = []
    
    <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals:
        <span class="hljs-comment"># If no overlap, add the interval</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> merged <span class="hljs-keyword">or</span> merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]:
            merged.append(interval)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Merge overlapping intervals</span>
            merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">return</span> merged

<span class="hljs-comment"># Example usage</span>
print(merge_intervals([[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">9</span>]]))  <span class="hljs-comment"># Output: [[1, 5], [7, 9]]</span>
</div></code></pre>
<h3 id="2-find-free-time-slots">2. <strong>Find Free Time Slots</strong></h3>
<p><strong>Problem</strong>: Given busy intervals of multiple employees, find the common free time slots.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>[[1, 3], [6, 9]], [[2, 4], [7, 10]]</code></li>
<li>Explanation:
<ul>
<li>Merge busy slots to get <code>[[1, 4], [6, 10]]</code>.</li>
<li>Free time slot is between <code>4</code> and <code>6</code>.</li>
<li>Output: <code>[[4, 6]]</code>.</li>
</ul>
</li>
</ul>
<p><strong>Visualization</strong>:</p>
<pre class="hljs"><code><div>Employee 1: [1, 3],       [6, 9]
Employee 2:    [2, 4],        [7, 10]
Merged:     [1, 4],       [6, 10]
Free Slot:              [4, 6]
</div></code></pre>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_free_time</span><span class="hljs-params">(intervals: List[List[int]])</span> -&gt; List[List[int]]:</span>
    <span class="hljs-comment"># Step 1: Flatten all intervals</span>
    all_intervals = [interval <span class="hljs-keyword">for</span> sublist <span class="hljs-keyword">in</span> intervals <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> sublist]
    all_intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    
    <span class="hljs-comment"># Step 2: Merge busy intervals</span>
    merged = []
    <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> all_intervals:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> merged <span class="hljs-keyword">or</span> merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]:
            merged.append(interval)
        <span class="hljs-keyword">else</span>:
            merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(merged[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])
    
    <span class="hljs-comment"># Step 3: Find free slots</span>
    free_time = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(merged)):
        free_time.append([merged[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], merged[i][<span class="hljs-number">0</span>]])
    
    <span class="hljs-keyword">return</span> free_time

<span class="hljs-comment"># Example usage</span>
print(find_free_time([[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>]], [[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">10</span>]]]))  <span class="hljs-comment"># Output: [[4, 6]]</span>
</div></code></pre>
<h3 id="3-minimum-number-of-arrows-to-burst-balloons">3. <strong>Minimum Number of Arrows to Burst Balloons</strong></h3>
<p><strong>Problem</strong>: Given a set of balloons represented as intervals, find the minimum number of arrows needed to burst all balloons.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>[[10, 16], [2, 8], [1, 6], [7, 12]]</code></li>
<li>Explanation:
<ul>
<li>Sort by end points: <code>[[1, 6], [2, 8], [7, 12], [10, 16]]</code>.</li>
<li>Use one arrow for <code>[1, 8]</code>, which bursts the first two intervals.</li>
<li>Use a second arrow for <code>[7, 16]</code> to burst the rest.</li>
<li>Output: <code>2</code>.</li>
</ul>
</li>
</ul>
<p><strong>Visualization</strong>:</p>
<pre class="hljs"><code><div>Balloon ranges: [1, 6], [2, 8], [7, 12], [10, 16]
First Arrow: [1, 8]
Second Arrow:       [7, 16]
</div></code></pre>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_arrows_to_burst_balloons</span><span class="hljs-params">(intervals: List[List[int]])</span> -&gt; int:</span>
    <span class="hljs-comment"># Sort intervals by their end points</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
    arrows = <span class="hljs-number">1</span>
    end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(intervals)):
        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt; end:
            arrows += <span class="hljs-number">1</span>
            end = intervals[i][<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">return</span> arrows

<span class="hljs-comment"># Example usage</span>
print(min_arrows_to_burst_balloons([[<span class="hljs-number">10</span>, <span class="hljs-number">16</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">12</span>]]))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h3 id="4-meeting-rooms-ii">4. <strong>Meeting Rooms II</strong></h3>
<p><strong>Problem</strong>: Find the minimum number of meeting rooms required.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>[[0, 30], [5, 10], [15, 20]]</code></li>
<li>Explanation:
<ul>
<li>Meeting <code>[0, 30]</code> overlaps with <code>[5, 10]</code> and <code>[15, 20]</code>.</li>
<li>The maximum number of overlapping meetings at any point is <code>2</code>.</li>
<li>Output: <code>2</code>.</li>
</ul>
</li>
</ul>
<p><strong>Visualization</strong>:</p>
<pre class="hljs"><code><div>Meetings: [0, 30]
           [5, 10]
                  [15, 20]
Overlaps: Two rooms are required simultaneously.
</div></code></pre>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min_meeting_rooms</span><span class="hljs-params">(intervals: List[List[int]])</span> -&gt; int:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    
    <span class="hljs-comment"># Step 1: Sort intervals by start time</span>
    intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
    
    <span class="hljs-comment"># Step 2: Use a min-heap to track end times of meetings</span>
    heap = []
    heapq.heappush(heap, intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(intervals)):
        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt;= heap[<span class="hljs-number">0</span>]:
            heapq.heappop(heap)
        heapq.heappush(heap, intervals[i][<span class="hljs-number">1</span>])
    
    <span class="hljs-keyword">return</span> len(heap)

<span class="hljs-comment"># Example usage</span>
print(min_meeting_rooms([[<span class="hljs-number">0</span>, <span class="hljs-number">30</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">20</span>]]))  <span class="hljs-comment"># Output: 2</span>
</div></code></pre>
<h3 id="5-car-pooling">5. <strong>Car Pooling</strong></h3>
<p><strong>Problem</strong>: Given trip requests as <code>[num_passengers, start_location, end_location]</code>, determine if the car capacity is enough.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>[[2, 1, 5], [3, 3, 7]]</code>, capacity = 4</li>
<li>Explanation:
<ul>
<li>At time <code>1-5</code>, there are <code>2</code> passengers.</li>
<li>At time <code>3-7</code>, <code>3</code> additional passengers are picked up, making a total of <code>5</code>.</li>
<li>Since <code>5 &gt; 4</code>, output is <code>False</code>.</li>
</ul>
</li>
</ul>
<p><strong>Visualization</strong>:</p>
<pre class="hljs"><code><div>Time: 1---5---7
Passengers: 2 at [1, 5], additional 3 at [3, 7]
Capacity Exceeded: 5 &gt; 4
</div></code></pre>
<p><strong>Python Code</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car_pooling</span><span class="hljs-params">(trips: List[List[int]], capacity: int)</span> -&gt; bool:</span>
    events = []
    <span class="hljs-keyword">for</span> trip <span class="hljs-keyword">in</span> trips:
        events.append((trip[<span class="hljs-number">1</span>], trip[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># Start of the trip</span>
        events.append((trip[<span class="hljs-number">2</span>], -trip[<span class="hljs-number">0</span>])) <span class="hljs-comment"># End of the trip</span>
    
    events.sort()
    current_passengers = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">for</span> _, passengers <span class="hljs-keyword">in</span> events:
        current_passengers += passengers
        <span class="hljs-keyword">if</span> current_passengers &gt; capacity:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-comment"># Example usage</span>
print(car_pooling([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]], <span class="hljs-number">4</span>))  <span class="hljs-comment"># Output: False</span>
</div></code></pre>
<p>These detailed examples demonstrate how the Merge Intervals pattern and related approaches can solve real-world problems effectively.</p>

</body>
</html>
